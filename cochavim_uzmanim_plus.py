#!/usr/bin/env python
# coding: utf-8

# In[1]:


####################################################################################################################
                           # מידע כללי על סוג הקובץ ופתיחתו          
####################################################################################################################


#!/usr/bin/env python
# coding: utf-8

# In[1]:


#!/usr/bin/env python
# coding: utf-8

# In[1]:


#!/usr/bin/env python
# coding: utf-8

# In[4]:

# רשימת הספריות שצריך להתקין במיוחד לצורך כוכבים וזמנים
# pip install screeninfo skyfield pytz pyluach jdcal clipboard tzfpy gematriapy pynput platformdirs


####################################################################################################################
                           # הערות וכן מידע על באגים וכן טיוטות של פונקציות וכן ארכיון של דברים שאינם בשימוש          
####################################################################################################################

'''
סיכום הבעיות והפתרונות לדלטא-טי 
היו בעיות חמורות בחישובי הזמנים של התוכנה בעבר הרחוק ובעתיד הרחוק וכן בחישוב משוואת הזמן כשהשתמשתי בסולם זמן של סקייפילד שכולל דלטא-טי רגיל
הבעיות קרו כי השתמשתי בסולם זמן יו.טי.סי. שמתעלם מדלטא_טי במקום בסולם זמן יו.טי.1 שמודע לדלטא_טי
שימו לב: הערך של דלטא-טי הרגיל של סקייפילד הוא כמעט מתאים לערך שנאס"א נותנים. זה אומר שהוא כן מדוייק. 
הבעיה היא רק שסולם הזמן הרגיל של יו-טי-אס בסקייפילד מתעלם מהדלטא-טי ולכן נגרמו כל הבעיות
בתחילה ניסיתי לטפל בבעיות באמצעות הגדרה מותאמת אישית שדלטא_טי יהיה שווה 0.0
עדכון 23.7.2024 דלטא-טי אפס גרם לשגיאות חמורות בירח לכן עברתי להשתמש בסולם זמן מובנה של סקייפילד שהוא יו.טי.1 והוא כמעט מדוייק
בכל זאת יש לו שגיאות של עד בערך 25 שניות בשנת 1 ומידת השגיאה ניתנת לחישוב בפונקצייה calculate_seconds_error_timescale
לצורך זה עיצבתי מחדש הרבה דברים בתוכנה ולכן יש הרבה שינויים
עיקר השינויים הם ביטול כל הגדרות דלטא_טי מיוחד ובמקום זה תחילת שימוש בשתי פונקציות חדשות לעיבוד קלט ופלט של זמן עבור כל התוכנה
1. skyfield_to_cu_time 2. cu_to_skyfield_time
וגם הטריק הבא שנועד לגרום לקלט של זמן עכשוי בפורמט דייט_טיים אך שיהיה בסולם זמן יו.טי.1 כשזה הסולם שבשימוש
skyfield_to_cu_time(ts.now(), location_timezone)
אך התברר שעושה בעיות וכנראה אין בו צורך לכן חזרתי להשתמש ב datetime.now().astimezone(location_timezone)
ועוד טריק שעשה בעיות חמורות
time = skyfield_to_cu_time(ts.from_datetime(time), location_timezone) 
# נראה כאילו קלט זמן רגיל של התוכנה מתנהג כמו יו.טי.1 בלי צורך בהמרה, כל עוד שאין מדובר בתאריכים עבור חישובי סקייפילד
# לסיכום: יש כמה דברים שאני לא יודע למה הם עובדים כפי שהם אבל מכיוון שהם עובדים אני סוגר את התוכנה ככה

# מידע על דלטא טי וחישובו
https://eclipse.gsfc.nasa.gov/SEhelp/deltat2004.html
Outside the period of observations (500 BCE to 2005 CE), the value of ΔT can be extrapolated from 
measured values using the long-term mean parabolic trend:
ראו את כל הדיון שלי ב https://github.com/skyfielders/python-skyfield/issues/904
וגם https://github.com/skyfielders/python-skyfield/issues/976
לחישובי משוואת הזמן בדקתי והשוויתי נתונים מול https://gml.noaa.gov/grad/solcalc/ 
year = 2600
t = (year-1820)/100
ΔT = -20 + 32 * t**2 
ΔT

########## לחשוב האם כדאי לעשות זריחה ושקיעה בקוטב לפי אזימוט השמש במקום לפי גובהה #########
###  לברר מדוע ביום תקופת ניסן יוצא לי 13.5 דקות לאחר השקיעה של 0.833 לא! 3.65 אלא קצת יותר ואולי זה בגלל ההבדל ברפרקציה בין מנת לבין 0.833 ###

# במקום תיבות הטקסט שבהם השתמשתי היה אפשר להשתמש ישירות ב
#from tkinter import scrolledtext
#txt = scrolledtext.ScrolledText(root, width=90, height=50, font= "david 13")

# מידע על יום יוליאני ותאריכים
להמרת תאריכים ויום יוליאני השוויתי מול
https://www.fourmilab.ch/documents/calendar/
ליום יוליאני השוויתי מול
https://ssd.jpl.nasa.gov/tools/jdc/#/jd
כאשר יום יוליאני הוא עם נקודה 5 (כמו חצי) זה השעה של תחילת היממה בלוח הכללי שזה בדיוק שתים עשרה בלילה
יש לשים לב לדבר חשוב מאוד: ספריית סקייפילד וגם הספרייה לחישוב יום יוליאני וגם נאס"א משתמשים בשיטת הספירה של האסטרונומים שיש בה שנה אפס
אך התוכנה הנוכחית כוכבים וזמנים וגם ספריית פיילוח משתמשים בשיטה של ההיסטוריונים שאין שנה אפס אלא השנה שלפני שנת 1 בלוח הלועזי היא שנת מינוס אחד
זה גורם שבשנים לפני אפס יש פער של שנה בין הספריות השונות
# אם בעתיד התוכנה תכלול חישובים עבור שנים לפני הספירה יהיה צריך לקחת בחשבון שבסקייפילד יש שנה אפס
# כמו כן חשוב לזכור שהזמנים של יום יוליאני לא מתחשבים בדלטא-טי ולכן לא תואמים לשעות בפלט של סקייפילד כאשר הפלט הוא ב- יו.טי.1 שכן מתחשב בדלטא-טי
'''

################## דברים שצריך לעשות#################
# לעקוב אחרי הפעילות של יו.טי.סי בשנים 1975 עד 2075 בפונקציית טיים_לוקיישן_טיימזון לעומת שימוש תמיד רק ב יו.טי.1
# לבדוק האם כדאי לעדכן קובץ עבור יו.טי.1 כאן https://rhodesmill.org/skyfield/time.html#ut1-and-downloading-iers-data
# קישור עדכני לקובץ הזה הוא https://datacenter.iers.org/products/eop/rapid/standard/finals2000A.all


####################################################################################################################
                           # משתנה שמחזיק את כל המידע וההסברים לחלון: מידע כללי והסברים          
####################################################################################################################



INFORMATION = ''' מידע כללי והסברים

שימו לב! אם מתג "התוכנה פעילה" אינו מסומן ב-וִי, הפעילות של התוכנה מופסקת ורוב הלחצנים לא פעילים

הרוצה לכוון את השעון העליון באמצעות המקלדת, יבחר את התא הרצוי באמצעות טַאבּ/עכבר המחשב
לאחר שהתא הרצוי נבחר, לחיצה על חץ תחתון במקלדת תפתח את התפריט של תא זה 
הניווט בתפריט יכול להתבצע באמצעות החץ העליון והתחתון שבמקלדת, או באמצעות עכבר המחשב 

התפריטים: "זמנים ואירועים" ו- "זמני הלכה" נועדו לצורך כיוון השעון העליון לזמנים אלו

בתפריט "זמנים ואירועים" יש אופצייה לכיוון השעון לשעה העכשווית לפי שעון המחשב
שימו לב! אם שעון המחשב אינו מכוון - גם שעון התוכנה לא יהיה מכוון
כמו כן ישנה אופצייה "עכשיו-מתעדכן" המערננת את החישובים מחדש בערך כל שניה אחת
כך אפשר לראות בזמן אמת את התקדמות גרמי השמיים במסלולם היומי

בתפריט "ממיר תאריכים ועוד", ניתן לפתוח שלוש תוכנות נלוות: 
ממיר תאריכים לועזי-עברי: כולל אפשרות להמרת והעברת תאריך עברי לתוך השעון הראשי של כוכבים וזמנים
יום הולדת עברי ובר/בת מצווה: הימים בשבוע שבהם יכול לחול יום הולדת עברי, וחישוב תאריך בר/בת מצווה
מידע על שנה עברית: סימן השנה, ופרטי חישוב הלוח העברי הקבוע


תפריט אפשרויות נוספות

כפתור התקנה קבועה של תוכנת כוכבים וזמנים מעתיק קבצים נדרשים לתיקיית כוכבים וזמנים ויוצר קיצור
דרך חדש להפעלת התוכנה. הפעלת התוכנה דרך קיצור הדרך החדש תהיה מהירה יותר

הוראות לגבי המיקומים הגיאוגרפיים
בתפריט: אפשרויות נוספות, ניתן לבצע חמש פעולות חשובות בעניין המיקומים הגיאוגרפיים
ניתן להגדיר מיקום נוכחי כברירת מחדל
ניתן להוסיף מיקום חדש לקובץ המיקומים. לצד מיקום שנוסף ידנית מופיע סולמית
ניתן למחוק מיקום מקובץ המיקומים
ניתן למיין מחדש את המיקומים לפי א-ב. שימו לב! בהפעלה הבאה ניתן להגדיר מחדש מיקום ברירת מחדל
ניתן לאפס את קובץ המיקומים של התוכנה לברירת המחדל שהייתה בהפעלה הראשונה של התוכנה

שימו לב! אם האפשרויות הנ"ל לא גורמות לשום שינוי במיקומים, יש לאפס את קובץ המיקומים ואז לנסות שוב
אם האיפוס לא עוזר, המחשב שלכם יכול לעבוד רק עם המיקומים הבסיסיים של התוכנה

חלון "שעון ההלכה" נועד להציג בצורה מתומצתת את כל הזמנים ההלכתיים החשובים ביותר
שעון שעה זמנית - לידיעת כל זמני היום, מהנץ לשקיעה, התלויים בשעות זמניות 
גובה השמש - לידיעת כל זמני היום שלפני הזריחה ושלאחר השקיעה
כמובן שנדרשת ידיעה מהו גובה השמש או השעה הזמנית הדרושים/המקובלים עבור זמן הלכתי מסויים 
מתחת הכיתוב גרא/מגא מופיע כמה דקות יש בשעה זמנית/שניות בדקה זמנית לכל אחת מהשיטות
מגא מחושב לפי מינוס 16 מעלות בבוקר ובערב המקביל ל 72 דקות בימי השיוויון
כבונוס ניתן גם גובה הירח מהאופק, והאחוזים שעבר הירח מתוך מסלולו החודשי ממולד למולד אמיתי
מתחת הכיתוב שמש/ירח מופיע האזימוט של השמש והירח
התאריך העברי מתחלף בשקיעה ליום הבא, והמילה "ליל" נוספת לפניו מהשקיעה ועד 12 בלילה
לשם יציאה מחלון "שעון ההלכה" יש ללחוץ על אסקייפ הממוקם בפינה השמאלית העליונה של המקלדת

דוחות קטנים - בתפריט אפשרויות נוספות
ניתן לייצר דו"ח של כל זמני היום ליום המבוקש, ולשמור אותו לקובץ
ניתן ליצור דו"ח הכולל פרטים על כוכבי שבת ראשונים הנראים אחרי השקיעה ביום המבוקש
ניתן ליצור דו"ח הכולל פרטים על כוכבי שבת אחרונים הנראים לפני הזריחה ביום המבוקש 
ניתן ליצור דוחות מפורטים על זמני ראיית הירח הראשון בחודש והירח האחרון בחודש

ייצוא קבצים גדולים - בתפריט אפשרויות נוספות
ניתן ליצור מספר קבצי נתונים גולמיים גדולים בפורמט סי.אס.וי. (דומה לאסל) כדלהלן 
כל הנתונים הם עבור החודש/השנה המוצגים בתוכנה ברגע הלחיצה על כפתור ייצור הקובץ 
לוח זמני היום חודשי לכל החודש העברי/הגרגוריאני 
לוח זמני היום שנתי לכל השנה העברית/הגרגוריאנית 
לוח ראיות ירח ראשון/אחרון לכל השנה העברית
שימו לב! אין להשתמש בקבצים הגולמיים (וכן בכל התוכנה) למטרות רווח ללא קבלת אישור מפורש

כל החישובים האסטרונומיים שבתוכנת כוכבים וזמנים בוצעו באמצעות ספריית סקייפילד לפייתון
https://rhodesmill.org/skyfield/
לתאריכים שבין 1.1.1551 לבין 31.12.2649 לפי נתונים שבקובץ אֶפְאֶמְאֶרִיס של נאס"א (הקובץ הבסיסי)
https://ssd.jpl.nasa.gov/ftp/eph/planets/bsp/de440.bsp
ולתאריכים שבין 3.1.1 לבין 31.12.2999 לפי נתונים שבקובץ אֶפְאֶמְאֶרִיס של נאס"א (קובץ מורחב) 
https://ssd.jpl.nasa.gov/ftp/eph/planets/bsp/de441.bsp
קבצי נאס"א אלו מדוייקים במיוחד, ובהם מתבצעים החישובים לשם שליחת חלליות אל גרמי השמיים 

כדי לחשב תאריכים שאינם בטווח הקובץ הבסיסי, אפאמאריס רחב טווח חייב להיות בתיקיית כוכבים וזמנים 
שמו של קובץ האפאמאריס המורחב חייב להיות
de441s.bsp
ניתן להוריד קובץ אפאמאריס מורחב (עד שנת 2999) באתר כוכבים וזמנים (שוקל כ- 300 מגה-בייט)
https://sites.google.com/view/cochavim-uzmanim/
לאחר הורדת קובץ אפאמאריס מורחב יש לשים אותו בתיקיית כוכבים וזמנים. פתיחת התיקייה כדלהלן
בחלון אפשרויות נוספות יש ללחוץ על:  פתיחת תיקיית כוכבים וזמנים
כדאי להזהר לא לשנות בטעות קבצים בתיקיית כוכבים וזמנים

קיים קובץ אפאמאריס של נאס"א גם לשנים שלפני הספירה הנוצרית אך זמנים אלו לא נתמכים בתוכנה זו
רק בגלל מגבלה של ספריית הזמנים הבסיסית של פייתון שלא תומכת בשנים שלפני הספירה הנוצרית

שימו לב: למידע נוסף על הדיוק של דלטא-טי עבור אירועים לפני/בעוד מאות שנים משוער , ראו
https://eclipse.gsfc.nasa.gov/SEhelp/deltat2004.html

שימו לב: בעבור רוב השנים, סולם הזמן המשמש בתוכנה הוא
UT1 
המשקלל בתוכו את דלטא-טי. זה גורם שסולם הזמן הזה הוא המתאים לשקף את היממה השמשית בכדור הארץ
אמנם: בין השנים 1972 ל- 2072 משמש בתוכנה סולם הזמן 
UTC 
שהחל משנת 1972 משקלל בתוכו את דלטא-טי. החל משנת 1972 סולם הזמן יו.טי.סי שומר שלא להתרחק 
מסולם הזמן יו.טי.1 ביותר מ- 0.9 שניות, והוא עושה זאת באמעות הוספת שניות: שניות קפיצה 
לסולם הזמן יו.טי.1 לפי חישובי סקייפילד יש שגיאה מסויימת שמצטברת ל-בערך 21 שניות בשנת 1 לספיה"נ
בחלון אפשרויות נוספות ניתן לקבל מידע על סולם הזמן שבשימוש ומידת השגיאה שלו לשנה המבוקשת
השגיאה אינה משפיעה על חישוב אירועים אסטרונומיים אלא על: מה השעה בשעת האירועים האסטרונומיים
שגיאה זו משפיעה על השעה ברוב השעונים והזמנים שבתוכנה, למעט: שעון מקומי אמיתי וממוצע, ומשוואת הזמן
חישוב השגיאה התבצע באמצעות בדיקת ההבדל בין שעת חצות היום (מרידיאן-טרנזיט) בממוצע שנתי 
לבין השעה 12:00 שהיא השעה שבה אמור להיות חצות היום בממוצע שנתי
דוגמא: שגיאה של פלוס 10 שניות - צריך להוסיף 10 שניות כדי להגיע לכך שחצות הממוצע יהיה ב- 12:00

שימו לב: יום יוליאני זו שיטה אסטרונומית לספירת זמן רציף בשיטה עשרונית, ואינה קשורה ללוח השנה היוליאני
באופן עקרוני שעה 12 בלילה בדיוק, בקו אורך אפס, מיוצגת ביום היוליאני כמספר שלם נקודה 5
יום יוליאני אינו מתחשב בדלטא-טי ובשעה המקומית, אך פלט הזמנים הרגיל בתוכנה זו כן מתחשב בהם
לפיכך: הזמן הנקוב בשדה "יום יוליאני" הוא לפי השעה בקו אורך אפס, ורק לאחר גריעת ה- דלטא-טי

שימו לב! בממיר התאריכים שבתוכנה זו אין שנה לועזית אפס, כשיטה המקובלת בהיסטוריה 
אך יום יוליאני הוא כשיטה המקובלת באסטרונומיה, שקיימת שנה אפס
לכן בשנות מינוס יש פער של שנה בין היום היוליאני לבין התאריך הלועזי

בתוכנת ממיר תאריכים ובתוכנת חישוב יום הולדת עברי נעזרתי רבות בספריית פייתון שנקראת
pyluach


להלן מעט הסברים, והגדרות אסטרונומיות

יש מספר מערכות של קואורדינטות לתיאור מיקומו של גרם שמיימי
מערכת אוֹפְקִית - מתארת את מיקום הגוף השמיימי ב- גובה מהאופק (קו אורך) וב- אזימוט מהצפון (קו רוחב)
מערכת מַשְׁוָונִית - מתארת את מיקום הגוף השמיימי ב- עלייה ישרה (קו אורך) ו- נְטִיָּיה (דקלינציה, קו רוחב)
מערכת אֶקְלִיפְּטִית - מתארת את מיקום הגוף השמיימי בקו אורך אקליפטי וקו רוחב אקליפטי

המערכת האופקית מתייחסת לאופק הנתון של כל צופה וצופה, ומשתנה לפי מיקום הצופה על פני כדור הארץ
המערכת המשוונית מעתיקה את קווי האורך והרוחב של כדור הארץ אל כדור השמיים
המערכת האקליפטית מתייחסת אל מישור המִילְקֶה. קווי הרוחב מקבילים למישור המילקה
מישור המילקה הוא המישור שבו כדור הארץ מקיף את השמש, ונקרא מילקה כי גוף שעומד עליו יגרום לליקוי 

כמעט כל מערכות המדידות הם במעלות קשת, 360 מעלות למעגל שלם 
לעומת זאת, קו האורך המשווני הנקרא עלייה ישרה, נמדד ביחידות זמן של שעות דקות ושנייות 
נקודת האפס היא הנקודה שבה השמש חוצה את קו המשווה השמיימי ביום השיוויון האביבי 
כמובן שאם 24 שעות הם 360 מעלות - כל שעה היא 15 מעלות. 
כוכב שהעלייה הישרה שלו היא 4 שעות, יחצה את קו המצהר השמיימי 3 שעות מאוחר יותר
מכוכב שהעלייה הישרה שלו היא: שעה 1, והזווית בין הכוכבים הללו היא 45 מעלות
העלייה הישרה של כוכבי השבת היא כמעט קבועה, ואילו של כוכבי הלכת היא משתנה
גם זווית השעה נמדדת ביחידות זמן, והיא מגדירה את תנועת הכוכב מקו המצהר לכיוון מערב
זווית השעה משתנה בכל רגע
דוגמא: כוכב שזווית השעה הנוכחית שלו היא 1 שעה, נמצא עכשיו 15 מעלות מערבה מקו המצהר 
על פי: יגאל פת-אל, אסטרונומיה - מדריך להכרת השמים, קוסמוס, רמת גן התשנ"ז

אורך ראשון (=אֵלוֹנְגַּצְיָה על המילקה) - ההפרש באורך האקליפטי בין השמש לבין הגוף השמיימי המבוקש
אלונגציה אמיתית לוקחת בחשבון גם את קו הרוחב האקליפטי של הגוף, כלומר נטייתו צפונה ודרומה

בכל החישובים: מזרח=90 מעלות, דרום=180, מערב=270, צפון = 360 או 0
גוף שמיימי נמצא בחצי המזרחי של הרקיע=אזימוט שלו גדול מ- 0 וקטן מ- 180 מעלות
גוף שמיימי בחצי המערבי של הרקיע=אזימוט שלו גדול מ-180 מעלות וקטן מ- 360 מעלות
גוף שמיימי בטרנזיט (חצות היום)=אזימוט שלו הוא בדיוק 180 מעלות 
גוף שמיימי באנטי-טרנזיט (חצות הלילה)= אזימוט שלו הוא בדיוק 360 או 0 מעלות

שקיעה גיאומטרית: כאשר השמש בגובה 0 מעלות 
שקיעה מישורית ממוצעת: כאשר השמש בגובה: מינוס 0.833 מעלות

דמדומים אסטרונומיים: השמש בגובה שבין מינוס 12 למינוס 18 מעלות תחת האופק
דמדומים ימיים: השמש בגובה שבין מינוס 6 למינוס 12 מעלות תחת האופק
דמדומים אזרחיים: השמש בגובה שבין 0 למינוס 6 מעלות תחת האופק

להלן גובה השמש המקובל במעלות תחת האופק של שיטות הלכתיות בעניין הדמדומים 
עלות השחר (רמבם) בתקופת ניסן בירושלים לפי הילוך 5 מיל של 24 דקות=מינוס 25.9 מעלות
עלות השחר (א) בתקופת ניסן בירושלים לפי הילוך 4 מיל של 22.5 דקות=מינוס 19.75 מעלות
עלות השחר (ב) בתקופת ניסן בירושלים לפי הילוך 4 מיל של 18 דקות=מינוס 16 מעלות
עלות השחר הנצפה על ידי רבני קנדה=מינוס 14 מעלות
משיכיר את חבירו ברחוק 4 אמות=מינוס 10.5 מעלות
צאת הכוכבים לפי 3/4 מיל של 18 דקות=מינוס 3.65 מעלות
צאת הכוכבים לפי גובה השמש בירושלים בממוצע שנתי של 20 דקות לאחר שקיעה מישורית=מינוס 4 מעלות
צאת הכוכבים לפי 3/4 מיל של 22.5 דקות=מינוס 4.37 מעלות
צאת הכוכבים לפי 3/4 מיל של 24 דקות=מינוס 4.61 מעלות
צאת השבת הרגיל היום בלוחות=מינוס 8.5 מעלות
צאת הכוכבים דרבינו תם במעלות הוא בדיוק כמו גובה השמש בעלות השחר

שיטות הלכתיות בעניין הזמן שמחלקים ל-12 לשם קביעת שעות זמניות
גר"א=מזריחה מישורית לשקיעה מישורית (זו השיטה הרגילה והמקובלת)
גר"א-0=מזריחה גיאומטרית לשקיעה גיאומטרית (שמש בגובה 0 מעלות)
מג"א-16=מעלות השחר לפי מינוס 16 מעלות עד צאת הכוכבים דרבינו תם לפי מינוס 16 מעלות
מג"א16/4=מעלות השחר לפי מינוס 16 מעלות עד צאת הכוכבים לפי מינוס 4 מעלות (שיטה תמוהה מאוד)

הסבר על שעונים
יממה אמיתית=הזמן המדוייק שעובר מחצות היום עד חצות היום שלמחרת. בערך 24 שעות
יממה ממוצעת=יממה של 24 שעות בדיוק
שעון מקומי=שעון המבוסס על חצות היום בקו האורך הגיאוגרפי המדוייק של המקום
שעון אזורי/מתואם=שעון הנמדד לפי חצות היום בקו אורך גיאוגרפי מוסכם. בדרך כלל קו האורך המוסכם הוא קו 
אורך שמתחלק ב-15 ללא שארית, וכל המיקומים שקרובים אליו בתוך 7.5 מעלות מזרחה או מערבה - משתמשים 
באותו זמן, וכך יש 24 איזורי זמן לכדור הארץ כולו (360 מעלות). אמנם יש מדינות שקבעו לעצמן איזור זמן שונה  
שעון מקומי אמיתי=שעון המתבסס על יממה אמיתית: ברגע חצות המקומי בכל יום מכוונים את השעון לשעה 12:00
שעון מקומי ממוצע=מתבסס על יממה ממוצעת קבועה של 24 שעות בדיוק. חצות המקומי לא יהיה בשעה 12:00
משוואת הזמן=ההפרש המצטבר בין שעת חצות אמיתית מקומית לבין השעה 12:00 המקומית
אם משוואת הזמן בפלוס - צריך להוסיף אותה לשעת חצות האמיתי כדי להגיע לשעה 12:00, וכן להיפך
דלטא_טי=ההפרש בין זמן המבוסס על קצב הסיבוב של כדור הארץ - שהוא משתנה, לבין זמן המבוסס על שעון 
אטומי שהוא תמיד בקצב קבוע. 
דלטא_טי מצטבר ליותר משעתיים! לפני 2000 שנה, כך שחצות היום יהיה בשעה 14:00 לפי סולם הזמן יו.טי.סי 
המתעלם מדלטא טי לפני שנת 1972, אך בשעה 12:00 לפי סולם הזמן יו.טי.1 המתחשב בדלטא_טי
שעון גריניץ=השעה באיזור הזמן של קו אורך אפס
שעות מהשקיעה=שעות שעברו מהשקיעה האחרונה (-0.833) עד הרגע הנוכחי. מכונה: שעון ערבי / שעון ארץ ישראל

לוח שנה לועזי יוליאני=לוח שנה המבוסס על ההנחה ששנה שמשית היא בדיוק: 365 יום ורבע. לוח לא מדוייק
לוח שנה לועזי גרגוריאני= לוח שנה שתוקן ע"י האפיפיור גרגוריוס בשנת 1582. כמעט מדוייק לשנה השמשית

תקופת ניסן האמיתית-שיווין האביב=השמש בקו אורך 0 או 360 
תקופת תשרי האמיתית-שיוויון הסתיו=השמש בקו אורך 180
תקופת תמוז האמיתית- יום הארוך=השמש בקו אורך 90 
תקופת טבת האמיתית-יום הקצר=השמש בקו אורך 270
דקלינציית השמש: בימי השיוויון - 0, ביום הארוך - בערך פלוס 23.5, ביום הקצר - בערך מינוס 23.5 

מולד הירח האמיתי: כאשר אורך השמש ואורך הירח שווים 
ניגוד הירח (ירח מלא): ההפרש בין אורך השמש לאורך הירח הוא 180 מעלות
רבע ראשון ואחרון של החודש=ההפרש בין אורך השמש לאורך הירח הוא 90 מעלות
ירח לפני הניגוד=אורך הירח *גדול* מאורך השמש 
ירח לאחר הניגוד=אורך הירח *קטן* מאורך השמש

ליקוי חמה מלא מתרחש כאשר גם האורך וגם הרוחב של השמש והירח שווים או כאשר האלונגציה של הירח היא: 0 
ליקוי לבנה מתרחש כאשר הרוחב של השמש והירח שוים, וההפרש בין אורך השמש לאורך הירח הוא 180 מעלות
או כאשר האלונגציה של הירח היא בדיוק 180'''




####################################################################################################################
                                    # יבוא החבילות הנדרשות          
####################################################################################################################

# מידע על מערכת ההפעלה שבשימוש
import platform

# משתנה מאוד חשוב שקובע האם מערכת ההפעלה הנוכחית היא ווינדוס כי אם היא לא אז אי אפשר לעשות חלק מהפעולות
is_windows = platform.system() == "Windows"

# לצורך ניקוי הזיכרון למניעת עומס
import gc

# לצורך רזולוציית המסך
import ctypes
import screeninfo

# תקשורת עם מערכת ההפעלה והתיקיות שלה
import os
import sys

# העתקת תיקיות במחשב ממקום למקום
import shutil

# למיקומי קבצים ותיקייות
from pathlib import Path

# כאשר התוכנה פועלת כתוכנה סגורה יש לייבא לצורך מסך טעינת התוכנה
if getattr(sys, "frozen", False):
    import pyi_splash
    
# לצורך לחיצה מדומה על המקלדת כדי שהמסך לא ייכבה אוטומטית
from pynput.keyboard import Controller as keyboard_Controller 
from pynput.keyboard import Key as keyboard_Key
        
# חבילות סקייפילד
import skyfield
from skyfield.api import N, S, E, W, wgs84, load, load_file, Angle, Star, EarthSatellite
from skyfield.framelib import ecliptic_frame
from skyfield import almanac, eclipselib
from skyfield.searchlib import find_maxima, find_minima, find_discrete

# חישובים
import numpy as np
from numpy import arccos
import math

# תאריכים ואיזורי זמן
import time as pytime # לעבודה עם זמנים בשניות מאז Epoch. בכוונה נתתי שם pytime כי יש בקוד שלי כמה משתנים בשם time
import datetime as dt
from datetime import datetime, timedelta, date
from pytz import timezone
import pytz
# בעתיד אולי נשתמש לאיזורי זמן ב 
#from zoneinfo import ZoneInfo

import calendar

# ייבוא חבילת גמטריה לצורך מידע על שנה עברית
import gematriapy as gy

# יבוא חבילת לוח עברי בפייתון
from pyluach import dates, hebrewcal, parshios, gematria, utils

# ספרייה לחישובי לוח שנה לועזי גם יוליאני וגם גרגוריאני, וגם יום-יוליאני
import jdcal

# ספרייה לקריאת קובץ סי אס וי של מיקומים
import csv

import locale # מידע על שפת הווינדוס וקידוד השפות # אמור לעבוד גם בלינוקס. לבדוק
    
# יבוא ספריות שקיימות רק בווינדוס
if is_windows:
    from win32com.client import Dispatch # עבודה מול מערכת הפעלה ווינדוס כגון יצירת קיצורי דרך

# פתיחת דפדפן אינטרנט
import webbrowser

# הודעות של טקינטר
from tkinter import messagebox as tkMessageBox

# טקינטר
import tkinter as Tkinter
import tkinter
from tkinter import ttk, PanedWindow
from tkinter import *
import tkinter.font as tkfont
import tkinter.font
from tkinter.filedialog import asksaveasfilename

# העתקה לקליפ-בוארד
import clipboard

# פתיחת קישור אינטרנט קריאת דפי אינטרנט או הורדת קבצים
from urllib.request import urlopen
from urllib.request import urlretrieve
# תקשורת עם אתרי אינטרנט חלופי ל 
#import requests

# מציאת איזור זמן לפי קווי אורח ורוחב
from tzfpy import get_tz # הרבה יותר מהיר מ timezonefinder שפעם השתמשתי

# אישורים של תעודות אבטחה לצורך נטפרי ועוד
import certifi

# היכן תהיה תיקיית הקבצים הדרושים עבור התוכנה
from platformdirs import user_data_dir

# פתיחת קבצי פייתון או תוכנות מתוך התוכנה הנוכחית
# משמש גם לפתיחת תיקיית קבצי התוכנה בווינדוס ובלינוקד במקום startfile שעבד רק בווינדוס
import subprocess

# עשיית פעולות במקביל בלי לתקוע את כל התוכנה. משמש בעיקר בהורת קבצים
import threading

# לשמירת מילון הגדרות
import json

# לרוורס עברית בלינוקס
import re

# בדיקת תהליכים פעילים וסגירתם
#import psutil

# תו יוניקוד להציד משמאל לימין. עדיף פותח וסוגר
LTR = "\u200E"
# תו יוניקוד להציד מימן לשמאל. עדיף פותח וסוגר
RTL = "\u200F"

# מחזיר טרו אם מערכת ההפעלה של המשתמש היא בעברית
is_system_hebrew = (locale.getlocale()[0] or '').lower().startswith('he')

# פונקצייה מאוד חשובה להצגת עברית בלינוקס. היא הופכת את הטקסט בעברית כדי שיוצג נכון
def reverse(text, for_title = False):
    BRACKETS_MAP = str.maketrans({
        '(': ')', ')': '(', 
        '[': ']', ']': '[', 
        '{': '}', '}': '{', 
        '<': '>', '>': '<'
    })

    if is_windows or (for_title and is_system_hebrew):
        return text

    if isinstance(text, (list, tuple)):
        return [reverse(item) for item in text]

    if not isinstance(text, str):
        return text

    # מספרים שלמים/עשרוניים, מילים באנגלית עם נקודות או קווים
    pattern = re.compile(r'\d+(\.\d+)?|[A-Za-z0-9]+(?:[.\-][A-Za-z0-9]+)*')
    lines = text.splitlines(keepends=True)
    result_lines = []

    for line in lines:
        has_newline = line.endswith("\n")
        line_content = line.rstrip("\n")
        segments = []
        idx = 0

        while idx < len(line_content):
            match = pattern.match(line_content, idx)
            if match:
                segments.append(match.group())
                idx = match.end()
            else:
                char = line_content[idx]
                if char == " ":
                    segments.append(char)
                else:
                    segments.append(char.translate(BRACKETS_MAP))
                idx += 1

        # הפוך רק רצפים של עברית/סימנים
        new_segments = []
        buffer = ""
        for seg in segments:
            if re.fullmatch(r'[A-Za-z0-9.\- ]+', seg):
                if buffer:
                    new_segments.append(buffer[::-1])
                    buffer = ""
                new_segments.append(seg)
            else:
                buffer += seg
        if buffer:
            new_segments.append(buffer[::-1])

        # הפוך את סדר הרצפים של rtl בלבד
        new_line = "".join(reversed(new_segments))
        if has_newline:
            new_line += "\n"
        result_lines.append(new_line)

    return "".join(result_lines)




       
####################################################################################################################
                                     # הגדרת משתנים כללים עבור התוכנה
####################################################################################################################

# הגדרת צבע רקע עבור רוב הדברים בתוכנה
cu_color = '#%02x%02x%02x' % (255, 246, 240) #lighter_cream_hex % light_cream_rgb

# הגדרת צבע רקע עבור תיבות אנטרי שמכילות מידע
e_color = "gray94"

# הגדרת משתנה כללי של הקידוד הנכון עבור פתיחת ושמירת קבצים
# עקב בעיות קידוד במחשבים באנגלית וכו הגדרתי כעת שתמיד הקידוד יהיה 1255
cu_encod = "cp1255"

# הגדרת משתנה כללי של קידוד ברירת המחדל במחשב המשתמש
default_encoding = locale.getpreferredencoding() if is_windows else cu_encod

# הגדרת משתנה כללי חשוב מאוד שקובע האם ווינדוס הוא בעברית
#is_heb_locale = False #locale.getlocale()[0] == 'Hebrew_Israel'

# הגדרת משתנה חשוב מאוד שקובע האם המשתמש פועל מתוך מערכת הפעלה לינוקס ושהיא בעברית כי במקרה כזה צריך להציג טקסטים בכיוון הפוך
is_linux_heb = False # if platform.system() != "Windows": # בדיקה אם המערכת הפעולה היא לא ווינדוס

#---------------------------------------
# הגדרת משתנה כללי לשמות החודשים בעברית המשמשים בתוכנה זו
CUֹ_HEB_MONTH_NAMES = ['ניסן','אייר','סיוון','תמוז','אב','אלול','תשרי','מְרַחשְׁוָון','כִּסְלֵיו','טבת','שבט','אדר','אדר-א','אדר-ב']

# חשוב מאוד כדי שלא יהיו שגיאות בפיילוח - הגדרת שמות החודשים של פיילוח (הנמצאים בספריית אוטיליס של פיילוח) לשמות המשמשים בתוכנה זו
utils.MONTH_NAMES_HEBREW = CUֹ_HEB_MONTH_NAMES

# הגדרת משתנה כללי חשוב מאוד שמחזיק את המילון של חצות שנתי ומספר השניות המתאים לתיקון סולם הזמן. המשתנה מתאפס בכל הפעלה מחדש של התוכנה
# המילון חשוב מאוד ומטרתו למנוע חישובים מיותרים חוזרים ונשנים עבור אותה שנה והוא מוגדר בפונקציית טיים_לוקיישן_טיימזון
# נתתי כאן סתם ערכים כדי לא לקבל שגיאה שאין ערכים
mean_transit_and_error_timescale_dict = {"year":"AA","location":"BA","year_mean_transit":"CA","seconds_error_timescale":"DA","year_timescale":"EA"}


##########################################
# משתנים חשובים מאוד
# האם סולם הזמן שבשימוש הוא יו.טי.1 או יו.טי.סי
is_ut1 = True # בהמשך יכול להשתנות לפי השנים בפונקציית טיים_לוקיישן_טיימזון

# טעינת סולם הזמן של סקייפילד
ts = load.timescale()
##########################################

# לצורך פונקציית set_menubuttons_times מוגדר כאן משתנה חשוב מאוד שמשמש כמתג האם פונקציית כל החישובים פועלת ברציפות או שפועלת שלא ברציפות
is_all_calculations_running = False    

# הגדרת משתנה שיחזיק את המידע האם נעשה שימוש בקובץ המיקומים המקורי או בקובץ הערוך
# כברירת מחדל הוא מוגדר על ערוך
which_locations_file = "ערוך"

# הגדרת משתנה כללי שמחזיק את המידע האם יש תהליך מישני פתוח. בהתחלה הוא מוגדר אפס
subprocess_patuach = 0

# רזולוציית המסך שבו נבנתה התוכנה
cu_screenwidth = 1366
cu_screenheight = 768

# קנה המידה הרגיל של התצוגה שבו נבנתה התוכנה
cu_scaling = 1.32 # כנראה המקורי היה 1.3 אבל למעשה בחרתי 1.32 כי המקורי עשה בעיות וזה כנראה פועל היטב במחשבים גדולים

# תאריך גרסת התוכנה הראשית
cu_version_date = dt.date(2026,2,10)

# פונקצייה שמחזירה שם יחד עם מיקום של קובץ בתיקיית תוכנת כוכבים וזמנים
'''
def get_cu_join_path(file_name_str):
    global cu_dir_path
    return os.path.join(cu_dir_path, file_name_str)
'''
####################################################################################################################
            # פונקציות פשוטות שיש מה להשתמש בהן גם בקודים אחרים ואינן שייכות דווקא לממשק הגראפי או לסקייפילד
####################################################################################################################


# פונקצייה להמרת זמן מ-שניות ל- סטרינג שעות דקות ושניות, או רק ל- סטרינג דקות ושניות שבניתי בסיוע רובי הבוט
def convert_seconds(seconds, to_hours=False):
    if seconds is None: return "--:--"
    # חישוב מספר הדקות והשניות שיש בשעה אחת, והדפסתם בפורמט של דקות ושניות
    if to_hours:
        return f'{seconds // 3600 :02.0f}:{(seconds % 3600) // 60 :02.0f}:{seconds % 60 :02.0f}'
    else:
        return f'{seconds // 60 :02.0f}:{seconds % 60 :02.0f}'
    
# פונקצייה שמחזירה סטרינג של זמן מתוך דיטטיים אבל גם מחזירה סטרינג ריק אם מקבל None או False
def format_dt(dt, date=False):
    if not dt:
        return "--:--"
    fmt = f"%H:%M:%S  --  %d/%m/{dt.year}" if date else "%H:%M:%S"
    return dt.strftime(fmt)


def seconds_to_time_str(seconds):
    if seconds is None: return "--:--"
    seconds = seconds % 86400
    h = int(seconds // 3600)
    m = int((seconds % 3600) // 60)
    s = int(seconds % 60)
    return f"{h:02d}:{m:02d}:{s:02d}"


# פונקצייה להמרה מ- טאפל של מעלות דקות ושניות, למעלות עשרוני
# פונקצייה זו נבנתה ע"י מערכת בינה מלאכותית של רובי הבוט
def dms_to_dd(degrees, minutes, seconds):
    sign = -1 if degrees < 0 else 1
    decimal_degrees = sign * (abs(degrees) + (minutes/60) + (seconds/3600))
    return decimal_degrees

# פונקצייה להמרה ממעלות עשרוני ל-טאפל של מעלות דקות ושניות
# פונקצייה זו נבנתה ע"י רובי הבוט בינה מלאכותית
def dd_to_dms(decimal_degrees):
    degrees = int(decimal_degrees)
    decimal_minutes = abs(decimal_degrees - degrees) * 60
    minutes = int(decimal_minutes)
    seconds = (decimal_minutes - minutes) * 60
    
    if decimal_degrees < 0:
        degrees = -degrees
    
    return (degrees, minutes, seconds)


# פונקצייה שבודקת האם שנה גרגוריאנית היא מעוברת או לא    
def is_leap_year(year):
    return (year % 4 == 0 and year % 100 != 0) or year % 400 == 0

############################################################################################

#-------------------------------------------------------------------------
# פונקציות עבור התוכנות הנספחות לכוכבים וזמנים אשר ניתנות לשימוש גם בתוכניות אחרות

# פונקצייה להמרה ממספר השנה העברית לשנה לועזית מקבילה 
# אם השנה הלועזית היא במינוס צריך להוסיף עוד שנה כי אין שנה לועזית אפס. אלא שנה עברית 3761 היא שנה 1 לועזית ושנה עברית 3760 היא שנה מינוס אחד
# כברירת מחדל אין שנה לועזית 0 
# באמת אצל ההיסטוריונים אכן אין שנת 0 אבל אצל האסטרונומים יש שנת 0
def int_heb_year_to_loazit_year(int_heb_year, loazit_year_zero=-1):
    if loazit_year_zero == -1:
        return int_heb_year - 3760 if int_heb_year >= 3761 else int_heb_year - 3761
    elif loazit_year_zero == 0:
        return int_heb_year - 3760
    
# פונקציית להדפסת שנה לועזית המקבילה לשנה עברית הכוללת טיפול בשתי שיטות הספירה (עם שנת אפס או בלי שנת אפס) עבור שנים שלפני הספירה הנוצרית
def string_heb_year_to_loazit_year_plus_zero(int_heb_year):
    return f'[שנה לועזית: {int_heb_year_to_loazit_year(int_heb_year)}; (או: {int_heb_year_to_loazit_year(int_heb_year, loazit_year_zero=0)} לשיטה המקובלת באסטרונומיה שקיימת שנה אפס)]' if int_heb_year_to_loazit_year(int_heb_year) <=0 else f'[שנה לועזית: {int_heb_year_to_loazit_year(int_heb_year)}]'

# פונקצייה להמרת שמות חודשים עבריים למספרים ברירת המחדל היא מניסן לאדר וכך מספרי החודשים הם כפי שמקובל בספריית פיי-לוח
def heb_month_name_to_number(heb_month_name, start = "nissan"):
    months_numbers = [1,2,3,4,5,6,7,8,9,10,11,12,12,13] if start == "nissan" else [7,8,9,10,11,12,1,2,3,4,5,6,13,6]
    months_names = ['ניסן','אייר','סיוון','תמוז','אב','אלול','תשרי','מְרַחשְׁוָון','כִּסְלֵיו','טבת','שבט','אדר','אדר-א','אדר-ב']
    for name in range(len(months_names)):
        if months_names[name] == heb_month_name:
            return months_numbers[name]

# הגדרת פונקציית מציאת מספר השנה במחזור 28 שנות חמה לתקופת שמואל "מחזור גדול", עם תנאי ש 0 שווה 28 וכן מספר המחזור שאוחזים בו        
def chishuv_shana_bemachzor_28(heb_year):
    machzor_28 = int(heb_year / 28) + 1 
    shana_bemachzor_28 = heb_year % 28
    if shana_bemachzor_28 == 0:
        shana_bemachzor_28 = 28  
        machzor_28 -= 1
    return machzor_28, shana_bemachzor_28

# הגדרת פונקציית מציאת מספר השנה במחזור 19 השנים הפשוטות והמעוברות "מחזור קטן", עם תנאי ש 0 שווה 19 וכן מספר המחזור שאוחזים בו
# הפונקצייה גם מחזירה האם השנה מעוברת או לא
def chishuv_shana_bemachzor_19(heb_year):
    machzor_19 = int(heb_year / 19) + 1 
    shana_bemachzor_19 = heb_year % 19
    if shana_bemachzor_19 == 0:
        shana_bemachzor_19 = 19  
        machzor_19 -= 1
    # בדיקה שמחזירה "נכון" אם השנה העברית מעוברת, ו"לא נכון" אם השנה העברית לא מעוברת אלא פשוטה 
    meuberet_year = True if shana_bemachzor_19 in [3,6,8,11,14,17,19] else False    
    return machzor_19, shana_bemachzor_19, meuberet_year

# פונקצייה שמחזירה "נכון" אם השנה העברית מעוברת, ו"לא נכון" אם השנה העברית לא מעוברת אלא פשוטה 
def shana_meuberet(heb_year_bemachzor_19):
    return heb_year in [3,6,8,11,14,17,19]

# הגדרת פונקציית המרה  מ- רשימה הכוללת יום שעה וחלק, אל- חלקים, שלא בתוך רשימה
# פונקציה זו אינה שימושית כרגע בתוכנית זו
def convert_to_chalakim(arr_yom_shaa_chelek): 
    yom = arr_yom_shaa_chelek[0]
    shaa = arr_yom_shaa_chelek[1]
    chelek = arr_yom_shaa_chelek[2]
    chalakim = yom * (24 * 1080) + (shaa * 1080) + chelek
    return chalakim

# הגדרת פונקציית המרה מ-חלקים אל- יום שעה וחלק
# חייבים להוסיף 0.0000000001 כדי למנוע שגיאת עיגול עשרונית שעושה חלק אחד פחות
def convert_from_chalakim(chalakim): 
    yom = int(chalakim / (24 * 1080))
    shaa = int((chalakim / (24 * 1080) - yom) * 24 + 0.0000000001)
    chelek = int((((chalakim / (24 * 1080) - yom) * 24 + 0.0000000001) - shaa) * 1080)
    # תיקון יום 0 שווה ל 7
    if yom == 0:
        yom = yom + 7
    return [yom, shaa, chelek]


# פונקצייה לחישוב שם היום בעברית עבור מספר יום בשבוע, מיום ראשון עד שבת: לדוגמא יום 1 הוא יום ראשון
def heb_string_day(day):
    
    heb_string_days = {
        1: 'ראשון',
        2: 'שני',
        3: 'שלישי',
        4: 'רביעי',
        5: 'חמישי',
        6: 'שישי',
        7: 'שבת'
    }
    
    return heb_string_days.get(day)

# פונקצייה לחישוב שם היום באנגלית עבור מספר יום בשבוע, מיום ראשון עד שבת: לדוגמא יום 1 הוא יום ראשון
def en_string_day(day):
    
    en_string_days = {
        1: 'Sunday',
        2: 'Monday',
        3: 'Tuesday',
        4: 'Wednesday',
        5: 'Thursday',
        6: 'Friday',
        7: 'Saturday'
    }
    
    return en_string_days.get(day)


# פונקצייה לחישוב אות היום בעברית עבור מספר יום בשבוע, מיום ראשון עד שבת: לדוגמא יום 1 הוא יום א
def heb_letter_day(day):
    
    heb_letters_days = {
        1: 'א',
        2: 'ב',
        3: 'ג',
        4: 'ד',
        5: 'ה',
        6: 'ו',
        7: 'ז'
    }
    
    return heb_letters_days.get(day)


# פונקצייה לקבל שם של כל אחד מהכיוונים שיש בעולם לפי מספר האזימוט כשבר עשרוני
# חובר בעזרת צ'אט גיפיטי
def get_side_name(azimuth):

    directions = {
        0.0: "צפון",
        45.0: "צפון-מזרח",
        90.0: "מזרח",
        135.0: "דרום-מזרח",
        180.0: "דרום",
        225.0: "דרום-מערב",
        270.0: "מערב",
        315.0: "צפון-מערב"
    }
    # זה מה שיהיה כתוב אם הוכנס ערך שגוי
    side_name = "לא ניתן לקבוע כיוון"

    # בדיקה של ערך מדויק
    if azimuth in directions:
        side_name = directions[azimuth]
    else:
        # בדיקה של ערך קרוב לגבול של ערך קיים בטווח של 22.5 מעלות מכל ערך קיים
        for key in directions:
            if key - 22.5 <= azimuth <= key + 22.5:
                side_name = directions[key]
                break

    return side_name



# פונקצייה שמחזירה מידע בכמה תקופת ניסן לפי שמואל מקדימה את מולד ניסן בלוח העברי הקבוע
# פונקצייה זו מבוססת על נוסחאות שבספר שערים ללוח העברי מאת רחמים שר שלום, עמוד 148
def kama_tkufat_nissan_shmuel_lifnei_mold_nisan(heb_year):
    
    # חישוב מה מספר המחזור שאוחזים בו ומה מספר השנה בתוך המחזור במחזור 19 השנים באמצעות פונקצייה
    machzor_19, shana_bemachzor_19, _ = chishuv_shana_bemachzor_19(heb_year)
    machzorim_shlemim_sheavru = machzor_19 - 1

    # א-תפה: עודף תקופת שמואל על תקופת רב אדא ב-19 שנות המחזור
    atapa_bechalakim = 1565
    # ז-ט-תרמב בחלקים: שיעור הקדימה של תקופת ניסן למולד ניסן בשנה א של המחזור
    zatarmab_bechalakim = 191802

    # הגדרת משתנים עבור המילון
    # (ירח) הפיכה לחלקים של 10 ימים + 21 שעות + 204 חלקים. זהו העודף שיש בשנת חמה של שמואל על 12 חודשים של הלוח העברי
    a = 282084
    # הפיכה לחלקים של 18 ימים + 15 שעות + 589 חלקים. זהו העודף שיש ב 13 חודשי לוח עברי (ירח) על שנת שמש של שמואל
    b = 483349
   
    # מילון לחישוב כמה חלקים יש להוסיף או להפחית עבור שנים שהם לא השנה הראשונה במחזור
    milon_shmuel = {
        1:0,
        2:a,
        3:a-b,
        4:(2*a)-b,
        5:(3*a)-b,
        6:(3*a)-(2*b),
        7:(4*a)-(2*b),
        8:(4*a)-(3*b),
        9:(5*a)-(3*b),
        10:(6*a)-(3*b),
        11:(6*a)-(4*b),
        12:(7*a)-(4*b),
        13:(8*a)-(4*b),
        14:(8*a)-(5*b),
        15:(9*a)-(5*b),
        16:(10*a)-(5*b),
        17:(10*a)-(6*b),
        18:(11*a)-(6*b),
        19:(11*a)-(7*b),
    }
    
    # תשובה בכמה חלקים מקדימה תקופת ניסן את מולד ניסן בשנה המבוקשת
    tshuva_bechalakim = machzorim_shlemim_sheavru * atapa_bechalakim - zatarmab_bechalakim + milon_shmuel.get(shana_bemachzor_19)
    # תשובה בחלוקה ליום שעה וחלק
    tshuva = convert_from_chalakim(abs(tshuva_bechalakim))
    return tshuva

# פונקצייה להחזרת מספר השנים שחלפו מאז חורבן בית שני
def get_shana_lechurban_bait_sheni(heb_year_int):
    shnat_hachurban = 3830
    if heb_year_int < shnat_hachurban:
        return f"שנת {abs(heb_year_int - shnat_hachurban + 2)} !לפני! חורבן בית המקדש השני שאירע בשנת ג'תתל (שנת 70 לספירת הנוצרים)"
    return f"שנת {heb_year_int - shnat_hachurban + 1} לחורבן בית המקדש השני שאירע בשנת ג'תתל (שנת 70 לספירת הנוצרים)"

# פונקצייה שמקבלת מספר שנה עברית ומחזירה איזו שנה לשמיטה והאם זו שנת מעשר עני
def get_shana_lashmita_and_maasrot(heb_year_int):
    A = heb_year_int % 7
    shana_lashmita = 7 if A == 0 else A
    shnat_maasrot = "מעשר שני" if shana_lashmita in [1,2,4,5] else "מעשר עני" if shana_lashmita in [3,6] else "שמיטה-הפקר: אין תרומות ומעשרות"
    return shana_lashmita, shnat_maasrot

# הגדרת פונקציית מציאת מספר השנה במחזור 28 שנות חמה לתקופת שמואל המכונה "מחזור גדול", עם תנאי ש 0 שווה 28 וכן מספר המחזור שאוחזים בו
# הפונקצייה גם מחזירה האם השנה מעוברת או לא
def chishuv_shana_bemachzor_28(heb_year):
    machzor_28 = int(heb_year / 28) + 1 
    shana_bemachzor_28 = heb_year % 28
    if shana_bemachzor_28 == 0:
        shana_bemachzor_28 = 28  
        machzor_28 -= 1   
    return shana_bemachzor_28, machzor_28

    


####################################################################################################################
                              # פונקציות סקייפילד או קשורות מאוד לסקייפילד או הגיעו מדוגמאות באתר סקייפילד
####################################################################################################################

# פונקציה מאוד חשובה שמקבלת זמן בפורמט סקייפילד ומוציאה זמן בפורמט המבוקש מבין אופציות פלט הזמן שסקייפילד יכולה להוציא
# ברירת המחדל היא שהפלט יהיה יוטי1 אסטימזון על איזור הזמן המבוקש
def skyfield_to_cu_time(skyfield_time, requested_timezone):
    
    global is_ut1
     
    a = skyfield_time.ut1_calendar()
    
    return datetime(a[0], a[1], a[2], a[3], a[4], int(a[5]), int((a[5] % 1) * 1e6), tzinfo=pytz.utc).astimezone(requested_timezone) if is_ut1 else skyfield_time.astimezone(requested_timezone)

# פונקציה מאוד חשובה שמקבלת זמן בפורמט רגיל הכולל בתוכו את איזור הזמן שלו, ומוציאה זמן בפורמט סקייפילד
def cu_to_skyfield_time(cu_time):
    
    global is_ut1
    
    # המרת הזמן בחזרה מאיזור הזמן המקומי לאיזור הזמן של גריניץ כי כל חישובי סקייפילד הם במקור רק על אזור זמן גריניץ
    # אולי צריך להוסיף קודם בדיקה האם קיים איזור זמן כלומר שזה לא none###########
    cu_time = cu_time.astimezone(timezone('utc'))
    
    return ts.ut1(cu_time.year, cu_time.month, cu_time.day, cu_time.hour, cu_time.minute, cu_time.second+cu_time.microsecond/1e6) if is_ut1 else ts.from_datetime(cu_time)


# פונקצייה לחישוב השפעת גובה במטרים על זריחה ושקיעה הנראים בגובה
def calculate_elevation_rise_set(altitude_m):
    
    # אם המקום נמוך מגובה פני הים אין אפשרות לחשב את השפעת הגובה אלא זה יהיה כאילו המקום במישור ומחשב לפי שקיעה מישורית
    # אני לא יודע האם זה הדבר הנכון ביותר אבל כרגע זה מה שיש כי אחרת יש שגיאות בחישוב שלהלן
    if altitude_m < 0:
        elevation_rise_set = -0.833
    else:
        # חישוב גובה המיקום אחרי הורדה של 20 אחוז מהגובה. לא יודע למה צריך להוריד 20 אחוז אבל כך התוצאה מתאימה ללוחות חי ולמציאות שראיתי בעין
        altitude_m_20 = altitude_m - (altitude_m * (20/100))
        # רדיוס כדור הארץ במטרים, בקו המשווה
        earth_radius_m = 6378136.6
        side_over_hypotenuse = earth_radius_m / (earth_radius_m + altitude_m_20)
        h = Angle(radians = -arccos(side_over_hypotenuse))
        # עד כאן התוצאה הייתה עבור שקיעה גיאומטרית. אבל השקיעה של סוף עיגול השמש בגובה הנל וגם כולל רפרקציה היא כך
        elevation_rise_set = h.degrees - 0.833 # בכוונה הגדרתי את גובה האופק של שקיעה מישורית נראית - בלי מינוס, בגלל ש-אייץ כבר במינוס
    return elevation_rise_set


# פונקצייה לחישוב נתונים אסטרונומיים רבים על גרמי השמיים, במיקום תאריך ושעה מסויימים
def astro_calculations(body,time,location,location_timezone,body_type = "PLANET"):
    
    if body_type == "PLANET":
        # הגוף כפי שנראה/נמדד ממיקום הצופה
        body_topocentric = (eph['earth'] + location).at(time).observe(eph[body]).apparent()
        # הגוף כפי שנראה/נמדד ממרכז כדור הארץ
        body_geocentric = eph['earth'].at(time).observe(eph[body]).apparent()
    
    else:
        # הגוף כפי שנראה/נמדד ממיקום הצופה
        body_topocentric = (eph['earth'] + location).at(time).observe(body).apparent()
        # הגוף כפי שנראה/נמדד ממרכז כדור הארץ
        body_geocentric = eph['earth'].at(time).observe(body).apparent()

    # אזימוט וגובה טופוצנטרי
    alt, az, _ = body_topocentric.altaz()

    # עלייה ישרה ונטייה: "נכונים לכאורה" לפי מיקום טופוצנטרי מיועד לצורך תצפית בטלסקופ וכן גם מופיע בסול אט אומברה
    # הערה: אם רוצים לקבל עלייה וירידה ימין אסטרומטרית, צריך להגדיר אותו דבר רק למחוק את ה, 'date'
    ra, dec, _ = body_topocentric.radec('date') #? or: body_geocentric
    
    # חישוב זווית השעה טופוצנטרי
    ha, _, _ = body_topocentric.hadec()
    
    # חישוב האם הדקלינציה צפונית או דרומית
    dec_N_S = f"{reverse('צפון') if is_heb_locale else 'North'}" if dec.degrees>0 else f"{reverse('דרום') if is_heb_locale else 'South'}"        
    
    # אורך ורוחב אקליפטי וגם מרחק מכדור הארץ בדווקא לפי מיקום גיאוצנטרי  
    lat_lon_dist = body_geocentric.frame_latlon(ecliptic_frame) #? or: body_topocentric
    lat = lat_lon_dist[0]
    lon = lat_lon_dist[1]
    dist = lat_lon_dist[2]
    
    # חישוב האם הרוחב האקליפטי צפוני או דרומי
    lat_N_S = f"{reverse('צפון') if is_heb_locale else 'North'}" if lat_lon_dist[0].degrees>0 else f"{reverse('דרום') if is_heb_locale else 'South'}"
         
    # אחוזי תאורה טופוצנטרי
    percent = 100.0 * body_topocentric.fraction_illuminated(eph['sun'])    
    
    # קוטר משווני של כל אחד מכוכבי הלכת
    # אם הגוף לא מופיע פה ברשימה אז המילון מחזיר: אפס
    # https://nssdc.gsfc.nasa.gov/planetary/factsheet/planet_table_ratio.html
    # חלק זה הוחלף למילון במקום להשתמש ב- איף ו-אליף בעזרת רובי בוט בינה מלאכותית 
    equatorial_radius_km = {
        'sun': 696342.0,
        'moon': 1738.1,
        'venus': 6051.8,
        'jupiter barycenter': 71492.0,
        'mars barycenter': 3396.2,
        'saturn barycenter': 60268.0,
        'mercury': 2440.5,
        'uranus barycenter': 25559.0,
        'neptune barycenter': 24764.0,
        'pluto barycenter': 1188.0
    }.get(body, 0.0)
    
    
    #  חישוב קוטר זוויתי נראה: בהתבסס על הרדיוס המשווני והמרחק מכדור הארץ
    apparent_diameter = Angle(radians=np.arcsin(equatorial_radius_km / dist.km) * 2.0)
    
    # אם רוצים שעלייה ישרה וזווית השעה יהיו בפורמט של שעות:דקות:שניות
    #ra = f'{ra.hms()[0] :02.0f}:{ra.hms()[1] :02.0f}:{ra.hms()[2] :02.2f}'
    #ha = f'{ha.hms()[0] :02.0f}:{ha.hms()[1] :02.0f}:{ha.hms()[2] :02.2f}'
    
    #------------------------
    # מכאן והלאה עד הסוף כל הדברים לא רלוונטיים עבור השמש, אלא רק לכוכבי הלכת האחרים
    
    if body == 'sun':
        return alt.degrees, az.degrees, ra, dec.degrees, ha, dec_N_S, lat.degrees, lon.degrees, dist.km, lat_N_S, percent, apparent_diameter.arcminutes(), 0, 0, 0, 0, 0, 0, 0
    
    
    # חישוב העובי הנראה בדקות קשת לפי שקלול אחוזי התאורה הנראים אבל יש לזכור לבדוק האם אחוזי התאורה מחושבים ממרכז כדור הארץ או יותר טוב שהם ממיקום הצופה
    thickness = apparent_diameter.arcminutes() * (percent / 100)
    
    # השמש כפי שנראה/נמדד ממיקום הצופה
    sun_topocentric = (eph['earth'] + location).at(time).observe(eph['sun']).apparent()
    # השמש כפי שנראה/נמדד ממרכז כדור הארץ
    sun_geocentric = eph['earth'].at(time).observe(eph["sun"]).apparent()
    
    # אזימוט וגובה של השמש - טופוצנטרי
    salt, saz, _ = sun_topocentric.altaz()
    
    # אלונגציה אמיתית שלוקחת בחשבון גם את רוחב הירח: טופוצנטרית
    elongation = sun_topocentric.separation_from(body_topocentric).degrees
    
    # חישוב קו-אורך השמש גיאוצנטרי 
    _, slon, _ = sun_geocentric.frame_latlon(ecliptic_frame)
    
    # אלונגציה על המלקה: שזה נקרא אצל הרמבם אורך ראשון: גיאוצנטרי. זה תמיד פחות מ 180 מעלות
    ecliptic_elongation = min(abs(slon.degrees - lon.degrees), 360 - abs(slon.degrees - lon.degrees))
    # בדיקה האם האלונגציה מזרחית או מערבית. נתון זה תקף גם לגבי אלונקציית מלקה 
    is_east = (lon.degrees - slon.degrees) % 360.0 < 180.0
    elongation_E_W = f"{reverse('מזרח') if is_heb_locale else 'East'}" if is_east else f"{reverse('מערב') if is_heb_locale else 'West'}"
    
    alt=alt.degrees
    az=az.degrees
    dec=dec.degrees
    lat=lat.degrees
    lon=lon.degrees
    if body_type == "PLANET":
        dist=dist.km
    else:
        dist=dist.au
    apparent_diameter = apparent_diameter.arcminutes()
    slon = slon.degrees
    salt = salt.degrees
    saz = saz.degrees
    
    
    return alt,az,ra,dec,ha,dec_N_S,lat,lon,dist,lat_N_S,percent,apparent_diameter,thickness,slon,elongation,ecliptic_elongation,elongation_E_W,salt,saz
    

# פונקצייה לחישוב זמן מקומי (לפי חצות שנתי ממוצע שהוא בשעה 12), לפי קו האורך הגיאוגרפי האמיתי
def localmeantime(utc_time,longitude):
    # מכאן והלאה החישוב עצמו: הבדל הזמן מגריניץ שהיא קו אורך 0 הוא: ארבע דקות לכל מעלת אורך
    lmt = utc_time + timedelta(seconds=round(4*60*longitude))
    # הזמן כרגע הוא זמן מקומי ולכן צריך להשמיט את איזור הזמן המקורי ולהפוך את זה לזמן סתמי ללא מידע על איזור זמן
    lmt = lmt.replace(tzinfo=None)
    return lmt
    

# חישוב התקבצות וניגוד עבור כל גוף, כברירת מחדל על הירח לקבל מולד ירח אמיתי הבא וניגוד ירח אמיתי הבא
# כברירת מחדל עבור הירח, החיפוש מתבצע מהזמן הנתון ועד חמישים יום לאחר מכן שזה קצת פחות מחודשיים
def hitkabzut_nigud_calculations(time,location,location_timezone,body="moon",PLUS_MINUS="PLUS",plus_minus_days=50):
    
    # הגדרת תחילת וסוף התאריכים לחישוב זריחות ושקיעות
    # לחישוב התקבצות וניגוד קודמים משתמשים במינוס
    if PLUS_MINUS == "MINUS":
        time_plus_minus_days = time - dt.timedelta(days=plus_minus_days)
        t0 = cu_to_skyfield_time(time_plus_minus_days) 
        t1 = cu_to_skyfield_time(time)
    
    # בכל שאר המקרים מחשבים בפלוס את ההתקבצות והניגוד העתידיים
    else:
        time_plus_minus_days = time + dt.timedelta(days=plus_minus_days)
        t0 = cu_to_skyfield_time(time)
        t1 = cu_to_skyfield_time(time_plus_minus_days)

    
    '''עבור כוכבי הלכת החיצוניים מאדים, צדק, שבתאי, אורנוס, וכל שאר הגופים מחוץ למסלולנו, 0 פירושו רגע החיבור עם השמש ו-1 פירושו רגע ההתנגדות.
    מכיוון שהירח נע מזרחה על פני השמים שלנו ביחס לשמש, לא מערבה, הפלט מתהפך בהשוואה לכוכבי הלכת החיצוניים: 0 פירושו רגע ההתנגדות או ירח מלא, בעוד ש-1 פירושו רגע החיבור או ירח חדש.
    כוכבי הלכת הפנימיים מרקורי ונוגה חווים רק קשרים עם השמש מנקודת המבט שלנו, לעולם לא ניגודים, כאשר 0 מציין צירוף נחות ו-1 צירוף עליון'''
    
    # הגדרת סוג החיפוש
    hitkabzut_nigud = almanac.oppositions_conjunctions(eph, eph[body])
    # הגדרת החיפוש על הזמנים שלעיל
    hitkabzut_nigud_times, y = almanac.find_discrete(t0, t1, hitkabzut_nigud)
    
    
    # עכשיו מפרידים את כל מה שלא צריך מתוך מערך התוצאות כי אנחנו צריכים רק 2 תוצאות
    # אם מחשבים אחורה צריך רק את 2 המיקומים !האחרונים! מתוך מערך הזמנים של התקבצות-ניגוד, כלומר מיקומים מינוס אחד ומינוס 2
    if PLUS_MINUS == "MINUS":
        hitkabzut_nigud_times, y = hitkabzut_nigud_times[-2:], y[-2:]
    # אם מחשבים קדימה צריך רק את 2 המיקומים !הראשונים! מתוך מערך הזמנים של התקופות, כלומר מיקומים אפס ואחד
    elif PLUS_MINUS == "PLUS":
        hitkabzut_nigud_times, y = hitkabzut_nigud_times[:2], y[:2]
         
    
    # הגדרת הערך המספרי המתאים עבור התקבצות וניגוד לפי האם הגוף הוא הירח או שאר הגופים
    # עבור כל מיקום במערך הזמנים של התקבצות-ניגוד, המידע האם מדובר בהתקבצות או ניגוד שמור במערך וואי במיקום המקביל.
    # בדרך כלל, אם וואי שווה אפס מדובר בהתקבצות ואם וואי שווה 1 מדובר בניגוד
    # זה נכון לגבי כל שאר הגופים חוץ מהירח, אבל לגבי הירח התקבצות שווה לאחד וניגוד שווה לאפס. לכן נהפוך את המשתנים לצורך הירח 
    # לנוגה ולכוכב חמה אין ניגוד, אז עבורם: התקבצות זה "התקבצות תחתונה", וניגוד זה "התקבצות עליונה" עבורם
    if body == "moon":
        y_hitkabzut = 1
        y_nigud = 0
    else:
        y_hitkabzut = 0
        y_nigud = 1
        
        
    # עכשיו בודקים עבור כל מקום במערך המצומצם שבו 2 זמנים האם מדובר בהתקבצות או בניגוד, לפי המספר שיש במקום המקביל במערך וואי שהוא מערך הסוגים
    for i in y:
        if y[i] == y_hitkabzut:
            hitkabzut = skyfield_to_cu_time(hitkabzut_nigud_times[i], location_timezone)
        if y[i] == y_nigud:
            nigud = skyfield_to_cu_time(hitkabzut_nigud_times[i], location_timezone)
                     
    return hitkabzut,nigud


# פונקצייה לחישוב ליקוי חמה/לבנה קרוב
# כברירת מחדל החיפוש מתבצע מהזמן הנתון ועד חמישים שנה לאחר מכן 
def eclipse_calculations(time,location,location_timezone,body="sun",PLUS_MINUS="PLUS",plus_minus_years=30):
    
    years_days = 365.25 * plus_minus_years
    
    # הגדרת תחילת וסוף התאריכים לחישוב זריחות ושקיעות
    # לחישוב התקבצות וניגוד קודמים משתמשים במינוס
    if PLUS_MINUS == "MINUS":
        time_plus_minus_years = time - dt.timedelta(days=years_days)
        t0 = cu_to_skyfield_time(time_plus_minus_years) 
        t1 = cu_to_skyfield_time(time)
    
    # בכל שאר המקרים מחשבים בפלוס את ההתקבצות והניגוד העתידיים
    else:
        time_plus_minus_years = time + dt.timedelta(days=years_days)
        t0 = cu_to_skyfield_time(time)
        t1 = cu_to_skyfield_time(time_plus_minus_years)

    
    # פונקצייה פנימית שמגדירה בשפה של סקייפילד את מהות האלונגציה בין השמש והירח בזמן מסויים כלשהו
    def moon_elongation_at(any_time):
        # השמש כפי שנראה/נמדד ממיקום הצופה
        sun_topocentric = (eph['earth'] + location).at(any_time).observe(eph['sun']).apparent()
        # הירח כפי שנראה/נמדד ממיקום הצופה
        moon_topocentric = (eph['earth'] + location).at(any_time).observe(eph['moon']).apparent()
        # אלונגציה אמיתית שלוקחת בחשבון גם את רוחב הירח: טופוצנטרית
        moon_elongation = sun_topocentric.separation_from(moon_topocentric).degrees
        return moon_elongation

    # הגדרת דילוג הימים שבהם יש לבדוק את האלונגציה. זה מה שיצא לי מהניסיון. לא צריך הרבה פחות כי ליקוי חמה יכול להיות רק פעם בחודש כלומר בשעת המולד
    moon_elongation_at.step_days = 25.0
    
    if body == "sun":
        
        # הצגת הודעה למשתמש בזמן ההמתנה לטעינת זמן הליקוי
        Waiting_eclipse = Toplevel(ws)
        Waiting_eclipse.geometry(f"{round(550*magnification_factor)}x{round(150*magnification_factor)}+{round(70*magnification_factor)}+{round(300*magnification_factor)}")
        # הגדרת צבע לכל החלון
        Waiting_eclipse.configure(bg=cu_color)
        # מיקום חלון ההמתנה מעל החלון הראשי
        Waiting_eclipse.wm_transient(ws)
        Waiting_eclipse.title(reverse('נא להמתין לחישוב הנתונים', for_title = True) if is_heb_locale else "Please wait for data calculations")
        
        msg = reverse("המתינו לטעינת תאריך ושעת הליקוי בשעון העליון\n\nשימו לב: תכונה זו איננה מושלמת\nוייתכן שעלולים להתפספס ליקויים מסויימים")
        en_msg = "Wait for the time of eclipse to be loaded in the upper clock\n\nPlease note: this feature is not perfect\nand it is possible that certain eclipses may be missed"
        Label(Waiting_eclipse, text=msg if is_heb_locale else en_msg, padx=20, pady=20,font="david 20 bold" if is_heb_locale else "david 16 bold",justify="center").pack()

        # חובה!!! עדכון ידני של חלון ההודעה כדי לוודא שהוא מוצג לפני ביצוע המשך הקוד
        Waiting_eclipse.update()

    
        # הגדרת החיפוש באמצעות פונקציית בדיקת האלונגציה
        elongations_times, elongations = find_minima(t0, t1, moon_elongation_at)

        # הגדרת מערך ריק עבור רשימת הליקויים
        eclipses = []

        # חיפוש בתוך רשימת האלונגציות רק של המקרים שבהם האלונגציה קטנה מ- 0.515 מעלות כי רק אז יהיה ליקוי מינימלי לפי מה שבדקתי
        for t, elongation_degrees in zip(elongations_times, elongations):
            if elongation_degrees < 0.5:
                # בדיקת אזימוט וגובה השמש בשעת הליקוי
                alt, az, _ = (eph['earth'] + location).at(t).observe(eph[body]).apparent().altaz()
                # אם בשעת הליקוי השמש נמצאת מעל האופק
                # אבל אולי כדאי לעבוד לפי אזימוט כי אולי שיא הליקוי הוא לפני הזריחה ועדיין אפשר לראות חלקית אחרי הזריחה
                # if az.degrees > 80 and az.degrees < 190: # בכוונה נתתי 10 מעלות נוספים לפני המזרח ואחרי המערב
                if alt.degrees > 0:
                    aaa=[skyfield_to_cu_time(t, location_timezone), elongation_degrees]
                    eclipses.append(aaa)  
                    
        # סגירת חלון ההמתנה לאחר ביצוע כל החישובים של פונקצייה זו
        Waiting_eclipse.destroy()  
            
    
    elif body == "moon":
        
        # הגדרת החיפוש באמצעות פונקציית ליקויי ירח של סקייפילד
        lunar_eclipses, lunar_eclipses_types, lunar_eclipses_details = eclipselib.lunar_eclipses(t0, t1, eph)
        
        # הגדרת מערך ריק עבור רשימת הליקויים
        eclipses = []

        # חיפוש בתוך רשימת האלונגציות רק של המקרים שבהם האלונגציה גדולה מ- 178.5 מעלות כי אולי רק אז יהיה ליקוי מינימלי 
        for eclipse, eclipse_type in zip(lunar_eclipses, lunar_eclipses_types):
            # ליקוי מלא הוא מסוג 2 וליקוי חלקי הוא מסוג 1. רק אם לא מדובר בליקוי חצי צל שהסוג שלו הוא 0, כי ליקוי כזה כמעט לא שמים לב בעין
            if eclipse_type != 0:
                # בדיקת אזימוט וגובה הירח בשעת הליקוי
                alt, az, _ = (eph['earth'] + location).at(eclipse).observe(eph[body]).apparent().altaz()
                # אם בשעת הליקוי הירח נמצא מעל האופק
                # אבל אולי כדאי לעבוד לפי אזימוט כי אולי שיא הליקוי הוא לפני הזריחה ועדיין אפשר לראות חלקית אחרי הזריחה
                # if az.degrees > 80 and az.degrees < 190: # בכוונה נתתי 10 מעלות נוספים לפני המזרח ואחרי המערב
                if alt.degrees > 0:
                    aaa=[skyfield_to_cu_time(eclipse, location_timezone), ""]
                    eclipses.append(aaa)  
                    
                    
    '''
    elif body == "moon":
        
        # הגדרת החיפוש באמצעות פונקציית בדיקת האלונגציה
        elongations_times, elongations = find_maxima(t0, t1, moon_elongation_at)
        
        # הגדרת מערך ריק עבור רשימת הליקויים
        eclipses = []

        # חיפוש בתוך רשימת האלונגציות רק של המקרים שבהם האלונגציה גדולה מ- 178.5 מעלות כי אולי רק אז יהיה ליקוי מינימלי 
        for t, elongation_degrees in zip(elongations_times, elongations):
            if elongation_degrees > 178.5:
                # בדיקת אזימוט וגובה הירח בשעת הליקוי
                alt, az, _ = (eph['earth'] + location).at(t).observe(eph[body]).apparent().altaz()
                # אם בשעת הליקוי הירח נמצא מעל האופק
                # אבל אולי כדאי לעבוד לפי אזימוט כי אולי שיא הליקוי הוא לפני הזריחה ועדיין אפשר לראות חלקית אחרי הזריחה
                # if az.degrees > 80 and az.degrees < 190: # בכוונה נתתי 10 מעלות נוספים לפני המזרח ואחרי המערב
                if alt.degrees > 0:
                    aaa=[skyfield_to_cu_time(t, location_timezone), elongation_degrees]
                    eclipses.append(aaa) 
                    '''
            
    # תמיד צריך רק את המיקום הראשון במערך כי אנחנו מחפשים את הליקוי הכי קרוב להווה, אבל אם הולכים אחורה אז צריך את המיקום האחרון ברשימה
    # אם נרצה רשימת ליקויים קרובים נצטרך להדפיס את כל המערך
    if PLUS_MINUS == "MINUS":
        eclipse = eclipses[-1][0]
    else:
        eclipse = eclipses[0][0]
        

    return eclipse


# פונקצייה לחישוב אלונגציה מירבית של נוגה
# כברירת מחדל החיפוש מתבצע מהזמן הנתון ועד חמש שנים לאחר מכן 
def calculate_venus_greatest_elongation(time,location,location_timezone,body="venus",PLUS_MINUS="PLUS",plus_minus_years=5):
    
    
    years_days = 365.25 * plus_minus_years
    
    # הגדרת תחילת וסוף התאריכים לחישוב זריחות ושקיעות
    # לחישוב התקבצות וניגוד קודמים משתמשים במינוס
    if PLUS_MINUS == "MINUS":
        time_plus_minus_years = time - dt.timedelta(days=years_days)
        t0 = cu_to_skyfield_time(time_plus_minus_years) 
        t1 = cu_to_skyfield_time(time)
    
    # בכל שאר המקרים מחשבים בפלוס את ההתקבצות והניגוד העתידיים
    else:
        time_plus_minus_years = time + dt.timedelta(days=years_days)
        t0 = cu_to_skyfield_time(time)
        t1 = cu_to_skyfield_time(time_plus_minus_years)

    
    # פונקצייה פנימית שמגדירה בשפה של סקייפילד את מהות האלונגציה בין השמש והירח בזמן מסויים כלשהו
    # לא עשיתי טופוצנטרי כי זה עושה בעיות שהאלונגציה יורדת, ואז עולה לאחר יום, ואז שוב יורדת וכך כל אירוע חוזר על עצמו כמה ימים
    def venus_elongation_at(any_time):
        # השמש כפי שנראה/נמדד ממרכז כדור הארץ
        sun_geocentric = eph['earth'].at(any_time).observe(eph['sun']).apparent()
        # נוגה כפי שנראה/נמדד ממרכז כדור הארץ
        venus_geocentric = eph['earth'].at(any_time).observe(eph['venus']).apparent()
        # אלונגציה אמיתית בין נוגה לשמש: גיאוצנטרית
        venus_elongation = sun_geocentric.separation_from(venus_geocentric).degrees
        return venus_elongation

    # הגדרת דילוג הימים שבהם יש לבדוק את האלונגציה. כך שיעור הדילוג בדוגמא של סקייפילד עצמם
    venus_elongation_at.step_days = 15.0
    
    if body == "venus":
        
        # הגדרת מערך ריק עבור רשימת הליקויים
        list_elongations = []
    
        # הגדרת החיפוש באמצעות פונקציית בדיקת האלונגציה
        elongations_times, elongations = find_maxima(t0, t1, venus_elongation_at)
        
        for t, elongation_degrees in zip(elongations_times, elongations):
            aaa=[skyfield_to_cu_time(t, location_timezone), elongation_degrees]
            list_elongations.append(aaa) 
        
        # אם הולכים אחורה אז צריך את המיקום האחרון ברשימה, ואם הולכים קדימה צריך את המיקום הראשון ברשימה
        if PLUS_MINUS == "MINUS":
            greatest_elongation = list_elongations[-1][0]
        else:
            greatest_elongation = list_elongations[0][0]
        
        return greatest_elongation


# חישוב ארבע התקופות הבאות של נקודות היפוך עונות השנה. החיפוש מתבצע כברירת מחדל לפי ארבע מאות הימים הבאים שזה קצת יותר משנה אחת
def Real_tkufot(time,location,location_timezone,PLUS_MINUS="PLUS",plus_minus_days=400):
    
    # הגדרת תחילת וסוף התאריכים לחישוב התקופות
    # לחישוב התקבצות וניגוד קודמים משתמשים במינוס
    if PLUS_MINUS == "MINUS":
        time_plus_minus_days = time - dt.timedelta(days=plus_minus_days)
        t0 = cu_to_skyfield_time(time_plus_minus_days) 
        t1 = cu_to_skyfield_time(time)
    
    # בכל שאר המקרים מחשבים בפלוס את ההתקבצות והניגוד העתידיים
    else:
        time_plus_minus_days = time + dt.timedelta(days=plus_minus_days)
        t0 = cu_to_skyfield_time(time)
        t1 = cu_to_skyfield_time(time_plus_minus_days)

 
    # הגדרת סוג החיפוש והגדרת החיפוש על הזמנים שלעיל
    seasons_times, y = almanac.find_discrete(t0, t1, almanac.seasons(eph))
    
    # עכשיו מפרידים את כל מה שלא צריך מתוך מערך התוצאות כי אנחנו צריכים רק 4 תוצאות
    # אם מחשבים אחורה צריך רק את 4 המיקומים !האחרונים! מתוך מערך הזמנים של התקופות, כלומר מיקומים מינוס אחד ומינוס 2, ומינוס3 ומינוס 4
    if PLUS_MINUS == "MINUS":
        seasons_times, y = seasons_times[-4:], y[-4:]
    # אם מחשבים קדימה צריך רק את 4 המיקומים !הראשונים! מתוך מערך הזמנים של התקופות, כלומר מיקומים אפס אחד שתיים ושלוש
    elif PLUS_MINUS == "PLUS":
        seasons_times, y = seasons_times[:4], y[:4]
         
    
    # עכשיו בודקים עבור כל מקום במערך המצומצם שבו 4 זמנים באיזו תקופה מתקופות השנה מדובר, לפי המספר שיש במקום המקביל במערך וואי שהוא מערך הסוגים
    for i in y:
        if y[i] == 0:
            Vernal_Equinox = skyfield_to_cu_time(seasons_times[i], location_timezone)
        if y[i] == 1:
            Summer_Solstice = skyfield_to_cu_time(seasons_times[i], location_timezone)
        if y[i] == 2:
            Autumnal_Equinox = skyfield_to_cu_time(seasons_times[i], location_timezone)
        if y[i] == 3:
            Winter_Solstice = skyfield_to_cu_time(seasons_times[i], location_timezone)

    
    return Vernal_Equinox,Summer_Solstice,Autumnal_Equinox,Winter_Solstice

# פונקצייה לחישוב חצות שמשי אמיתי וההפרש בינו לבין חצות שמשי מקומי ממוצע כלומר: משוואת הזמן
# אולי בעתיד כל החלק של משוואת הזמן יהיה בבדיקה שנתית מלאה ולא בדרך של בדיקת הפער בין השעה 12 לבין חצות מקומי
def calculate_transits_and_equation_of_time(time,location,location_timezone):
    
    # הגדרת הזמן לשעה שש בבוקר
    time_6 = time.replace(hour=6, minute=0, second=0, microsecond=0)
    
    # חישוב חצות היום והלילה בחיפוש בין שש בבוקר לשש בבוקר למחורת: נזכיר כי הזמן הוא כבר בשעון מקומי
    meridian_transit = almanac.meridian_transits(eph, eph["sun"], location)
    transit, y = almanac.find_discrete(cu_to_skyfield_time(time_6), cu_to_skyfield_time(time_6 + dt.timedelta(hours=24)), meridian_transit)
    day_transit = skyfield_to_cu_time(transit[0], location_timezone)
    night_transit = skyfield_to_cu_time(transit[1], location_timezone)
    # אם רוצים רק טרנזיט של היום בשיטה החדשה של סקייפילד
    #transit = almanac.find_transits(eph['earth'] + location, eph['sun'], cu_to_skyfield_time(time_6), cu_to_skyfield_time(time_6 + dt.timedelta(hours=24)))
    #day_transit = skyfield_to_cu_time(transit[0], location_timezone)
    
    #-----------
    # חישוב משוואת הזמן
    # חישוב חצות האמיתי באיזה שעה הוא בשעון מקומי ממוצע
    transit_lmt = localmeantime(day_transit.astimezone(timezone('utc')),location.longitude.degrees)
    
    # הגדרת זמן של 12 בצהריים בדיוק מפני ששעה זו אמורה להיות שעת חצות בממוצע שנתי כשסולם הזמן מכוון כראוי
    #transit_mean = transit_lmt.replace(hour=12, minute=0, second=0, microsecond=0)
    
    # אפשרות אחרת הכי מדוייקת אבל עם בעיות משלה וכדלהלן
    # שיטה הכי מדוייקת, שכרוכה ביותר חישובים, ונדרשת בגלל השגיאה של סולם הזמן יו.טי.1 בסקייפילד שגורמת שחצות בממוצע שנתי הוא לא בדיוק ב-12:00
    # בגלל השגיאה בסולם הזמן של סקייפילד השימוש בשיטה זו גורם ששעון מקומי אמיתי לא מראה בחצות את 12:00 אך משוואת הזמן מדוייקת
    # לעומת זאת שימוש בשיטה הקודמת לפי 12:00 גורם שיש אחידות בין השעונים וחצות בשעון מקומי אמיתי הוא ב-12:00 אך משוואת הזמן לא נכונה בשיעור השגיאה של סולם הזמן
    # ראו גם פונקציית חישוב השגיאה של סולם הזמן
    
    # חישוב חצות היום בממוצע שנתי, בשעון מקומי ממוצע, במיקום הנוכחי, באמצעות פונקצייה שהוגדרה
    #mean_time = calcolate_local_year_mean_transit(time.year, location)
    
    # כדי לחסוך בחישובים מיותרים, במקום להשתמש בשורה הקודמת בניתי מילון. המילון מוגדר בפונקציית טיים_לוקיישן_טיימזון כדי שיתעדכן מיד ויהיה זמין לכל התוכנה
    # קוראים מהמילון את הערך של חצות היום בממוצע שנתי במיקום זה. אם המיקום או השנה משתנים הערך משתנה בפונקציית טיים_לוקיישן_טיימזון
    mean_time = mean_transit_and_error_timescale_dict["year_mean_transit"]
    
    # שעון גריניץ של חצות הממוצע
    transit_mean = transit_lmt.replace(hour=mean_time.hour, minute=mean_time.minute, second=mean_time.second, microsecond=mean_time.microsecond)
    
    
    # בדיקת פער הזמן כלומר הדלתא בין שעה מקומית ממוצעת של חצות האמיתי לבין שעה מקומית ממוצעת של חצות הממוצע ובדיקה האם יש להוסיף דקות או להפחית דקות
    if transit_lmt < transit_mean:
        equation_of_time = transit_mean-transit_lmt
        seconds_equation_of_time = equation_of_time.total_seconds()
        str_equation_of_time = f'+{str(equation_of_time)[2:7]}'
    else:
        equation_of_time = transit_lmt-transit_mean
        seconds_equation_of_time = - equation_of_time.total_seconds()
        str_equation_of_time = f'-{str(equation_of_time)[2:7]}'
        
    # היה אפשר להגדיר כך את str_equation_of_time 
    #str_equation_of_time = f'{"+" if seconds_equation_of_time >=0 else "-"}{convert_seconds(abs(seconds_equation_of_time))}'
        
    return day_transit, night_transit, seconds_equation_of_time, str_equation_of_time 
        

# פונקצייה לחישוב זריחות ושקיעות לכל כוכבי הלכת כולל גובה ואזימוט בשעת זריחה ושקיעה, כולל שקיעה בגבהים שונים, כולל הגדרות לבחירת זריחה או שקיעה קודמים או הבאים    
def calculate_rising_seting(time,location,location_timezone,horizon=0, body="moon", PLUS_MINUS = "NONE", plus_minus_hours = 24.5):
    
    # הגדרת תחילת וסוף התאריכים לחישוב זריחות ושקיעות 
    # בגלל שהפרש הזמן בין שני זריחות של הירח הוא בערך עד 65 דקות *יותר מיממה*, ואולי לפעמים יותר, נאלצתי לחפש את זמני הירח על פני 26 שעות
    # כמו כן, לפעמים יש כמה דקות יותר מאשר 24 שעות בין שקיעה לשקיעה של השמש וכדומה בגלל שאורך היממה של 24 שעות הוא רק ממוצע, לכן חיפוש על 24.5 שעות
    # בנוסף, החיפוש של הירח צריך להיות לפי זריחה או שקיעה הקודמת או הבאה, ולא חיפוש זריחה ושקיעה בתאריך נתון כי יש תאריכים שיש בהם רק זריחה או רק שקיעה של הירח
    
    if body == "moon":
        plus_minus_hours = 26
    
    if PLUS_MINUS == "PLUS":
        t0 = cu_to_skyfield_time(time)
        t1 = cu_to_skyfield_time(time + dt.timedelta(hours=plus_minus_hours))
    elif PLUS_MINUS == "MINUS":
        t0 = cu_to_skyfield_time(time - dt.timedelta(hours=plus_minus_hours))
        t1 = cu_to_skyfield_time(time)
    elif PLUS_MINUS == "NONE":
        time_midnight = time.replace(hour=0, minute=0, second=0, microsecond=0)
        next_midnight = time_midnight + dt.timedelta(days=1)
        t0 = cu_to_skyfield_time(time_midnight)
        t1 = cu_to_skyfield_time(next_midnight)
        
    
    
    ######################## מכאן לפי שיטת הפעולה הישנה של סקייפילד שנבדקה ועובדת היטב
    # הגדרת זריחה ושקיעה
    rise_set = almanac.risings_and_settings(eph, eph[body], location, horizon_degrees=horizon, radius_degrees=0)
    
    # חיפוש הזריחה והשקיעה המבוקשים בין שני התאריכים
    # יש לשים לב שעלולים להיות במערך התוצאות יותר מזריחה אחת ושקיעה אחת
    rise_set_times, y = almanac.find_discrete(t0, t1, rise_set)   
    
    # עכשיו מפרידים את כל מה שלא צריך מתוך מערך התוצאות כי אנחנו צריכים רק 2 תוצאות
    # אם מחשבים אחורה צריך רק את 2 המיקומים !האחרונים! מתוך מערך הזמנים של זריחה-שקיעה, כלומר מיקומים מינוס אחד ומינוס 2
    if PLUS_MINUS == "MINUS":
        rise_set_times, y = rise_set_times[-2:], y[-2:]
    # אם מחשבים קדימה צריך רק את 2 המיקומים !הראשונים! מתוך מערך הזמנים של זריחה-שקיעה, כלומר מיקומים אפס ואחד
    elif PLUS_MINUS == "PLUS":
        rise_set_times, y = rise_set_times[:2], y[:2]
     
    # עכשיו בודקים עבור כל מקום במערך המצומצם שבו 2 זמנים האם מדובר בזריחה או שקיעה, לפי המספר שיש במקום המקביל במערך וואי שהוא מערך הסוגים
    # אחד זה זריחה ואפס זה שקיעה
    # בשלב זה לא עושים אסטימזון כי עדיין צריך לחשב אזימוט וגובה כשהזמנים הם בפורמט של סקייפילד
    for i in y:
        if y[i] == 1:
            rising = rise_set_times[i]
        if y[i] == 0:
            setting = rise_set_times[i]
            
    # השורה הבאה נועדה רק לצורך בדיקה האם יש מידע בבשני המיקומים שאמורים להיות במערך הזריחות והשקיעות
    # במקרה שאין זריחות ושקיעות בתאריך זה, תוחזר שגיאת אינדקס שלפיה נדע שאין זריחות ושקיעות במקום זה בתאריך זה
    _,_, = rise_set_times[0], rise_set_times[1]
    
    ######################## עד כאן לפי שיטת הפעולה הישנה של סקייפילד
    
    '''    
    ######################## מכאן לפי שיטת הפעולה החדשה של סקייפילד - ועדיין לא נבדק כהוגן########    
    ######### לפי השיטה החדשה לא מוחזר שגיאה אם אין זריחה מתאימה כמו בקוטב ולא מצויין גובה הזריחה. זה מחזיר את גובה הזריחה הקרוב המתאים
    
    # חיפוש הזריחה והשקיעה המבוקשים בין שני התאריכים
    # יש לשים לב שעלולים להיות במערך התוצאות יותר מזריחה אחת ושקיעה אחת
    rising, rise_y = almanac.find_risings(eph['Earth'] + location, eph[body], t0, t1, horizon_degrees=horizon)
    setting, set_y = almanac.find_settings(eph['Earth'] + location, eph[body], t0, t1, horizon_degrees=horizon)
    
    # עכשיו מפרידים את כל מה שלא צריך מתוך מערך התוצאות כי אנחנו צריכים רק תוצאה אחת לזריחה ותוצאה אחת לשקיעה
    # אם מחשבים אחורה צריך רק את המיקום !האחרון! מתוך מערך הזמנים של זריחה-שקיעה, כלומר מיקומים מינוס אחד
    if PLUS_MINUS == "MINUS":
        rising, rise_y = rising[-1], rise_y[-1]
        setting, set_y = setting[-1], set_y[-1]
    # אם מחשבים קדימה או אם מחשבים סתם באותו יום צריך רק את המיקום !הראשון! מתוך מערך הזמנים של זריחה-שקיעה, כלומר מיקום אפס
    else: #elif PLUS_MINUS == "PLUS":
        rising, rise_y = rising[0], rise_y[0]
        setting, set_y = setting[0], set_y[0]
     
    ######################## עד כאן לפי שיטת הפעולה החדשה של סקייפילד
    '''
    
    # בדיקת אזימוט וגובה בשעת הזריחה ובשעת השקיעה
    rise_alt, rise_az, _ = (eph['earth'] + location).at(rising).observe(eph[body]).apparent().altaz()
    set_alt, set_az, _ = (eph['earth'] + location).at(setting).observe(eph[body]).apparent().altaz()
    
    # הגדרת הזמנים לפי שעון מקומי וגובה ואזימוט לפי מעלות
    rising = skyfield_to_cu_time(rising, location_timezone)
    setting = skyfield_to_cu_time(setting, location_timezone)
    rise_alt = rise_alt.degrees
    rise_az = rise_az.degrees
    set_alt = set_alt.degrees
    set_az = set_az.degrees
    
    return rising,setting,rise_alt,rise_az,set_alt,set_az
    



# פונקצייה לחישוב שעה זמנית
# הערה: ברוב ימות השנה, רק בדיוק בקו רוחב 0 שעון שעה זמנית נותן בחצות היום !האמיתי! שעה 06:00 בדיוק, והסיבה לזה כנראה לא תלוייה בתוכנה אלא במציאות
# פונקצייה שמחזירה מה השעה הזמנית הנוכחית וכמה שניות יש בשעה זמנית ביום זה.
# היא מקבלת את הזמן המבוקש וגם את הזריחה והשקיעה הקובעים
def calculate_temporal_time(datetime_input, sunrise_today, sunset_today, sunrise_tomorrow, sunset_yesterday):
    
    ##########################################################################################################
    # הגדרת תחילת וסוף היממה מבחינת התאריך הלועזי, ובדיקה מה הזריחה והשקיעה הקובעים עבור גרא ומגא
    input_date_start = datetime_input.replace(hour=0, minute=0, second=0, microsecond=0)
    input_date_end = input_date_start + timedelta(days=1)
    
    # בין 12 בלילה לזריחה: מחשבים מהשקיעה של אתמול לזריחה של היום
    if sunrise_today and sunset_yesterday and datetime_input >= input_date_start and datetime_input < sunrise_today:
        sunrise_determines, sunset_determines = sunrise_today, sunset_yesterday
        day_night_str = reverse("לילה") if is_heb_locale else "night"

    # בין הזריחה לשקיעה: מחשבים מהזריחה של היום לשקיעה של היום
    elif sunrise_today and sunset_today and datetime_input >= sunrise_today and datetime_input < sunset_today:
        sunrise_determines, sunset_determines = sunrise_today, sunset_today
        day_night_str = reverse("יום") if is_heb_locale else "day"

    # בין השקיעה ל־12 בלילה: מחשבים מהשקיעה של היום עד הזריחה של מחר
    elif sunset_today and sunrise_tomorrow and datetime_input >= sunset_today and datetime_input < input_date_end:
        sunrise_determines, sunset_determines = sunrise_tomorrow, sunset_today
        day_night_str = reverse("לילה") if is_heb_locale else "night"

    # אם חסר נתון או שלא נכנס לאף טווח
    else:
        sunrise_determines, sunset_determines = None, None
        temporal_time = "--:--"
        day_night_str = "?"
        seconds_in_temporal_hour = 0.0
        return temporal_time, seconds_in_temporal_hour, sunrise_determines, sunset_determines, day_night_str
    ##############################################################################################################
    
    # מסדר את הזריחה והשקיעה הקובעים, מהמוקדם למאוחר
    START, END = sorted((sunrise_determines, sunset_determines))
        
    # חישוב כמה שניות יש מהזריחה ועד השקיעה בחלוקה לשתייים עשרה שזה אומר כמה שניות יש בשעה זמנית של היום
    sec_TH = (END - START) / 12
    # חישוב כמה שניות עברו מהזריחה עד עכשיו
    SR_or_SS_to_time = datetime_input - START
    
    # כעת מחלקים את הזמן שעבר מהזריחה או מהשקיעה ועד עכשיו, בזמן שיש בכל שעה זמנית ביום זה והתוצאה היא השעה הזמנית המתאימה לרגע זה
    # הערה: הוספתי 0.0000001 כדי שלא תהיה שגיאה של נקודה צפה בחישוב השניות
    A = (SR_or_SS_to_time / sec_TH) + 0.0000001
    zmanit_hour = int(A) 
    B = ((A - zmanit_hour) * 60) + 0.0000001
    zmanit_minute = int(B)
    C = ((B - zmanit_minute) * 60) + 0.0000001
    zmanit_second = int(C)

    # הדפסת השעה הזמנית המתאימה
    temporal_time = f'{zmanit_hour:02.0f}:{zmanit_minute:02.0f}:{zmanit_second:02.0f}'
    
    # שבר עשרוני של מספר השניות ומיקרושניות שיש בשעה זמנית אחת
    seconds_in_temporal_hour = sec_TH.total_seconds()

    return temporal_time, seconds_in_temporal_hour, sunrise_determines, sunset_determines, day_night_str


#####################################################################################

# פונקצייה שמחשבת מהי שעת חצות המקומית בממוצע שנתי במיקום מסויים ובשנה מסויימת
# השנה זה מספר שלם והמיקום זה מיקום בפורמט סקייפילד
# שימו לב! הפונקצייה מחזירה זמן בשעון מקומי ממוצע שמדוייק למיקום המבוקש באמצעות פונקציית localmeantime
def calcolate_local_year_mean_transit(year, location):

    # חישוב חצות היום בלבד במיקום המבוקש בשיטה החדשה של סקייפילד עבור כל יום מימי השנה המבוקשת
    # כרגע אין שגיאות אבל בעיקרון האפאמרים לא מכסה את היומיים הראשונים של שנת 1 לספירה הנוצרית
    year_start = ts.ut1(year, 1, 1, 0, 0 ,0) if is_ut1 else ts.utc(year, 1, 1, 0, 0 ,0)
    year_end = ts.ut1(year, 12, 31, 23, 59 ,59) if is_ut1 else ts.utc(year, 12, 31, 23, 59 ,59)
    transits = almanac.find_transits(eph['earth'] + location, eph['sun'], year_start, year_end)
    # המרת כל זמני החצות לזמנים שלהם באיזור זמן גריניץ בסולם הזמן המתאים, לתוך מערך חדש
    transits = [transit.ut1_calendar() for transit in transits] if is_ut1 else [transit.utc for transit in transits]
    # המרה של שעת חצות היום של כל יום מימי השנה מ-שעות דקות ושניות - ל-שניות ואיסוף סכום סופי של כל השניות
    total_seconds = sum(time[3] * 3600 + time[4] * 60 + time[5] for time in transits) if is_ut1 else sum(time.hour * 3600 + time.minute * 60 + time.second for time in transits)
    
    # חישוב ממוצע של מספר השניות שזה בעצם חישוב של חצות ממוצע עבור כל השנה
    average_seconds = total_seconds // len(transits)

    # הפיכת הזמן שהתקבל לזמן פייתון (תחילת יממה ראשונה של השנה זה לא בדווקא אלא יכול להיות כל שנה)
    transit_mean = datetime(year, 1, 1) + timedelta(seconds=average_seconds)
    
    return localmeantime(transit_mean,location.longitude.degrees)


# הפונקצייה הבאה בודקת מה מידת השגיאה בשניות של סולם הזמן של סקייפילד שבשימוש כרגע
# מידת השגיאה נקבעת לפי מידת ההבדל בשניות בין חצות שנתי מקומי ממוצע לבין השעה 12:00 שם
# הפונקצייה דורשת משתנה אחד שהוא זמן חצות בממוצע שנתי בשעון מקומי
def calculate_seconds_error_timescale(transit_mean):
    
    # הפיכת הזמן הממוצע לשעה 12:00
    transit_12 = transit_mean.replace(hour=12, minute=0, second=0, microsecond=0)

    # בדיקת פער הזמן כלומר הדלתא בין שעה מקומית ממוצעת של חצות לבין השעה 12 בצהריים ובדיקה האם יש להוסיף דקות או להפחית דקות
    if transit_mean < transit_12:
        error_timescale = transit_12-transit_mean
        seconds_error_timescale = error_timescale.total_seconds()
    else:
        error_timescale = transit_mean-transit_12
        seconds_error_timescale = - error_timescale.total_seconds()

    return seconds_error_timescale


####################################################################################################################
                          # פונקציות לשימוש התוכנה או הממשק הגרפי או טקינטר
####################################################################################################################

# מחלקה מיוחדת עבור טקינטר תת אזור בסיוע רובי הבוט
class cu_PanedWindow(PanedWindow):
    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.configure(bg=cu_color)


#---------------------------
# פונקצייה לקבל מיקום מוחלט של קובץ שאמור להיות כלול בתוכנה
# ראו: https://stackoverflow.com/questions/7674790/bundling-data-files-with-pyinstaller-onefile/44352931#44352931
def resource_path(relative_path):
    """ Get absolute path to resource, works for dev and for PyInstaller """
    try:
        # PyInstaller creates a temp folder and stores path in _MEIPASS
        base_path = sys._MEIPASS
    except Exception:
        base_path = os.path.abspath(".")

    return os.path.join(base_path, relative_path)

# פונקציה לקביעת כיוון הטקסט בעברית אם זה ווינדוס אז ישר ואם זה לינוקס אז מבצעים הפיכת הטקסט מהסוף להתחלה
def text_orientation(text):
    return text[::-1] if is_linux_heb else text


# הגדרות בסיסיות עבור התוכנה    
def get_defaults():   
    
    # נתיב לתיקיית הנתונים של קבצים הדרושים לתוכנה בתיקית המשתמש במערכת ההפעלה
    # עשיתי roaming=True בגלל שבגרסאות הקודמות התיקייה הייתה בתוך רומינג ולא רציתי שיאבדו הקבצים למשתמשים הקודמים
    cu_dir_path = user_data_dir(appname="cochavim_uzmanim", appauthor=False, roaming=True) # roaming=False
    
    # יצירת התיקייה אם לא קיימת ולא תהיה שגיאה אם כן קיימת
    os.makedirs(cu_dir_path, exist_ok=True)
    

    # הגדרת המיקום הראשון של שני קבצי האפאמאריס בתיקיית כוכבים וזמנים
    eph_440_path_1 = os.path.join(cu_dir_path, "de440.bsp")
    eph_441s_path_1 = os.path.join(cu_dir_path, "de441s.bsp")
    
    # הגדרת המיקום השני של שני קבצי האפאמאריס בתיקייה שבה התוכנה פועלת כרגע במיקום המוחלט הבא
    eph_440_path_2 = resource_path("de440.bsp")
    eph_441s_path_2 = resource_path("de441s.bsp")
    
    # אם קבצי האפאמאריס לא נמצאים בתיקיים כוכבים וזמנים שזה המיקום הראשון אז הם נמצאים בתיקייה שבה התוכנה פועלת שזה המיקום השני
    eph_440_path = eph_440_path_1 if os.path.exists(eph_440_path_1) else eph_440_path_2
    eph_441s_path = eph_441s_path_1 if os.path.exists(eph_441s_path_1) else eph_441s_path_2

    # טעינת שני קבצי האפאמאריס אם הם קיימים באחד משני המיקומים. אפאמאריס שלא קיים מקבל ערך: פָאלס
    eph_440 = load_file(eph_440_path) if os.path.exists(eph_440_path) else False
    eph_441s = load_file(eph_441s_path) if os.path.exists(eph_441s_path) else False
    
    # הגדרת ברירת המחדל היא שהאפאמריס שבשימוש הוא אפאמאריס 440 שבדרך כלל מגיע מראש עם התוכנה 
    eph = eph_440

    state1 = 'readonly'

    # טעינת כל השנים המתאימות לתוך מערך, כי אם הם ב-ריינג לוקח להם הרבה יותר זמן להיטען
    input_years_range = [f"{i:02.0f}" for i in range(1,3000)]
    
    # הגדרת הכתובת עבור קובץ המיקומים הערוך שהוא קובץ המיקומים העדכני ביותר 
    locations_edited_path = os.path.join(cu_dir_path, "locations_edited.csv")
    
    #######################
    '''
    # כל הטיפול בשם קובץ המיקומים הערוך הישן הוא זמני לצורך המשתמשים הישנים של התוכנה
    if os.path.exists(cu_dir_path+'\מיקומים-ערוך.csv') and not os.path.exists(locations_edited_path):      
        # שינוי שמו של קובץ המיקומים הערוך מהשם הישן לשם החדש
        try:
            os.rename(cu_dir_path+'\מיקומים-ערוך.csv', locations_edited_path)
        except:
            pass
    '''
    ######################
          
    locations_path = locations_edited_path if os.path.exists(locations_edited_path) else resource_path('cu_locations.csv')
    
    # הגדרת מיקום מוחלט של קובץ הכוכבים הדיפולטי שנמצא בתיקיית ההתקנה
    stars_path = resource_path('cu_stars.csv')
    
    # קבלת נתיב מלא של התיקייה הזמנית (או לא זמנית) שממנה פועלת כעת התוכנה סתם כדוגמא הלכתי לפי קובץ הכוכבים כדוגמא לקובץ שצריך להיות בתיקיית הריצה הראשית
    absolute_temp_path = os.path.abspath(os.path.dirname(stars_path))
    
    # בדיקה האם זו גרסה מותקנת או לא באמצעות בדיקה האם התיקייה פועלת מתוך תיקייה שמתחילה ב _MEI שאז זו תיקייה זמנים וזה גרסה ניידת ולא מותקנת
    is_installed = not os.path.basename(absolute_temp_path).startswith("_MEI")
    
    # השגיאה המתקבלת כאשר טווח השנים לא קיים באפמאריס
    #skyfield.errors.EphemerisRangeError
    
    settings_path = os.path.join(cu_dir_path, "cu_settings.json")

    return eph, eph_440, eph_441s, state1, input_years_range, locations_path, locations_edited_path, stars_path, settings_path, cu_dir_path, is_installed


# פונקצייה עם כמה אופציות לעריכת שינויים בקובץ המיקומים הערוך
def edit_locations_file(location = "NONE"):
    
    # הצהרה על המשתנה הגלובלי שמחזיק את המידע האם נעשה שימוש בקובץ המיקומים הערוך או המקורי
    global which_locations_file
    
    # כאשר נעשה שימוש בקובץ המיקומים המקורי אין שום משמעות לפונקצייה זו ולכן מדלגים על כולה
    if which_locations_file == "מקורי":
        if is_heb_locale:
            tkMessageBox.showinfo(reverse("שגיאה"), reverse("לא ניתן לערוך את קובץ המיקומים המקורי. לחץ על 'איפוס קובץ המיקומים' ונסה שוב. אם השגיאה חוזרת לאחר האיפוס - אין אפשרות במחשב זה לערוך שינויים במיקומים"))
        else:
            tkMessageBox.showinfo("Error", "It is not possible to edit the original location file. Click on 'Reset the location file' and try again. If the error returns after the reset - it is not possible to edit locations on this computer")
        pass
    
    # רק הוספת מיקום וכן מיון המיקומים רלוונטיים גם כאשר המיקום מוגדר על בחירה ידנית. כל שאר האופציות לא אפשריות במצב זה
    elif city.get() in [reverse("בחירה-ידנית"), "Choose manually"] and choice_option.get() not in ["ADD", "SORT"]:
        pass
    
    # בכל מקרה אחר הפונקצייה פועלת כרגיל
    else:
    
        # קבלת הגדרות ברירות מחדל עבור התוכנה באמצעות פונקצייה
        _, _, _, _, _, locations_path,locations_edited_path,_, _, cu_dir_path,_ = get_defaults()
        
        current_city = reverse(city.get()) # חייבים לעשות ככה כדי לעשות רוורס בחזרה בלינוקס 
        
        # טעינת קובץ המיקומים מתוך המיקום המוחלט
        with open(locations_path, 'r', encoding=cu_encod) as myFile:
            reader = csv.reader(myFile)
            locations_data = list(reader)

        # הסרת שורות ריקות מהמערך שהתקבל מקובץ המיקומים
        locations_data = [i for i in locations_data if i]

        # במקרה שהמשתמש לוחץ על כפתור מחיקת מיקום מקובץ המיקומים אז המיקום שבחר נהפך לריק ובהמשך נסיר את הריקים מהמערך 
        # הסיבה שהשתמשתי בהפיכה לריק ולא ב "מחיקה" היא כי משום מה במחיקה חזרה שגיאה שוב ושוב שלא הצלחתי לפתור
        if choice_option.get() == "DELETE":
            
            # שאילה האם המשתמש בטוח שברצונו לשנות את מיקום ברירת המחדל של התוכנה
            if is_heb_locale:
                msg_box = tkinter.messagebox.askquestion(reverse('אישור מחיקת מיקום מקובץ המיקומים'),reverse('\nהאם אתה בטוח שברצונך למחוק את המיקום הנוכחי מקובץ המיקומים?\nאם כן, התוכנה תיסגר ויש להפעילה מחדש'),icon='warning', default="no")
            else:
                msg_box = tkinter.messagebox.askquestion('Confirmation to delete a location from the location file','\nAre you sure you want to delete the current location from the location file?\nIf so, the software will close and must be restarted',icon='warning', default="no")
            # אם המשתמש ענה שהוא רוצה למחוק מיקום
            if msg_box == 'yes':
                # חיפוש בכל מיקום ומיקום שבקובץ הנתונים בלי לחשב את השורה הראשונה שהיא רק המפתח מה יש בכל עמודה
                for i in range(len(locations_data))[1:]:
                    location_name = locations_data[i][0] if is_heb_locale else locations_data[i][-1] # תמיד השם באנגלית נמצא במיקום האחרון
                    if location_name == current_city:
                        locations_data[i] = ""
                        #del(locations_data[i])

        # במקרה שהמשתמש לוחץ על כפתור הגדרת מיקום נוכחי כברירת מחדל
        # אם שם המיקום שווה לשם שמופיע כעת ברשימת המיקומים אבל אינו מופיע במיקום הראשון של רשימת המיקומים 
        # זהו מיקום ברירת המחדל שאנו רוצים והוא יתווסף למיקום הראשון ברשימת המיקומים ויימחק ממיקומו הקודם
        elif choice_option.get() == "DEFAULT":
            if is_heb_locale:
                msg_box = tkinter.messagebox.askquestion(reverse('אישור הגדרת מיקום כברירת מחדל'),reverse('\nהאם אתה בטוח שברצונך להגדיר את המיקום הנוכחי כברירת מחדל?\nאם כן, התוכנה תיסגר ויש להפעילה מחדש'),icon='warning',default="no")
            else:
                msg_box = tkinter.messagebox.askquestion('Confirm setting default location','\nAre you sure you want to set the current location as default?\nIf so, the software will close and must be restarted',icon='warning',default="no")
            # אם המשתמש ענה שהוא רוצה להגדיר את המקום כברירת מחדל
            if msg_box == 'yes':
                # חיפוש בכל מיקום ומיקום שבקובץ הנתונים בלי לחשב את השורה הראשונה שהיא רק המפתח מה יש בכל עמודה
                for i in range(len(locations_data))[1:]:
                    location_name = locations_data[i][0] if is_heb_locale else locations_data[i][-1] # תמיד השם באנגלית נמצא במיקום האחרון
                    first_row_location_name = locations_data[1][0] if is_heb_locale else locations_data[1][-1] # תמיד השם באנגלית נמצא במיקום האחרון
                    if location_name == current_city and first_row_location_name != current_city:
                        locations_data.insert(1,locations_data[i])
                        del(locations_data[i+1])
                        #locations_data[1] = locations_data[i] # לא בשימוש כי יש פתרון טוב יותר  


        # הוספת מיקום ידני חדש לראש רשימת המיקומים שבקובץ הערוך. המיקום המבוקש להוספה מתקבל מפונקצייה אחרת כארגומנט בקריאה לפונקצייה זו
        # המשך של פונקציית add_new_location
        elif choice_option.get() == "ADD":
            # שאילה האם המשתמש בטוח שברצונו להוסיף מיקום חדש לרשימת המיקומים
            if is_heb_locale:
                msg_box = tkinter.messagebox.askquestion(reverse('אישור הוספת מיקום לקובץ המיקומים'),reverse('\nהאם אתה בטוח שברצונך להוסיף את המיקום החדש לרשימת המיקומים?\nאם כן, התוכנה תיסגר ויש להפעילה מחדש'),icon='warning',default="no")
            else:
                msg_box = tkinter.messagebox.askquestion('Confirmation of adding a location to the location file','\nAre you sure you want to add the new location to the list of locations?\nIf so, the software will close and must be restarted',icon='warning',default="no ")
            # אם המשתמש ענה שהוא רוצה להוסיף מיקום
            if msg_box == 'yes':
                # הוספת המיקום החדש לראש רשימת המיקומים
                locations_data.insert(1,location)
                
        # מיון רשימת המיקומים לפי א-ב        
        elif choice_option.get() == "SORT":
            if is_heb_locale:        
                msg_box = tkinter.messagebox.askquestion(reverse('אישור מיון קובץ המיקומים לפי א-ב'),reverse('\nהאם אתה בטוח שברצונך למיין את קובץ המיקומים לפי א-ב?\nאם כן, התוכנה תיסגר ויש להפעילה מחדש\nבהפעלה הבאה תוכל להגדיר מחדש מיקום ברירת מחדל'),icon='warning',default="no")
            else:
                msg_box = tkinter.messagebox.askquestion('Confirmation of sorting the location file by A-B-C','\nAre you sure you want to sort the location file by A-B?\nIf so, the software will close and have to be restarted\nOn the next run you can redefine a location default',icon='warning',default="no")
            # אם המשתמש ענה שהוא רוצה למיין
            if msg_box == 'yes':
                # שמירת משתנה ובו שורת כותרות הטורים
                A = locations_data[0]
                # מיון לפי א-ב של כל שאר השורות חוץ מהשורה הראשונה שיש בה את כותרות הטורים
                locations_data = sorted(locations_data[1:], key=lambda row: row[0 if is_heb_locale else 5])  #,reverse=True / key=operator.itemgetter(0)
                # הוספת כותרות הטורים לראש רשימת המיקומים העדכנית
                locations_data.insert(0,A)


        # הסרת מיקומים ריקים ממערך המיקומים למקרה שהמשתמש מחק מיקום
        locations_data = [i for i in locations_data if i]

        # שינוי קובץ המיקומים יתבצע רק אם המשתמש השיב בחיות שברצונו לבצע את אחת האופציות שיש לפונקצייה זו
        if msg_box == 'yes':
            
            # כתיבת הנתונים המתוקנים לתוך קובץ חדש שיאוכסן בתיקיייה של התוכנה באפפ-דאטה ובפעם הבאה שיפתחו את התוכנה המיקומים ייקראו מהמיקום החדש
            with open(locations_path, 'w', encoding=cu_encod, newline='') as newFile:
                myWriter = csv.writer(newFile)
                # כתיבת כל המיקומים לאותו קובץ
                myWriter.writerows(locations_data)
                # סגירת התוכנה כדי שבפעם הבאה התוכנה תיפתח מיד במיקום ברירת מחדל החדש
                ws.destroy()

            
# פונקצייה לפתיחת תיקיית כוכבים וזמנים        
def start_cu_dir_path():
    if os.path.exists(cu_dir_path):
        # שאילה האם המשתמש בטוח שברצונו לפתוח את קובץ המיקומים הערוך
        if is_heb_locale:
            msg_box = tkinter.messagebox.askquestion(reverse('פתיחת תיקיית כוכבים וזמנים'),reverse('\nהאם ברצונך לפתוח את תיקיית כוכבים וזמנים?\nאם כן, יש להיזהר לא לפגוע בקבצים שבה'),icon='warning', default="no")
        else:
            msg_box = tkinter.messagebox.askquestion('Opening the Stars and Times folder','\nDo you want to open the Stars and Times folder?\nIf so, be careful not to damage the files in it',icon='warning', default="no")
        if msg_box == 'yes':
            subprocess.run(["explorer" if is_windows else "xdg-open", str(cu_dir_path)])

# פונקצייה לפתיחת אתר האינטרנט של כוכבים וזמנים באמצעות דפדפן ברירת המחדל של המשתמש
def open_cu_website():
    cu_url = "http://sites.google.com/view/cochavim-uzmanim/"
    webbrowser.open(cu_url)

    
# פונקצייה למציאת תאריך הגרסה העדכנית ביותר של תוכנת כוכבים וזמנים הזמינה באתר האינטרנט של כוכבים וזמנים
# כברירת מחדל מוגדר שמדובר בבדיקה ידנית שהמשתמש יוזם 
def is_cu_software_update(manual=True):
        
    # הצהרה על משתנה גלובלי שמכיל מידע על תאריך הגרסה הנוכחית של התוכנה
    global cu_version_date

    # קישור לקובץ שבו מעודכן תאריך הגרסה האחרונה הקיימת
    url = "https://github.com/sgbmzm/cochavim-uzmanim/releases/download/cochavim_uzmanim_plus/cu_version.txt"

    # ניסיון כי אולי אין חיבור לאינטרנט. אם אין חיבור מוציאים הודעה ומפסיקים את הפעולה
    try:
        # קריאת הטקסט שבאתר בעזרת ספריית urllib.request
        date_string = urlopen(url).read().decode('utf-8').strip()
        date_object = datetime.strptime(date_string, "%d/%m/%Y").date()
        
        # הגדרת מה נקרא שהגרסה מעודכנת
        is_apdate = cu_version_date >= date_object
        
        # אם התוכנה אינה עדכנית יש להוציא הודעה
        if not is_apdate:
            if is_heb_locale:
                tkMessageBox.showinfo(reverse("בדיקת גרסה עדכנית לתוכנת כוכבים וזמנים"), reverse(f"הגרסה שברשותך אינה עדכנית\nתאריך הגרסה שברשותך:  {cu_version_date:%d/%m/%Y}\nתאריך הגרסה העדכנית באתר כוכבים וזמנים:  {date_object:%d/%m/%Y}\nהאתר ייפתח כעת בדפדפן כדי שתוכלו להוריד גרסה חדשה"))
            else:
                tkMessageBox.showinfo("Checking the latest version of the cochavim uzmanim software", f"The version you have is not up to date\nThe date of the version you have: {cu_version_date:%d/%m/%Y}\nThe date of the latest version on the cochavim uzmanim website: {date_object:%d/ %m/%Y}\nThe site will now open in the browser so you can download a new version")
            # פתיחת אתר כוכבים וזמנים
            open_cu_website()
            
        # אם התוכנה עדכנית ומדובר בבדיקה ידנית יש להוציא הודעה
        elif manual and is_apdate:
            if is_heb_locale:
                tkMessageBox.showinfo(reverse("בדיקת גרסה עדכנית לתוכנת כוכבים וזמנים"), reverse(f"הגרסה שברשותך עדכנית"))
            else:
                tkMessageBox.showinfo("Checking the latest version of the cochavim uzmanim software", f"The version you have is up to date")
                            
    # במקרה שיש שגיאה בגלל בעית חיבור לרשת או כל בעיה אחרת, אם מדובר בבדיקה שהמשתמש יזם יש להוציא הודעה מפורטת
    except Exception as e:
        if manual:
            if is_heb_locale:
                tkMessageBox.showerror(reverse("בדיקת גרסה עדכנית לתוכנת כוכבים וזמנים"), reverse(f"לא ניתן לבדוק האם התוכנה עדכנית\nראו פרטים להלן\n\n{str(e)}"))
            else:
                tkMessageBox.showerror("Checking the latest version of the cochavim uzmanim software", f"It is not possible to check whether the software is up-to-date\nsee details below\n\n{str(e)}")


# פונקצייה להתקנה קבועה של תוכנת כוכבים וזמנים
def install_cu():
    
    # בדיקה מה מערכת ההפעלה של המשתמש
    system = platform.system().lower()

    # פונקצייה ליצירת קיצור דרך על שולחן העבודה ותפריט התחל-תוכניות
    # הפונקצייה מקבלת שלושה ארגומנטים: 1. נתיב מלא לקובץ שרוצים לעשות לו קיצור דרך. 2. השם שבו ייקרא קיצור הדרך. 3. המקום שבו ישימו את קיצור הדרך וברירת המחדל היא בשולחן העבודה
    # נבנתה בעזרת צ'אט-גיפיטי  
    def create_shortcut(target_path, shortcut_name="shortcut", is_heb_locale=True):
        
        # ---------- פונקציה פנימית ליצירת קיצור דרך ב-Windows ----------
        def create_windows_shortcuts(destination_folder):
            shortcut_path = os.path.join(destination_folder, f"{shortcut_name}.lnk")
            # אם הקיצור קיים, מוחק קודם
            if os.path.exists(shortcut_path):
                os.remove(shortcut_path)
            shell = Dispatch('WScript.Shell')
            shortcut = shell.CreateShortCut(shortcut_path)
            shortcut.TargetPath = target_path
            shortcut.save()
            
        # ---------- פונקציה פנימית ליצירת קיצור דרך ב-Linux ----------
        def create_linux_desktop_entry(destination_folder):
            shortcut_path = Path(destination_folder) / f"{shortcut_name}.desktop"
            # אם הקיצור קיים, מוחק קודם
            if shortcut_path.exists():
                shortcut_path.unlink()
            content = f"""[Desktop Entry]
    Name={shortcut_name}
    Exec={target_path}
    Type=Application
    Terminal=false
    Icon={target_path}
    """
            with open(shortcut_path, "w") as f:
                f.write(content)
            os.chmod(shortcut_path, 0o755)


        # טקסטים בהתאם לשפה
        txt_desktop_question = reverse("האם ברצונך ליצור קיצור דרך לשולחן העבודה?") if is_heb_locale else "Do you want to create a desktop shortcut?"
        txt_start_question = reverse("האם ברצונך ליצור גם קיצור דרך בתפריט התחל?") if is_heb_locale else "Do you also want to add a Start Menu shortcut?"
        txt_success_desktop = reverse("קיצור דרך בשולחן העבודה נוצר בהצלחה") if is_heb_locale else "Desktop shortcut created successfully"
        txt_success_start = reverse("קיצור דרך בתפריט התחל נוצר בהצלחה") if is_heb_locale else "Start Menu shortcut created successfully"
        txt_error = reverse("יצירת קיצור דרך נכשלה בגלל:\n") if is_heb_locale else "Creating shortcut failed because:\n"
        txt_error_os = reverse("מערכת ההפעלה אינה נתמכת ליצירת קיצור דרך") if is_heb_locale else "Operating system not supported for shortcut creation"
        
        # ---------- WINDOWS ----------
        if system == "windows":
            
            # שולחן עבודה
            desktop_dir = os.path.join(os.environ['USERPROFILE'], 'Desktop')
            if tkMessageBox.askyesno("Shortcut Creation", txt_desktop_question):
                try:
                    create_windows_shortcuts(desktop_dir)
                    tkMessageBox.showinfo("Success", txt_success_desktop)
                except Exception as e:
                    tkMessageBox.showerror("create_shortcut_desktop_Error", f"{txt_error}{e}")

            # תפריט התחל
            if tkMessageBox.askyesno("Shortcut Creation", txt_start_question):
                try:
                    start_menu_dir = os.path.join(os.environ['APPDATA'], r'Microsoft\Windows\Start Menu\Programs')
                    create_windows_shortcuts(start_menu_dir)
                    tkMessageBox.showinfo("Success", txt_success_start)
                except Exception as e:
                    tkMessageBox.showerror("create_shortcut_start_menu_Error", f"{txt_error}{e}")
        
        # ---------- LINUX ----------
        elif system == "linux":
            desktop_dir = Path.home() / "Desktop"
            if tkMessageBox.askyesno("Shortcut Creation", txt_desktop_question):
                try:
                    create_linux_desktop_entry(desktop_dir)
                    tkMessageBox.showinfo("Success", txt_success_desktop)
                except Exception as e:
                    tkMessageBox.showerror("Error", f"{txt_error}{e}")

        # ---------- מערכות לא נתמכות ----------
        else:
            tkMessageBox.showerror("Error", txt_error_os)
 
    
    #-----------------------------------
    # מכאן והלאה הפונקצייה הראשית של התקנת התוכנה
    
    # הגדרת כותרת לחלונית הודעה
    title_for_installation_message = reverse("התקנת תוכנת כוכבים וזמנים") if is_heb_locale else "Installing cochavim uzmanim software"
     
    # הצהרה על משתנה גלובלי שמחזיק את המיקום של תיקיית התוכנה
    global cu_dir_path
    
    # הגדרת שם הקובץ של קובץ ההתקנה לפי מערכות ההפעלה
    cochavim_uzmanim_plus_dir_filename = "cochavim_uzmanim_plus_dir.exe" if is_windows else "cochavim_uzmanim_plus_dir"
    
    # הגדרת הנתיב המוחלט שבתיקייה הזמנית שבה נמצא קובץ הפעלה של תוכנת כוכבים וזמנים כאשר היא פועלת מתיקייה
    cu_dir_exe_path = resource_path(cochavim_uzmanim_plus_dir_filename)
    
    # אם אין קובץ הפעלה מתאים יש להוציא הודעה ולהפסיק את הפעולה
    if not os.path.exists(cu_dir_exe_path):
        tkMessageBox.showinfo(title_for_installation_message, reverse(f"אין קובץ מתאים להתקנה") if is_heb_locale else f"There is no suitable file to install")
        return
    
    # קבלת נתיב מלא של התיקייה הזמנית שממנה פועלת כעת התוכנה
    absolute_temp_path = os.path.abspath(os.path.dirname(cu_dir_exe_path))
          
    try:        
        # נתיב התיקייה שבה נשמרים קבצי ההתקנה
        installation_dir = os.path.join(cu_dir_path, "cu_installation")
        
        # אם יש כבר תיקייה בשם של תיקיית היעד יש למחוק אותה כי אחרת אי אפשר להעתיק תחת שם זה
        # זה טוב לי כי אז כל התיקייה תעודכן
        if os.path.exists(installation_dir):
            if is_heb_locale:
                msg_box = tkinter.messagebox.askquestion(reverse('אישור התקנה מחדש'),reverse('\nהתוכנה כבר מותקנת\nהאם אתה בטוח שברצונך להתקין מחדש?\nאין לכבות את התוכנה עד לקבלת אישור התקנה'),icon='warning',default="no")
            else: 
                msg_box = tkinter.messagebox.askquestion('reinstall confirmation','\nThe software is already installed\nAre you sure you want to reinstall?\nDo not turn off the software until you receive installation confirmation',icon='warning',default="no")
            # אם המשתמש ענה שהוא רוצה להתקין מחדש
            if msg_box == 'yes':
                shutil.rmtree(installation_dir)
            else:
                tkMessageBox.showinfo(title_for_installation_message, reverse(f"ההתקנה בוטלה לפי בחירת המשתמש") if is_heb_locale else f"The installation was canceled by the user's choice")
                return
        
        # אם עדיין לא מותקן כי אין תיקייה כזו
        elif not os.path.exists(installation_dir):
            if is_heb_locale:
                msg_box = tkinter.messagebox.askquestion(reverse('אישור התקנה'),reverse('\nהאם אתה בטוח שברצונך להתקין את התוכנה?\nאין לכבות את התוכנה עד לקבלת אישור התקנה?'),icon='warning',default="no")
            else:
                msg_box = tkinter.messagebox.askquestion('Installation confirmation','\nAre you sure you want to install the software?\nDo not turn off the software until you receive installation confirmation?',icon='warning',default="no")
            # אם המשתמש ענה שהוא לא רוצה להתקין יש לבטל ולצאת מהפונקציהה
            if msg_box == 'no':
                tkMessageBox.showinfo(title_for_installation_message, reverse(f"ההתקנה בוטלה לפי בחירת המשתמש") if is_heb_locale else f"The installation was canceled by the user's choice")
                return

        # העתקת תיקיית כוכבים וזמנים הזמנית שפועלת מתיקיית טמפ למקום קבוע בתוך תיקיית כוכבים וזמנים הקבועה
        # זה בכוונה חייב להיות תחת תיקייה בשם _internal אחרת התוכנה לא תעבוד
        shutil.copytree(absolute_temp_path, os.path.join(installation_dir, "_internal"))
                
        # הוצאת קובץ התוכנה עצמו מתוך תיקיית _internal לתיקייה הראשית cu_installation כי בלי זה התוכנה לא תפעל
        src_path = os.path.join(installation_dir, "_internal", cochavim_uzmanim_plus_dir_filename)
        dst_path = os.path.join(installation_dir, cochavim_uzmanim_plus_dir_filename)
        shutil.copy(src_path, dst_path)
        
        # הנתיב החדש לסקריפט פייתון המקורי של התוכנה למקרה שאני רוצה למחוק אותו כדי שהמשתמש לא יראה את הקוד המלא
        #cu_script_new_path = os.path.join(cu_dir_path, "cu_installation", "_internal", "cochavim_uzmanim_plus.py")
        # מחיקת קובץ סקריפט פייתון המקורי של התוכנה כדי שלא יהיה גלוי למשתמש
        #os.remove(cu_script_new_path)
        
        # הודעה למשתמש
        if is_heb_locale:
            tkMessageBox.showinfo(reverse("התקנת תוכנת כוכבים וזמנים"), reverse(f"התוכנה הותקנה בתיקייה הבאה\n{installation_dir}\nכעת ניצור קיצורי דרך בשולחן העבודה ובתפריט ההתחלה"))
        else:
            tkMessageBox.showinfo("Installing cochavim uzmanim software", f"The software has been installed in the following folder\n{installation_dir}\nNow we will create shortcuts on the desktop and start menu")
            
    # במקרה של שגיאה בהתקנה
    except Exception as e:
        tkMessageBox.showinfo(title_for_installation_message, reverse(f"התקנת התוכנה נכשלה בגלל {e}") if is_heb_locale else f"Software installation failed because {e}")
        return # אם לא הצליח יוצאים מהפונקצייה ולא ממשיכים ליצירת קיצורי דרך
            
    # אם ההתקנה הצליחה יוצרים קיצורי דרך לתוכנה המותקנת
    # הנתיב החדש לקובץ ההפעלה של התוכנה המותקנת
    cu_dir_exe_new_path = os.path.join(cu_dir_path, "cu_installation", cochavim_uzmanim_plus_dir_filename)
    # שם קיצור הדרך
    shortcut_name = "כוכבים וזמנים גרסה מותקנת" if is_heb_locale else "cochavim uzmanim installed version" # בכוונה לא לעשות כאן רוורס לעברית כי זה לקובץ חיצוני
    # קריאה לפונקציית יצירת קיצורי הדרך שהוגדרה לעיל
    create_shortcut(cu_dir_exe_new_path, shortcut_name, is_heb_locale)
  
    
# פונקצייה למחיקת קובץ המיקומים הערוך כדי שייכתב קובץ עדכני בפתיחת התוכנה הבאה
# מיועד לשימוש במקרה של עדכון התוכנה
def delete_edited_locations_file():
    # אם קיים קובץ מיקומים ערוך יש להקפיץ הודעת אישור למחיקת הקובץ ואם יש אישור אז הקובץ נמחק
    if os.path.exists(locations_edited_path):
        if is_heb_locale:
            msg_box = tkinter.messagebox.askquestion(reverse('איפוס קובץ המיקומים'), reverse('אזהרה! פעולה זו אינה ניתנת לביטול\nהאם אתה בטוח שברצונך לאפס את קובץ המיקומים?\nאם כן, התוכנה תיסגר ויש להפעילה מחדש'),icon='warning', default="no")
        else:
            msg_box = tkinter.messagebox.askquestion('Resetting the locations file', 'Warning! This action cannot be undone\nAre you sure you want to reset the locations file?\nIf so, the software will close and must be restarted',icon='warning', default ="no")
        if msg_box == 'yes':
            os.remove(locations_edited_path)
            ws.destroy()

# פונקצייה להוספת מיקום חדש לקובץ המיקומים הערוך דרך התוכנה עצמה              
def add_new_location():
    
    # הצהרה על המשתנה הגלובלי שמחזיק את המידע האם נעשה שימוש בקובץ המיקומים הערוך או המקורי
    global which_locations_file
    
    # כאשר נעשה שימוש בקובץ המיקומים המקורי אין שום משמעות לפונקצייה זו ולכן מדלגים על כולה
    if which_locations_file == "מקורי":
        tkMessageBox.showinfo(reverse("שגיאה"), reverse("לא ניתן לערוך את קובץ המיקומים המקורי. לחץ על 'איפוס קובץ המיקומים' ונסה שוב. אם השגיאה חוזרת לאחר האיפוס - אין אפשרות במחשב זה לערוך שינויים במיקומים"))
        pass
    
    # בכל מקרה אחר
    else:
        # חלון הוספת המיקום    
        loc = Toplevel(ws)
        loc.geometry(f"{round(500*magnification_factor)}x{round(200*magnification_factor)}+{round(70*magnification_factor)}+{round(200*magnification_factor)}")
        loc.title(reverse("כוכבים וזמנים: הוספת מיקום חדש", for_title = True) if is_heb_locale else "Adding a new location")
        # מיקום חלון הוספת מיקום מעל החלון הראשי
        loc.wm_transient(ws)
        # הגדרת צבע לכל החלון
        loc.configure(bg=cu_color)
        text_en="\nEnter data and press the add button\nFor longitude that is *west* of Greenwich or latitude that is *south* of the equator\nput a minus sign before the number"
        Label(loc, text=reverse("\nהזן נתונים ולחץ על כפתור ההוספה\nעבור אורך שהוא *מערבי* מגריניץ' או רוחב שהוא *דרומי* מקו המשווה - סמן מינוס לפני המספר \nאם הגובה אינו ידוע לך - השאר ריק\n") if is_heb_locale else text_en).grid(column=0, row=0, columnspan=5)
        # הגדרת משתנים עבור השדות הנדרשים למלא והגדרת השדות הנדרשים עצמם
        new_name = StringVar(loc)
        new_lon = StringVar(loc)
        new_lat = StringVar(loc)
        new_elev = StringVar(loc)
        Entry(loc, textvariable=new_name, width=13, justify='center',state="normal").grid(column=3, row=1)
        Label(loc, text =reverse("שם המקום (לפחות אות אחת)") if is_heb_locale else "Location name (at least 1 letter)").grid(column=3, row=2)
        Entry(loc, textvariable=new_lat, width=9,state="normal").grid(column=2, row=1)
        Label(loc, text =reverse("קו רוחב (עֶשׂרוֹנִי)") if is_heb_locale else "latitude (decimal)").grid(column=2, row=2)
        Entry(loc, textvariable=new_lon, width=9,state="normal").grid(column=1, row=1)
        Label(loc, text =reverse("קו אורך (עֶשׂרוֹנִי)") if is_heb_locale else "longitude (decimal)").grid(column=1, row=2)
        Entry(loc, textvariable=new_elev, width=9,state="normal").grid(column=0, row=1)
        Label(loc, text =reverse("גובה (במטרים)") if is_heb_locale else "Elevation (Meters)").grid(column=0, row=2)
        Label(loc, text ="                                     ").grid(column=0, row=3)

        # הגדרת פונקציית משנה לצורך בדיקת ואימות הנתונים שהוזנו במיקום הידני ושמירתם אם הם תקינים
        def save_location():
            # קליטת הערכים שבשדות
            name = new_name.get()
            latit = new_lat.get()
            long = new_lon.get()
            elev = new_elev.get()

            # ניסיון להמרת הערכים שבשדות לסוג הסופי שבו הם צריכים להיות בקובץ המיקומים
            try:
                # אם אין שום דבר בשדה שם המקום אז המשתנה יהיה שווה אפס
                name = str(name) if name else 0
                latit = float(latit)
                long = float(long)
                # אם אין בשדה הגובה כלום - אז הגובה שווה אפס עשרוני
                elev = float(elev) if elev else 0.0
                
            # אם יש בעיה, להודיע למשתמש
            except ValueError:
                if is_heb_locale:
                    tkMessageBox.showinfo(reverse("שגיאה בניסיון הוספת מיקום"), reverse("יש בעיה באחד או יותר מהנתונים שהזנת - נסה שנית"))
                else:
                    tkMessageBox.showinfo("Error trying to add a location", "There is a problem with one or more of the data you entered - try again")

            # רק אם יש מידע טקסטואלי במשתנה שם המקום, וגם שאר הערכים בשדות האחרים הם מספר עשרוני
            if name != 0 and type(name) == str and not str(name).isdigit() and type(latit) == float and type(long) == float and type(elev) == float:

                new_location = [name+"#", latit, long, elev, "", "no English name"] if is_heb_locale else [reverse("אין שם בעברית"), latit, long, elev, "", name+"#"]
                
                # שמירת המיקום החדש לקובץ המיקומים הערוך באמצעות פונקצייה שהגדרתי למעלה המטפלת בעריכת קובץ המיקומים
                edit_locations_file(location = new_location)

        # הצבת לחצן שישמור את המיקום החדש באמצעות הפונקצצייה שלעיל 
        Button(loc, text =reverse("הוסף לקובץ המיקומים") if is_heb_locale else "Add to locations file", borderwidth=5, command = save_location).grid(column=0, row=4, columnspan=5)
        Label(loc, text ="").grid(column=2, row=5)



# פונקצייה לפתיחת התוכנות הנלוות
def open_subprocess():
    
    # הצהרה על משתנה גלובלי שמחזיק את המידע האם יש תהליך משני פתוח
    # הערה, בכל תהליך מישני הגדרי שאם הוא נסגר הערך של משתנה גלובלי זה יורק באחד
    # כאן בפונקצייה מוגדר שאם תהליך נפתח המשתנה עולה באחד
    global subprocess_patuach        
    
    # ראשית כל עצירת החישובים הרציפים של התוכנה הראשית כדי לא להכביד על המערכת
    if choice_time.get() == "עכשיו מתעדכן":
        choice_time.set("עכשיו (לפי המחשב)")
    
    # הגבלה שרק שלוש תתי הליכים יוכלו להיות פתוחים במקביל
    if subprocess_patuach < 3:
    
        # פתיחת הפונקצייה המתאימה
        if choice_subprocess.get() == "yom_huledet":
            yom_huledet()
            subprocess_patuach += 1
        elif choice_subprocess.get() == "date_converter":
            date_converter()
            subprocess_patuach += 1
        elif choice_subprocess.get() == "heb_year_information":
            heb_year_information()
            subprocess_patuach += 1
    else:
        tkMessageBox.showinfo(reverse("שגיאה"), reverse("כרגע יש שלוש חלונות פעילים שנפתחו מתוך התוכנה\nסגור אחד מהם ונסה שנית"))

# פונקצייה נורא חשובה שעושה ריסטרט לכל התוכנה
def restart_app():
    if is_heb_locale:
        msg_box = tkinter.messagebox.askquestion(reverse("הפעלה מחדש"),reverse('\nהאם ברצונך שהתוכנה תופעל מחדש?'),icon='warning', default="no")
    else:
        msg_box = tkinter.messagebox.askquestion('restart app','\nAre you sure to restart app?',icon='warning', default="no")
    if msg_box == 'yes':
        app = sys.executable
        os.execl(app, app, *sys.argv)
        

# פונקצייה לקבלת המיקומים וכל המידע עליהם
def get_locations(locations_path,locations_edited_path,cu_dir_path):
    
    # טעינת קובץ המיקומים מתוך המיקום המוחלט
    with open(locations_path, 'r', encoding=cu_encod) as myFile:
        reader = csv.reader(myFile)
        # סילוק השורה הראשונה
        #next(reader)## כבר אין צורך כי זה מבוצע אחר כך
        locations_data = list(reader)
        # הסרת שורות ריקות מהמערך שהתקבל מקובץ המיקומים
        locations_data = [i for i in locations_data if i]
        
    # הגדרת מערך ריק עבור המיקומים עצמם
    locations = []

    # טיפול בכל מיקום ומיקום שבקובץ הנתונים בלי לחשב את השורה הראשונה שהיא רק המפתח מה יש בכל עמודה
    for i in range(len(locations_data))[1:]:
     
        # הגדרת אורך רוחב גובה איזור זמן ושם של המיקום
        location_name_heb = locations_data[i][0]
        location_lat = float(locations_data[i][1])
        location_lon = float(locations_data[i][2])
        location_elevation = float(locations_data[i][3]) if locations_data[i][3] != "" else 0.0
        location_name_en = locations_data[i][-1] # תמיד במיקום האחרון. טוב גם לקבצים ישנים שהשם באנגלית היה בטור 5 כי בטור 4 היה איזור זמן
        
        # הכנסת כל המיקומים לתוך מערך המיקומים    
        locations.append({"skyfield_location": wgs84.latlon(location_lat, location_lon, location_elevation), "location_name_heb": location_name_heb, "location_name_en": location_name_en})
    
    # במקרה שאין קובץ מיקומים ערוך בתיקיית אפפ-דאטא, צריך לשים שם קובץ זה כדי שהמשתמש יוכל לערוך אותו
    if not os.path.exists(locations_edited_path):
        # כתיבת הנתונים המתוקנים לתוך קובץ חדש שיאוכסן בתיקיייה של התוכנה באפפ-דאטה ובפעם הבאה שיפתחו את התוכנה המיקומים ייקראו מהמיקום החדש
        with open(locations_edited_path, 'w', encoding=cu_encod, newline='') as newFile:
            myWriter = csv.writer(newFile)
            myWriter.writerows(locations_data)
           
    return locations


# פונקצייה לקבלת מערך כוכבי השבת
def get_stars(stars_path,cu_dir_path):
    
    # טעינת קובץ הכוכבים מתוך המיקום המוחלט
    with open(stars_path, 'r', encoding=cu_encod) as myFile:
        reader = csv.reader(myFile)
        # סילוק השורה הראשונה
        #next(reader)## כבר אין צורך כי זה מבוצע אחר כך
        stars_data = list(reader)
        # הסרת שורות ריקות מהמערך שהתקבל מקובץ הכוכבים
        stars_data = [i for i in stars_data if i]
        
    '''    
    # לא יודע למה זה לא פועל טוב
    # שמירת משתנה ובו שורת כותרות הטורים
    A = stars_data[0]
    # מיון של כל שאר השורות חוץ מהשורה הראשונה לפי עמודת הבהירות מהקטן לגדול
    stars_data = sorted(stars_data[1:], key=lambda row: row[1]) #,reverse=True / key=operator.itemgetter(0)
    # הוספת כותרות הטורים לראש רשימת המיקומים העדכנית
    stars_data.insert(0,A)
    '''

    # הגדרת מערך ריק עבור הכוכבים עצמם
    stars = []

    # טיפול בכל מיקום ומיקום שבקובץ הכוכבים בלי לחשב את השורה הראשונה שהיא רק המפתח מה יש בכל עמודה
    for i in range(len(stars_data))[1:]:
     
        # הגדרת כמה משתנים נפרדים עבור העמודות השונות שבקובץ הכוכבים
        name_he = stars_data[i][0]
        name_en = stars_data[i][8]
        
        # אם יש רק מספר במקום שבו צריך להיות שם, יש להוסיף אות אלף אחרי המספר כדי שלא יהיה שיבוש בהצגת העברית
        if str(name_he).isdigit():
            name_he = name_he+"א"
            
        magnitude = float(stars_data[i][1])
        ra_hours = float(stars_data[i][2])
        dec_degrees = float(stars_data[i][3])
        epoch_year = float(stars_data[i][4]) if stars_data[i][5] != "" else 2000.25
        parallax_mas = float(stars_data[i][5]) if stars_data[i][5] != "" else 0.0
        ra_mas_per_year = float(stars_data[i][6]) if stars_data[i][6] != "" else 0.0
        dec_mas_per_year = float(stars_data[i][7]) if stars_data[i][7] != "" else 0.0
        
        # הכנסת כל הכוכבים לתוך מערך הכוכבים כולל מגניטודה    
        stars.append({"name_en": name_en, "name_he": name_he, "magnitude": magnitude, "skyfield Star": Star(names=name_en,ra_hours=ra_hours,dec_degrees=dec_degrees,epoch=epoch_year,parallax_mas=parallax_mas,ra_mas_per_year=ra_mas_per_year,dec_mas_per_year=dec_mas_per_year)})
        
    return stars


# פונקצייה להגדרת תאריך ושעה באיזור האינפוט העליון עבור פונקציית סט מניובוטונס טיימס
def set_date_time(time):
    hours.set(f'{time.hour :02.0f}')
    minutes.set(f'{time.minute :02.0f}')
    seconds.set(f'{time.second :02.0f}')
    microseconds.set(f'{time.microsecond :2.0f}')
    greg_year.set(f'{time.year :02.0f}')
    greg_month.set(f'{time.month :02.0f}')
    greg_day.set(f'{time.day :02.0f}')
    
    # רק אם לא מוגדר על עכשיו מתעדכן, יש לקרוא לפונקציית כל החישובים כדי שתחשב הכל על הזמן החדש שהוגדר בשעון העליון
    # אם מוגדר על עכשיו מתעדכן אסור לקרוא לפונקציית כל החישובים כי היא כבר פועלת רציף
    if choice_time.get() != "עכשיו מתעדכן":
        all_calculations()




# פונקצייה להגדרת לזמנים שונים שהמשתמש בוחר בתפריט הבחירה
# לאחר הגדרת הזמן, השעון העליון נקרא לכיוון באמצעות set_date_time
def set_menubuttons_times():
    
    # אם כפתור הפעלת החישובים לא פעיל, יש לצאת מייד מהפונקצייה
    if C1.get() != 1:
        return   
    
    # קבלת שעה מקום ואיזור הזמן מהמשתמש
    time,location,location_timezone=time_location_timezone()

    # אם מוגדר על עכשיו מתעדכן יש לקרוא פעם אחת לפונקציית כל החישובים ואז היא חוזרת על עצמה
    # רק במקרה זה אין מה לקרוא לכיוון השעון העליון
    # אסור לקרוא לפונקציית כל החישובים כאשר היא כבר פועלת על חישובים חוזרים ומתמשכים. לכן יש מתג שמודיע האם החישובים כבר רצים במתמשך
    # לכן תמיד צריך כאן בדיקות באיף ולא באליף שמטרתן להגדיר את הכפתור הזה 
    # אם מפעילים את פונקציית כל החישובים במצב מתמשך מפעילים קודם כל את המתג שאומר שהיא פועלת בחישוב רציף
    global is_all_calculations_running
    if choice_time.get() == "עכשיו מתעדכן" and not is_all_calculations_running:
        is_all_calculations_running = True
        all_calculations() 
    # כיבוי המתג במקרה שלא מדובר בחישוב רציף
    if choice_time.get() != "עכשיו מתעדכן":
        is_all_calculations_running = False

    # חישובים שלא תלויים בזריחה ושקיעה
    if choice_time.get() == "עכשיו (לפי המחשב)":
        #set_date_time(skyfield_to_cu_time(ts.now(), location_timezone))
        set_date_time(datetime.now().astimezone(location_timezone))
    elif choice_time.get() == "מולד ירח אמיתי הבא":
        hitkabzut,nigud = hitkabzut_nigud_calculations(time,location,location_timezone,body="moon",PLUS_MINUS ="PLUS",plus_minus_days=50)
        set_date_time(hitkabzut)
    elif choice_time.get() == "ניגוד ירח אמיתי הבא":
        hitkabzut,nigud = hitkabzut_nigud_calculations(time,location,location_timezone,body="moon",PLUS_MINUS ="PLUS",plus_minus_days=50)
        set_date_time(nigud) # +timedelta(seconds=1) כי זה יוצא שנייה קודם
    elif choice_time.get() == "מולד ירח אמיתי קודם":
        hitkabzut,nigud = hitkabzut_nigud_calculations(time,location,location_timezone,body="moon",PLUS_MINUS ="MINUS",plus_minus_days=50)
        set_date_time(hitkabzut)
    elif choice_time.get() == "ניגוד ירח אמיתי קודם":
        hitkabzut,nigud = hitkabzut_nigud_calculations(time,location,location_timezone,body="moon",PLUS_MINUS ="MINUS",plus_minus_days=50)
        set_date_time(nigud) # +timedelta(seconds=1) כי זה יוצא שנייה קודם
    elif choice_time.get() == "שיוויון האביב הבא":
        Vernal_Equinox,Summer_Solstice,Autumnal_Equinox,Winter_Solstice=Real_tkufot(time,location,location_timezone,PLUS_MINUS="PLUS",plus_minus_days=400)
        set_date_time(Vernal_Equinox)
    elif choice_time.get() == "שיוויון הסתיו הבא":
        Vernal_Equinox,Summer_Solstice,Autumnal_Equinox,Winter_Solstice=Real_tkufot(time,location,location_timezone,PLUS_MINUS="PLUS",plus_minus_days=400)
        set_date_time(Autumnal_Equinox)
    elif choice_time.get() == "היפוך הקיץ הבא":
        Vernal_Equinox,Summer_Solstice,Autumnal_Equinox,Winter_Solstice=Real_tkufot(time,location,location_timezone,PLUS_MINUS="PLUS",plus_minus_days=400)
        set_date_time(Summer_Solstice)
    elif choice_time.get() == "היפוך החורף הבא":
        Vernal_Equinox,Summer_Solstice,Autumnal_Equinox,Winter_Solstice=Real_tkufot(time,location,location_timezone,PLUS_MINUS="PLUS",plus_minus_days=400)
        set_date_time(Winter_Solstice)
    elif choice_time.get() == "נוגה בהתארכות הבאה":
        # הגדלת הזמן הראשוני בדקה אחת כדי שהחיפוש לא ייתקל שוב ושוב באירוע שקיים בזמן הנוכחי שתמיד יישאר האירוע הראשון ברשימה
        # כנראה שהסיבה לבאג הזה היא שפונקציית החישוב הבאה משתמשת בחיפוש אירוע מותאם אישית בסקייפילד
        time = time + timedelta(minutes=1)
        venus_greatest_elongation = calculate_venus_greatest_elongation(time,location,location_timezone,body="venus",PLUS_MINUS="PLUS",plus_minus_years=5)
        set_date_time(venus_greatest_elongation)
    elif choice_time.get() == "נוגה בהתקבצות הבאה":
        hitkabzut,nigud = hitkabzut_nigud_calculations(time,location,location_timezone,body="venus",PLUS_MINUS ="PLUS",plus_minus_days=600)
        set_date_time(nigud) if nigud < hitkabzut else set_date_time(hitkabzut)
    elif choice_time.get() == "ליקוי חמה הבא הנראה במיקום זה":
        # הגדלת הזמן הראשוני בדקה אחת כדי שהחיפוש לא ייתקל שוב ושוב באירוע שקיים בזמן הנוכחי שתמיד יישאר האירוע הראשון ברשימה
        # כנראה שהסיבה לבאג הזה היא שפונקציית החישוב הבאה משתמשת בחיפוש אירוע מותאם אישית בסקייפילד
        time = time + timedelta(minutes=1)
        solar_eclipse = eclipse_calculations(time,location,location_timezone,body="sun",PLUS_MINUS="PLUS",plus_minus_years=30)
        set_date_time(solar_eclipse)    
    elif choice_time.get() == "ליקוי ירח הבא הנראה במיקום זה":
        # הגדלת הזמן הראשוני בדקה אחת כדי שהחיפוש לא ייתקל שוב ושוב באירוע שקיים בזמן הנוכחי שתמיד יישאר האירוע הראשון ברשימה
        # כנראה שהסיבה לבאג הזה היא שפונקציית החישוב הבאה משתמשת בחיפוש אירוע מותאם אישית בסקייפילד
        # ליקוי ירח הנראה במיקום מסויים קורה בתדירות הרבה יותר גבוהה מליקוי חמה הנראה במיקום מסויים זה לכן החיפוש הוא 10 שנים קדימה ולא יותר
        time = time + timedelta(minutes=1)
        moon_eclipse = eclipse_calculations(time,location,location_timezone,body="moon",PLUS_MINUS="PLUS",plus_minus_years=10)
        set_date_time(moon_eclipse)
    elif choice_time.get() == "דילוג זמן לפי בחירת המשתמש":
        time_skip(time)
    #elif choice_time.get() == "פלוס 16.875 דקות":
    #     set_date_time(time+timedelta(minutes=16.875))  
    
    # החלק העליון של התוכנה פועל תמיד, אבל החלק שתלוי בחישובי זריחה ושקיעה לא פועל במקום שאין בו זריחה ושקיעה בכל יום כגון באיזור הקוטב הצפוני
    # לכן צריך לנסות, ואם לא מצליחים לחשב שקיעות אז לא לחשב שעות זמניות
    try:
        if choice_time.get() == "עלות השחר -19.75":
            SR,SS,_,_,_,_ = calculate_rising_seting(time,location,location_timezone,horizon=-19.75, body="sun")
            set_date_time(SR)
        elif choice_time.get() == "תחילת דמדומים -18":
            SR,SS,_,_,_,_ = calculate_rising_seting(time,location,location_timezone,horizon=-18, body="sun")
            set_date_time(SR)
        elif choice_time.get() == "עלות השחר -16":
            SR,SS,_,_,_,_ = calculate_rising_seting(time,location,location_timezone,horizon=-16, body="sun")
            set_date_time(SR)
        elif choice_time.get() == "עלות השחר -14":
            SR,SS,_,_,_,_ = calculate_rising_seting(time,location,location_timezone,horizon=-14, body="sun")
            set_date_time(SR)
        elif choice_time.get() == "תחילת דמדומים -12":
            SR,SS,_,_,_,_ = calculate_rising_seting(time,location,location_timezone,horizon=-12, body="sun")
            set_date_time(SR)
        elif choice_time.get() == "משיכיר -10.5":
            SR,SS,_,_,_,_ = calculate_rising_seting(time,location,location_timezone,horizon=-10.5, body="sun")
            set_date_time(SR)
        elif choice_time.get() == "תחילת דמדומים -6":
            SR,SS,_,_,_,_ = calculate_rising_seting(time,location,location_timezone,horizon=-6, body="sun")
            set_date_time(SR)
        elif choice_time.get() == "הנץ בגובה - כשאין הסתרות":
            Z = calculate_elevation_rise_set(location.elevation.m)
            SR,SS,_,_,_,_ = calculate_rising_seting(time,location,location_timezone,horizon=Z, body="sun")
            set_date_time(SR)
        elif choice_time.get() == "הנץ 0":
            SR,SS,_,_,_,_ = calculate_rising_seting(time,location,location_timezone,horizon=0, body="sun")
            set_date_time(SR)
        elif choice_time.get() == "הנץ -0.833":
            SR,SS,_,_,_,_ = calculate_rising_seting(time,location,location_timezone,horizon=-0.833, body="sun")
            set_date_time(SR)
        elif choice_time.get() == 'סוף זמן שמע מג"א -16':
            SR,SS,_,_,_,_ = calculate_rising_seting(time,location,location_timezone,horizon=-16, body="sun")
            set_date_time((SR) + (((SS - SR) / 12) *3))    
        elif choice_time.get() == 'סוף זמן שמע גר"א':
            SR,SS,_,_,_,_ = calculate_rising_seting(time,location,location_timezone,horizon=-0.833, body="sun")
            set_date_time((SR) + (((SS - SR) / 12) *3))
        elif choice_time.get() == 'סוף זמן תפילה מג"א -16':
            SR,SS,_,_,_,_ = calculate_rising_seting(time,location,location_timezone,horizon=-16, body="sun")
            set_date_time((SR) + (((SS - SR) / 12) *4))    
        elif choice_time.get() == 'סוף זמן תפילה גר"א':
            SR,SS,_,_,_,_ = calculate_rising_seting(time,location,location_timezone,horizon=-0.833, body="sun")
            set_date_time((SR) + (((SS - SR) / 12) *4))
        elif choice_time.get() == "חצות היום":
            day_transit, _, _, _ = calculate_transits_and_equation_of_time(time,location,location_timezone)
            set_date_time(day_transit)
        elif choice_time.get() == "מנחה גדולה":
            SR,SS,_,_,_,_ = calculate_rising_seting(time,location,location_timezone,horizon=-0.833, body="sun")
            set_date_time((SR) + (((SS - SR) / 12) *6.5))
        elif choice_time.get() == "מנחה קטנה":
            SR,SS,_,_,_,_ = calculate_rising_seting(time,location,location_timezone,horizon=-0.833, body="sun")
            set_date_time((SR) + (((SS - SR) / 12) *9.5))
        elif choice_time.get() == "פלג המנחה":
            SR,SS,_,_,_,_ = calculate_rising_seting(time,location,location_timezone,horizon=-0.833, body="sun")
            set_date_time((SR) + (((SS - SR) / 12) *10.75))  
        elif choice_time.get() == "שקיעה 0":
            SR,SS,_,_,_,_ = calculate_rising_seting(time,location,location_timezone,horizon=0, body="sun")
            set_date_time(SS)
        elif choice_time.get() == "שקיעה -0.833":
            SR,SS,_,_,_,_ = calculate_rising_seting(time,location,location_timezone,horizon=-0.833, body="sun")
            set_date_time(SS)
        elif choice_time.get() == "שקיעה בגובה - כשאין הסתרות":
            Z = calculate_elevation_rise_set(location.elevation.m)
            SR,SS,_,_,_,_ = calculate_rising_seting(time,location,location_timezone,horizon=Z, body="sun")
            set_date_time(SS)
        elif choice_time.get() == "צאת הכוכבים -3.65":
            SR,SS,_,_,_,_ = calculate_rising_seting(time,location,location_timezone,horizon=-3.65, body="sun")
            set_date_time(SS)
        elif choice_time.get() == "צאת הכוכבים -4":
            SR,SS,_,_,_,_ = calculate_rising_seting(time,location,location_timezone,horizon=-4, body="sun")
            set_date_time(SS)
        elif choice_time.get() == "צאת הכוכבים -4.61":
            SR,SS,_,_,_,_ = calculate_rising_seting(time,location,location_timezone,horizon=-4.61, body="sun")
            set_date_time(SS)
        elif choice_time.get() == "סוף דמדומים -6":
            SR,SS,_,_,_,_ = calculate_rising_seting(time,location,location_timezone,horizon=-6, body="sun")
            set_date_time(SS)
        elif choice_time.get() == "צאת שבת לוחות -8.5":
            SR,SS,_,_,_,_ = calculate_rising_seting(time,location,location_timezone,horizon=-8.5, body="sun")
            set_date_time(SS)
        elif choice_time.get() == "סוף דמדומים -12":
            SR,SS,_,_,_,_ = calculate_rising_seting(time,location,location_timezone,horizon=-12, body="sun")
            set_date_time(SS)
        elif choice_time.get() == 'צאת הכוכבים דר"ת -16':
            SR,SS,_,_,_,_ = calculate_rising_seting(time,location,location_timezone,horizon=-16, body="sun")
            set_date_time(SS)
        elif choice_time.get() == "סוף דמדומים -18":
            SR,SS,_,_,_,_ = calculate_rising_seting(time,location,location_timezone,horizon=-18, body="sun")
            set_date_time(SS)
        elif choice_time.get() == 'צאת הכוכבים דר"ת -19.75':
            SR,SS,_,_,_,_ = calculate_rising_seting(time,location,location_timezone,horizon=-19.75, body="sun")
            set_date_time(SS)
        elif choice_time.get() == "זריחת הירח הבאה":
            MR,MS,_,_,_,_ = calculate_rising_seting(time,location,location_timezone,horizon=0, body="moon",PLUS_MINUS = "PLUS")
            set_date_time(MR)
        elif choice_time.get() == "שקיעת הירח הבאה":
            MR,MS,_,_,_,_ = calculate_rising_seting(time,location,location_timezone,horizon=0, body="moon",PLUS_MINUS = "PLUS")
            set_date_time(MS)
        elif choice_time.get() == "זריחת הירח הקודמת":
            MR,MS,_,_,_,_ = calculate_rising_seting(time,location,location_timezone,horizon=0, body="moon",PLUS_MINUS = "MINUS")
            set_date_time(MR)
        elif choice_time.get() == "שקיעת הירח הקודמת":
            MR,MS,_,_,_,_ = calculate_rising_seting(time,location,location_timezone,horizon=0, body="moon",PLUS_MINUS = "MINUS")
            set_date_time(MS)

    # במקרה שיש שגיאה בחישוב הזריחות והשקיעות
    except IndexError:
        tkMessageBox.showinfo("שגיאה", "עבור המיקום הנוכחי בתאריך הנוכחי, התוכנה אינה יכולה לחשב את זמני זריחות/שקיעות/חצות ")


############################################################################################
                            # שעון ההלכה למחשב
############################################################################################


hw_version = f"{cu_version_date:%d/%m/%Y}"

# מונה לדעת מתי ללחוץ לחיצה ווירטואלית על שיפט כדי למנוע כיבוי מסך
counter_shift = 0.0

#  ההסברים מורכבים משני חלקים כל אחד: הסבר וערך. ההסבר עובר בסוף רוורס ולכן אם יש בו מספרים חייבים לעשות להם רוורס כאן כדי שהרוורס הסופי יישר אותם 
hesberim = [
        
        ["ליציאה לחצו במקלדת על",f"Esc"],
        ["שעון ההלכה גרסה",f"{hw_version}"],
        [" מאת: שמחה גרשון בורר - כוכבים וזמנים",""],
        [reverse("sgbmzm@gmail.com"), ""],
        ["כל הזכויות שמורות - להלן הסברים", ""],
        
        [" התאריך העברי מתחלף בשקיעה (גרא)", ""],
        
        [" מתחת גרא/מגא:  דקות בשעה זמנית", ""],
        [" מתחת שמש/ירח:  אזימוט שמש/ירח", ""],
        ["אזימוט = מעלות מהצפון, וכדלהלן", ""],
        [f"צפון={reverse('0/360')}, מז={reverse('90')}, ד={reverse('180')}, מע={reverse('270')}", ""],
        ["  שלב הירח במסלולו החודשי - באחוזים", ""],
        [f"מולד={reverse('0/100')}, ניגוד={reverse('50')}, רבעים={reverse('25/75')}", ""],
    
        ["רשימת זמני היום בשעות זמניות", ""],
        ["זריחה ושקיעה במישור", "00:00"],
        ["סוף שמע ביום/רבע הלילה", "03:00"],
        ["  סוף תפילה ביום/שליש הלילה", "04:00"],
        ["חצות יום ולילה", "06:00"],
        ["מנחה גדולה", "06:30"],
        ["מנחה קטנה", "09:30"],
        ["פלג המנחה", "10:45"],
        
        ["   זמנים במעלות כשהשמש תחת האופק", ""],
        ["זריחת ושקיעת מרכז השמש", "0.0°"],
        ["  זריחה ושקיעה במישור", "-0.833°"],
        
        [f"זמני צאת הכוכבים {reverse('3/4')} מיל במעלות", ""],
        [f"לפי מיל של {reverse('18')} דקות", "-3.65°"],
        [f"לפי מיל של {reverse('22.5')} דקות", "-4.2°"],
        [f"לפי מיל של {reverse('24')} דקות", "-4.61°"],
        ["צאת כוכבים קטנים רצופים", "-6.3°"],
        
        ["  מעלות: עלות השחר/צאת כוכבים דרת", ""],
        [f"לפי 4 מיל של {reverse('18')} דקות", "-16.02°"],
        [f"לפי 4 מיל של {reverse('22.5')} דקות", "-19.75°"],
        [f"לפי 5 מיל של {reverse('24')} דקות", "-25.8°"],
        ["משיכיר/תחילת ציצית ותפילין", "-10.5°"],
        
        
        ["זמנים נוספים", ""],
        ["להימנע מסעודה בערב שבת", "09:00"],
        ["סוף אכילת חמץ", "04:00"],
        ["סוף שריפת חמץ", "05:00"],

        
        ["להלן תנאי מינימום לראיית ירח ראשונה", ""],
        [f"שלב {reverse('3%')}; והפרש גובה שמש-ירח {reverse('8°')}", ""],
    
    ]  

    

# פונקצייה לפתיחת חלון מידע שעון ההלכה במקום מה שהיה שעון לבתי כנסת       
# הערה: שעון ההלכה למחשב מבצע חישובים עצמאיים אבל מבוססים על פונקציות כלליות של תוכנת כוכבים וזמנים

# משתנים לשליטה בתצוגת השורות המוחלפות
current_screen_hesberim = 0.0 
current_screen_zmanim = 0.0
current_screen_zmanim_with_clocks = 0.0


def halacha_clock():
    
    # אם כפתור הפעלת החישובים לא פעיל, יש לצאת מייד מהפונקצייה
    if C1.get() != 1:
        return
    
    root_hw = Toplevel(ws)
    ##############################################
    # חובה!!!!! לעשות את זה כדי לבטל את הסקאלינג הרגיל של כוכבים וזמנים הכללי שהותאם למסך במקדם הגדלה
    # בשעון ההלכה שמגיע נפרד לא עושים את זה. זה נצרך רק לשעון ההלכה שבתוך תוכנת כוכבים
    root_hw.tk.call('tk', 'scaling', cu_scaling) 
    ##############################################
    root_hw.attributes('-fullscreen', True)
    root_hw.configure(bg='black')
    #root_hw.bind("<Escape>", lambda e: root_hw.destroy())  # יציאה ב-ES
    
    # עושה שלא יראו את העכבר על המסך של שעון ההלכה
    root_hw.config(cursor="none")
     
    # פונקצייה מה לעשות בלחיצה על אסקייפ
    def for_Escape():
        choice_time.set("עכשיו (לפי המחשב)")
        root_hw.destroy()

    # בלחיצה על אסקייפ סגירת החלון וכו
    root_hw.bind("<Escape>", lambda event: for_Escape())
    root_hw.bind("<Button-2>", lambda event: for_Escape()) # כיבוי בלחיצה על לחצן אמצעי בעכבר

    # מעל כל החלונות האחרים
    root_hw.attributes('-topmost',True)
    
    # מסך מלא בלי השמטת שורה עליונה (לא יודע למה, אבל זה עוזר ליציאה בלחיצה על אסקייפ)
    if is_windows:
        root_hw.state('zoomed')
    else:
        root_hw.attributes('-zoomed', True) # מתאים ללינוקס
    
    
    # חובה!!!!!!!!! הפעלת חישוב רציף
    # אם לא עושים את זה זה שמחזיר את הזמן שיש עכשיו בשעון הידני
    is_test = False # True אם רוצים שלא יתעדכן אלא יציג מה שיש בשעון הראשי
    
    if choice_time.get() != "עכשיו מתעדכן" and not is_test:
        choice_time.set("עכשיו מתעדכן")
        # חובה! קריאה לפונקציית כל החישובים כדי שתדע לחזור שוב ושוב על החישובים
        all_calculations()
        
        #### אם רוצים להגדיר בודי1 על הירח צריך לטפל בזה כאן. אם לא אז יוצג הגוף הנבחר כרגע
    
    # קבלת גודל המסך
    #screen_width = root_hw.winfo_screenwidth()
    #screen_height = root_hw.winfo_screenheight()
    # שימוש בזה במקום באפשרות הקודמת כי זה לוקח את גודל המסך האמיתי גם כאשר המסך מוגדל כברירת מחדל של ווינדוס ואם לא כך יש תקלות תצוגה
    # ובתוך כוכבים וזמנים כך צריך לעשות לשעון ההלכה כדי שיהיה מסך מלא גם במחשבים עם מסך בקנה מידה מוגדל כברית מחדל
    # אך בשעון ההלכה כשמגיע לבד לא בתוך כוכבים וזמנים עושים את האפשרות הקודמת
    screen_width = screeninfo.get_monitors()[0].width  
    screen_height = screeninfo.get_monitors()[0].height 


    # פריסת הבסיס שלפיה עיצבתי את המסך
    base_width = 320
    base_height = 170

    # חישוב קנה מידה להגדלה
    scale_x = screen_width / base_width
    scale_y = screen_height / base_height
    scale = min(scale_x, scale_y)
    
    # פונקציה ליצירת גופנים עם קנה מידה
    def scaled_font(name, size, weight="normal"):
        return (name, int(size * scale), weight)

    canvas = tkinter.Canvas(root_hw, width=screen_width, height=screen_height, bg="black", highlightthickness=0)
    canvas.pack()

    # משתנה שמגדיר איזה סוג צבע ירוק יהיה בשימוש לטקסטים שונים בשעון ההלכה
    hw_green = "lime"
    # צבע מגנטה עמום יותר
    hw_dim_magenta = "#AA55AA"
    
    add_labels = settings_dict["halacha_clock_labels"]
    
    # איזור כותרת
    canvas.create_text(160 * scale, 10 * scale, text=reverse("שעון ההלכה                                      כוכבים וזמנים"), fill="turquoise", font=scaled_font("miriam", 10, "bold"))
    city_id = canvas.create_text(160 * scale, 10 * scale, text="", fill=hw_green, font=scaled_font("miriam", 12, "bold"))
    # איזור תאריך עברי
    heb_date_rect_id = canvas.create_rectangle(0, 21 * scale, screen_width, 38 * scale, fill="black")
    heb_date_id = canvas.create_text(160 * scale, 28 * scale, text="", fill="white", font=scaled_font("miriam", 14, "bold"))
    holiday_id = canvas.create_text(160 * scale, 40 * scale, text="", fill=hw_dim_magenta, font=scaled_font("miriam", 8, "bold"))
    canvas.create_line(0, 43 * scale, screen_width, 43 * scale, fill="yellow")

    # איזור שעה זמנית גרא ומגא
    canvas.create_text(300 * scale, 51 * scale, text=reverse("גרא"), fill="white", font=scaled_font("miriam", 13))
    if add_labels:
        canvas.create_text(300 * scale, 77 * scale, text=reverse("דקות לשעה"), fill="turquoise", font=scaled_font("miriam", 4))
    gra_title_id = canvas.create_text(201 * scale, 47 * scale, text=reverse(""), fill="turquoise", font=scaled_font("miriam", 4))
    gra_method_id = canvas.create_text(300 * scale, 60 * scale, text="", fill=hw_dim_magenta, font=scaled_font("miriam", 5))
    minutes_in_gra_temporal_hour_id = canvas.create_text(300 * scale, 70 * scale, text="", fill="turquoise", font=scaled_font("miriam", 10))
    gra_temporal_hour_id = canvas.create_text(208 * scale, (67 if add_labels else 62) * scale, text="", fill=hw_green, font=scaled_font("miriam", 30, "bold"))
    

    canvas.create_text(115 * scale, 51 * scale, text=reverse("מגא"), fill="white", font=scaled_font("miriam", 13))
    if add_labels:
        canvas.create_text(115 * scale, 77 * scale, text=reverse("דקות לשעה"), fill="turquoise", font=scaled_font("miriam", 4))
    mga_title_id = canvas.create_text(50 * scale, 47 * scale, text=reverse(""), fill="turquoise", font=scaled_font("miriam", 4))
    mga_method_id = canvas.create_text(115 * scale, 60 * scale, text="", fill=hw_dim_magenta, font=scaled_font("miriam", 5))
    minutes_in_mga_temporal_hour_id = canvas.create_text(115 * scale, 70 * scale, text="", fill="turquoise", font=scaled_font("miriam", 10))
    mga_temporal_hour_id = canvas.create_text(50 * scale, (65 if add_labels else 60) * scale, text="", fill=hw_green, font=scaled_font("miriam", 20, "bold"))
    canvas.create_line(0, 80 * scale, screen_width, 80 * scale, fill="yellow")

    # איזור מידע על שמש וירח
    canvas.create_text(300 * scale, 90 * scale, text=reverse("שמש"), fill="white", font=scaled_font("miriam", 13))
    sun_az_id = canvas.create_text(300 * scale, 110 * scale, text="", fill="turquoise", font=scaled_font("miriam", 10))
    if add_labels:
        canvas.create_text(200 * scale, 85 * scale, text=reverse("גובה מהאופק:"), fill="turquoise", font=scaled_font("miriam", 4))
        canvas.create_text(300 * scale, 102 * scale, text=reverse("אַזִימוּט:"), fill="turquoise", font=scaled_font("miriam", 4))
    sun_alt_id = canvas.create_text(209 * scale, (105 if add_labels else 101) * scale, text="", fill=hw_green, font=scaled_font("miriam", 30, "bold"))

    moon_name_id = canvas.create_text(115 * scale, 90 * scale, text=reverse("ירח"), fill="white", font=scaled_font("miriam", 13))
    if add_labels:
        canvas.create_text(114 * scale, 102 * scale, text=reverse("אַזִימוּט:"), fill="turquoise", font=scaled_font("miriam", 4))
        canvas.create_text(80 * scale, 112 * scale, text=reverse("מסלול \nחודשי:"), fill="turquoise", font=scaled_font("miriam", 4))
    moon_az_id = canvas.create_text(115 * scale, 110 * scale, text="", fill="turquoise", font=scaled_font("miriam", 10))
    moon_alt_id = canvas.create_text(50 * scale, 94 * scale, text="", fill=hw_green, font=scaled_font("miriam", 20, "bold"))
    moon_phase_id = canvas.create_text(40 * scale, 113 * scale, text="", fill="turquoise", font=scaled_font("miriam", 14, "bold"))
    canvas.create_line(0, 120 * scale, screen_width, 120 * scale, fill="yellow")

    # איזור מתחלף: זמנים בשעון רגיל ושעונים נוספים
    zmanim_with_clocks_id = canvas.create_text(160 * scale, 132 * scale, text="", fill="white", font=scaled_font("miriam", 15))
    canvas.create_line(0, 143 * scale, screen_width, 143 * scale, fill="yellow")

    # איזור שעון רגיל ותאריך לועזי ואיזור הזמן
    utc_offset_id = canvas.create_text(270 * scale, 156 * scale, text="", fill="white", font=scaled_font("miriam", 18))
    time_id = canvas.create_text(180 * scale, 156 * scale, text="", fill=hw_green, font=scaled_font("miriam", 20, "bold"))
    greg_date_id = canvas.create_text(65 * scale, 156 * scale, text="", fill="white", font=scaled_font("miriam", 18))
    canvas.create_line(0, 166 * scale, screen_width, 166 * scale, fill="yellow")
    
    # איזור מתחלף שקיים רק במחשב ולא בשעון ההלכה הפיזי ומיוע להצגת הסברים או אינפורמציה אחרת
    info_id = canvas.create_text(160 * scale, 174 * scale, text="", fill=hw_dim_magenta, font=scaled_font("miriam", 10))
 
    
    
    global current_screen_hesberim, current_screen_zmanim, current_screen_zmanim_with_clocks
    # איפוס ההסברים כדי שבהדלקה מחודשת יתחילו מהתחלה
    current_screen_hesberim = 0.0 
    current_screen_zmanim = 0.0
    current_screen_zmanim_with_clocks = 0.0

    
    #פונקציה לעדכון המסך כל שנייה
    def update_canvas():
        
        global HEB_DATE_FG, HEB_DATE_BG, zmanim_list, hc_greg, hc_holiday # מוגדרים בפונקציית אולל כלכוליישנס
        global hc_sun_alt, hc_sun_az, hc_body_alt, hc_body_az, hc_moon_phase_percent # מוגדרים בפונקציית אסטרו כלכוליישנס
        
        # כותרת
        hc_location_name = city.get()
        
        # שורת תאריך עברי
        hc_heb_date = print_heb_date.get() # מדפיס עם שם היום 
        
        # שעוני שעה זמנית גרא ומגא
        hc_clock_mga = print_temporal_hour_MGA.get()
        hc_minutes_mga = print_minutes_in_temporal_hour_MGA.get()       
        hc_clock_gra = print_temporal_hour_GRA.get()
        hc_minutes_gra = print_minutes_in_temporal_hour_GRA.get()
        
        hc_gra_method = f"({Halachic_method_GRA.get()}°)"
        hc_mga_method = f"({Halachic_method_MGA.get()}°)"
        hc_gra_day = f":{print_day_or_night_GRA.get()}{reverse('שעון שעה זמנית - ')}"
        hc_mga_day = f":{print_day_or_night_MGA.get()}{reverse('שעון שעה זמנית - ')}"
        
        # גובה ואזימוט שמש וירח ואחוז מהמסלול של הירח
        #hc_sun_alt = sun_alt.get()
        #hc_sun_az = sun_az.get()      
        hc_body_name = body1.get() # השם של הגוף. לא תמיד זה הירח
        #hc_body_alt = body1_alt.get() # גובה
        #hc_body_az = body1_az.get() # אזימוט  
        #hc_moon_phase_percent = "0.0 %"# 
        
        # שעונים. צריך לצרף להסברים ולזמנים
        hc_magrab = print_hours_from_last_sunset.get()
        hc_lmt = print_lmt_time.get()
        hc_lsot = print_LSoT_time.get()
        hc_utc = print_utc_time.get()
        # זמנים לא קיים
        
        # תאריך לועזי שעה והפרש מגריניץ
        hc_time = print_time.get()
        #hc_greg = print_greg_date.get() # מדפיס עם שם היום
        hc_utc_offset = print_GMT_difference.get()

        
        # עדכון שורת הכותרת
        canvas.itemconfig(city_id, text=hc_location_name)

        
        # איזור תאריך עברי כולל צבע מתאים לימי חול ולשבתות וחגים
        # צבע הטקסט והרקע של התאריך העברי: ביום חול לבן על שחור ובשבת וחג שחור על צהוב, ובחגים דרבנן כולל תעניות שחור על ציאן
        
        #################################################################################
        # איזור לטיפול בכך שהרקע הצבעוני שתחת התאריך העברי יהיה רק תחתיו ולא בכל השורה
        
        # קבלת טקסט עם הנתונים על הפונט שהוגדר לאיזור התאריך העברי והפרדתו למערך של שלושה נתונים
        heb_date_font_tuple = canvas.itemcget(heb_date_id, "font").split()
        # הפרדת שלושת הנתונים
        font_family, font_size, font_weight = heb_date_font_tuple
        # בניית אובייקט פונט של טקינטר מתוך מערך שלושת הנתונים
        heb_date_font = tkfont.Font(family=font_family, size=int(font_size), weight=font_weight)   
        # מדידת אורך הטקסט של התאריך העברי בהתאם לפונט שבו השתמשנו לכתוב אותו
        text_width = heb_date_font.measure(hc_heb_date)
        y1 = 19 * scale # גובה התחלת הרקע מראש המסך
        y2 = 35 * scale # גובה סיום הרקע מראש המסך
        center_x = 160 * scale # מרכז המסך מימין לשמאל
        padding = 30 # שוליים נוספים מעבר לטסקט אם רוצים שהרקע יחרוג קצת. לא הכרחי אפשר לעשות 0
        x1 = center_x - (text_width / 2) - padding # מרחק תחילת הטקסט ממרכז המסך
        x2 = center_x + (text_width / 2) + padding # מרחק סוף הטקסט ממרכז המסך
        canvas.coords(heb_date_rect_id, x1, y1, x2, y2) # עדכון הרקע כך שיהיה רק בגבולות של הטקסט

        ####################################################################
        
        
        canvas.itemconfig(heb_date_rect_id, fill=HEB_DATE_BG)
        canvas.itemconfig(heb_date_id, text=hc_heb_date, fill=HEB_DATE_FG)
        canvas.itemconfig(holiday_id, text=hc_holiday)
       
        # עדכון שעה זמנית גרא ומגא ודקות בשעה זמנית לכל אחת מהשיטות
        canvas.itemconfig(minutes_in_gra_temporal_hour_id, text=hc_minutes_gra)
        canvas.itemconfig(gra_method_id, text=hc_gra_method)
        canvas.itemconfig(gra_temporal_hour_id, text=hc_clock_gra)
        if add_labels:
            canvas.itemconfig(gra_title_id, text=hc_gra_day)
            canvas.itemconfig(mga_title_id, text=hc_mga_day)
        canvas.itemconfig(minutes_in_mga_temporal_hour_id, text=hc_minutes_mga)
        canvas.itemconfig(mga_method_id, text=hc_mga_method)
        canvas.itemconfig(mga_temporal_hour_id, text=hc_clock_mga)

        # עדכון מידע על השמש והירח גובה אזימוט ושלב בחודש
        canvas.itemconfig(sun_az_id, text=hc_sun_az)
        canvas.itemconfig(sun_alt_id, text=hc_sun_alt)
        canvas.itemconfig(moon_name_id, text=hc_body_name)
        canvas.itemconfig(moon_az_id, text=hc_body_az)
        canvas.itemconfig(moon_alt_id, text=hc_body_alt)
        canvas.itemconfig(moon_phase_id, text=hc_moon_phase_percent)
            

        global current_screen_hesberim, current_screen_zmanim, current_screen_zmanim_with_clocks
        
        
        # איזור שורת הסברים מתחלפת
        text = reverse(hesberim[int(current_screen_hesberim)][0])  # רוורס של הטקסט העברי
        time_value = hesberim[int(current_screen_hesberim)][1]  # הערך להצגה
        CCC = f"{time_value}  :{text}" if time_value != "" else f"{text}"
        # עדכון שורת ההסברים
        canvas.itemconfig(info_id, text=CCC if is_heb_locale else "information") # אפשר להשמיט את fill="violet" ואז הטקסט יהיה לבן כמו שהוגדר לעיל
       
                
        ### הכנה לשורת שעונים. הרווחים הם בכוונה לצורך מירכוז בשעון ההלכה הפיזי
        clocks_string = f"{hc_magrab}  {hc_lmt}  {hc_lsot}  {hc_utc}"
        #clocks_string = f"גריניץ  |  מקומי  |  מקומי-ממוצע  |  מהשקיעה"
        # משתנה ששומר מערך זמנים שבו אחרי כל שורת זמן יש שורת שעונים וכך הזמנים והשעונים מוצגים לסירוגין
        zmanim_with_clocks = [item for zman_line in zmanim_list for item in (zman_line, [reverse(clocks_string)])]
        zmanim_with_clocks_string = reverse(zmanim_with_clocks[int(current_screen_zmanim_with_clocks)][0])
        zmanim_string = reverse(zmanim_list[int(current_screen_zmanim)][0])
        
        # מציג בשורה את מה שכתוב בהגדרות שצריך להציג. ברירת המחדל היא זמנים עם שעונים
        d_dict = {"zmanim_with_clocks": zmanim_with_clocks_string, "zmanim": zmanim_string, "clocks": clocks_string}
        canvas.itemconfig(zmanim_with_clocks_id, text=d_dict.get(settings_dict["zmanim_mode"], zmanim_with_clocks_string))
        
        
        # קידום בשלב אחד עבור הגדרת השרוה הבאה בסיבוב הבא
        speed_step = 0.15 #מהירות ההחלפה כדלהלן: 0.15 = 6 שניות | 0.3 = 3 שניות | 0.45 = שנייה וחצי
        current_screen_hesberim = (current_screen_hesberim + (speed_step * 2)) % len(hesberim)  # זה גורם מחזור של שניות לאיזה נתונים יוצגו במסך
        current_screen_zmanim = (current_screen_zmanim + speed_step) % len(zmanim_list)
        current_screen_zmanim_with_clocks = (current_screen_zmanim_with_clocks + speed_step) % len(zmanim_with_clocks)
       
        
        
        #############################################################################
        #############################################################################
        #############################################################################
            
        
        # עדכון תאריך לועזי שעה רגילה ואיזור זמן
        canvas.itemconfig(utc_offset_id, text=hc_utc_offset)
        canvas.itemconfig(time_id, text=hc_time)
        canvas.itemconfig(greg_date_id, text=hc_greg)
        
        
        #gc.collect() # ניקוי הזיכרון חשוב לפעמים כדי למנוע קריסות מזיכרון עמוס מידי
        
        
        ####################################################################
        # כשהמונה מגיע ל- 45 מדמים לחיצה על מקש שיפט במקלדת כדי למנוע כיבוי אוטומטי  
        global counter_shift
        if counter_shift >= 45:
            #print("counter_shift_press")
            keyboard = keyboard_Controller()
            keyboard.press(keyboard_Key.shift)
            keyboard.release(keyboard_Key.shift)
            counter_shift = 0.0 # איפוס המונה
        
        counter_shift += 1 # בכל שנייה המונה מתקדם באחד
        ####################################################################
           

        # חזרה על העדכון כל שנייה מחדש. זה לא דבר כבד כי כל החישובים כבר מבוצעים בחלון הראשי
        root_hw.after(1000, update_canvas)


    # התחלת העדכון
    update_canvas()



############################################################################################
                            # עד כאן שעון ההלכה למחשב
############################################################################################
    
    

        
# פונקצייה לחלון ההסברים
def esber():
    esber = Toplevel(ws)
    esber.minsize(80,80)
    esber.geometry(f"{round(800*magnification_factor)}x{round(685*magnification_factor)}+{round(100*magnification_factor)}+{round(1*magnification_factor)}")
    # הגדרת צבע לכל החלון
    esber.configure(bg=cu_color)
    esber.title(reverse("כוכבים וזמנים: מידע כללי והסברים", for_title = True))
    Label(esber, text=reverse("ברוכים הבאים לתוכנת כוכבים וזמנים") if is_heb_locale else "Welcome to the Cochavim uzmanim software", font = "david 18 bold").pack()
    Label(esber, text=reverse("תוכנה זו נכתבה על ידי הרב ד''ר שמחה גרשון בורר") if is_heb_locale else "This software was written by Rabbi Dr. Simcha Gershon Bohrer", font = "david 14 bold").pack()
    Label(esber, text=reverse(f"לפניות\n {reverse('sgbmzm@gmail.com')} \n") if is_heb_locale else "For contact\nsgbmzm@gmail.com\n", font = "david 13 bold").pack()
    
    # אזור נפרד לטקסט ההסברים
    output_text = cu_PanedWindow(esber)

    # גלילה של הטקסט למעלה ולמטה
    Y_scrollbar = Scrollbar(output_text, orient = 'vertical')
    Y_scrollbar.pack( side = RIGHT, fill = Y )

    # חלון טקסט עצמו להצגת התוצאות
    txt = Text(output_text, height=50, width=90, yscrollcommand = Y_scrollbar.set, font= "david 13")
    
    # הכנסת ההסברים לתוך תיבת הטקסט. ההסברים נמצאים במשתנה אינפורמיישן שהוגדר בתחילת קוד זה
    txt.insert("end", f'{reverse(INFORMATION)}')
    
    # הגדרת העיצוב של הטקסט בתיבת הטקסט: שיהיה ממורכז
    txt.tag_configure("center", justify='center')
    txt.tag_add("center", 1.0, "end")   
    
    # סגירה של תיבת הטקסט לקריאה בלבד ואריזה לתוך החלון
    txt.configure(state="disabled")
    
    # חסימת כל תגובה לעכבר וכו של תיבת הטקסט
    # כדי למנוע בעיות בהיפוך התצוגה של העברית
    #txt.bindtags(("txt", "esber", "all"))
    
    # לחילופין, חסימת שתי תגובות ספציפיות לעכבר עבור תיבת הטקסט
    txt.bind("<Button>", lambda event: "break")
    txt.bind("<Motion>", lambda event: "break")

    # אריזת תיבת הטקסט
    txt.pack( side = LEFT, fill = BOTH )

    # הגדרת שפעולת ברי הגלילה תתבצע על תיבת הטקסט
    Y_scrollbar.config( command = txt.yview )

    # אריזת האיזור הנפרד של טקסט התוצאות
    output_text.pack()
    
    
# פונקצייה לדילוג זמן קדימה ואחורה בשעון העליון
def time_skip(time):

    def get_values():
        
        # יצירת הזמן הנוכחי
        current_time = time

        # חישוב ההפרש בזמן
        time_difference = timedelta(days=int(days.get()), hours=int(hours.get()), minutes=int(minutes.get()), seconds=int(seconds.get()))

        # חישוב הזמן לפי ההפרש המחושב
        if sign.get() == "+":
            result_time = current_time + time_difference
        else:
            result_time = current_time - time_difference

        # עדכון הזמן בשעון הראשי של התוכנה
        set_date_time(result_time)
        
        # כיבוי חלון הדילוג
        window.destroy()


        #result_label.config(text=f"Days: {days}, Hours: {hours}, Minutes: {minutes}, Seconds: {seconds}")

    def reset_values():
        days.set(0)
        hours.set(0)
        minutes.set(0)
        seconds.set(0)
        sign.set("+")
    
    # יצירת חלון ראשי
    window = Toplevel(ws)
    window.title(reverse("זמן לדילוג", for_title = True) if is_heb_locale else "time to skip")
    # מיקום החלון מעל החלון הראשי
    window.wm_transient(ws)
    window.minsize(180,310)
    window.geometry(f"{round(180*magnification_factor)}x{round(310*magnification_factor)}+{round(100*magnification_factor)}+{round(120*magnification_factor)}")
    # הגדרת צבע לכל החלון
    window.configure(bg=cu_color)
    
    # יצירת ספינבוקסים לבחירת פלוס או מינוס, ימים, שעות, דקות ושניות
    
    
    sign = StringVar(window)
    days = StringVar(window)
    hours = StringVar(window)
    minutes = StringVar(window)
    seconds = StringVar(window)
    
    sign_spinbox = tkinter.Spinbox(window, textvariable=sign, values=("+", "-"), width=2, wrap=True, font = "narkisim 17",justify='center',state = 'readonly')
    days_spinbox = tkinter.Spinbox(window, textvariable=days, from_=0, to=99, width=2,wrap=True,font = "narkisim 17",justify='center',state = 'readonly')
    hours_spinbox = tkinter.Spinbox(window, textvariable=hours, from_=0, to=99, width=2, wrap=True,font = "narkisim 17",justify='center',state = 'readonly')
    minutes_spinbox = tkinter.Spinbox(window, textvariable=minutes, from_=0, to=99, width=2, wrap=True,font = "narkisim 17",justify='center',state = 'readonly')
    seconds_spinbox = tkinter.Spinbox(window, textvariable=seconds, from_=0, to=99, width=2,wrap=True,font = "narkisim 17",justify='center',state = 'readonly')

    # הוספת תוויות לספינבוקסים
    tkinter.Label(window, text=reverse("בחרו זמן לדילוג"), font = "david 15 bold").grid(row=0, column=2)
    tkinter.Label(window, text=reverse("ימים"),font = "david 15").grid(row=1, column=2)
    tkinter.Label(window, text=reverse("שעות"),font = "david 15").grid(row=2, column=2)
    tkinter.Label(window, text=reverse("דקות"),font = "david 15").grid(row=3, column=2)
    tkinter.Label(window, text=reverse("שניות"),font = "david 15").grid(row=4, column=2)
    tkinter.Label(window, text=reverse("קדימה/אחורה"), font = "david 15").grid(row=5, column=2)

    # הצגת הספינבוקסים באמצעות רשימה
    
    days_spinbox.grid(row=1, column=1, padx=5, pady=5)
    hours_spinbox.grid(row=2, column=1, padx=5, pady=5)
    minutes_spinbox.grid(row=3, column=1, padx=5, pady=5)
    seconds_spinbox.grid(row=4, column=1, padx=5, pady=5)
    sign_spinbox.grid(row=5, column=1, padx=5, pady=5)


    # כפתור איפוס
    reset_values_button = tkinter.Button(window, text=reverse("אפס הכל"), command=reset_values)
    reset_values_button.grid(row=6, column=1, columnspan=2, pady=10)
    
    # כפתור לקבלת הערכים שנבחרו והזנתם לשעון הראשי
    get_values_button = tkinter.Button(window, text=reverse("בצע דילוג"),font = "david 15 bold", command=get_values)
    get_values_button.grid(row=7, column=1, columnspan=2, pady=10)



    
# פונקצייה שדואגת שלא יהיה אפשר להזין בקלט מהמשתמש תאריך לועזי שאינו קיים כגון 30 לפברואר ועוד    
def fixing_greg_day():
    if int(greg_month.get()) == 2 and int(greg_day.get()) > 28 and not is_leap_year(int(greg_year.get())):
        greg_day.set(28)
    elif int(greg_month.get()) == 2 and int(greg_day.get()) > 28 and is_leap_year(int(greg_year.get())):
        greg_day.set(29)
    elif int(greg_month.get()) in [4,6,9,11] and int(greg_day.get()) == 31:
        greg_day.set(30)
    # זה נועד כדי למנוע שגיאה של התוכנה בחישובים עבור היומיים הראשונים של שנת 1 לספירה
    elif int(greg_year.get()) == 1 and int(greg_month.get()) == 1 and int(greg_day.get()) < 3:
        greg_day.set("03")
    #ws.after(1, fixing_greg_day)
    
    
# פונקצייה להקפצת חלון הודעה על סולם הזמן והסטייה שלו עבור הכפתור המתאים בתפריט אפשרויות נוספות
def time_scale_showinfo():
    # קבלת שעה מקום ואיזור הזמן מהמשתמש
    time,location,location_timezone=time_location_timezone()
    
    ts_info = f'''
        השנה הלועזית המבוקשת היא:     {mean_transit_and_error_timescale_dict["year"]}
        סולם הזמן שבשימוש לשנה זו:    {mean_transit_and_error_timescale_dict["year_timescale"]} 
        לסולם זמן זה בסקייפילד יש שגיאה קטנה
        שגיאה זו משמעותית יותר בשנים מאוד קדומות
        שגיאת סולם הזמן לשנה זו היא:       {mean_transit_and_error_timescale_dict["seconds_error_timescale"]}       שניות
        השגיאה אינה משפיעה על חישוב אירועים אסטרונומיים
        אלא על: מה השעה בשעת האירועים האסטרונומיים
        שגיאה זו משפיעה על רוב השעונים והזמנים בתוכנה 
        למעט: שעון מקומי אמיתי וממוצע ומשוואת הזמן - שתוקנו

        חישוב השגיאה התבצע באמצעות בדיקת ההבדל בין שעת חצות 
        היום (מרידיאן-טרנזיט) בממוצע שנתי, לבין השעה 12:00 
        שהיא השעה שבה אמור להיות חצות היום בממוצע שנתי '''

    tkMessageBox.showinfo(reverse("מידת השגיאה של סולם הזמן"), reverse(ts_info))



####################################################################################################################
                               # הפונקציות הראשיות שמפעילות את התוכנה
####################################################################################################################

# פונקצייה להורדת קובץ לתיקיית הקבצים של כוכבים וזמנים כולל חלון התקדמות
def downloading_files(url_string, file_name_string):
    """
    הורדת קובץ מהאינטרנט עם חלון התקדמות וביטול.
    הקובץ יישמר בשם file_name_string בתיקיית cu_dir_path.
    """
    if is_heb_locale:
        msg_box = tkMessageBox.askquestion(reverse('אישור הורדת קבצים'), reverse(f'\nהאם אתה בטוח שברצונך להוריד את הקובץ "{file_name_string}"?'))
    else:
        msg_box = tkMessageBox.askquestion('Confirm file download', f'\nAre you sure you want to download the file "{file_name_string}"?')

    if msg_box != 'yes':
        return  # המשתמש ביטל את ההורדה

    file_path = os.path.join(cu_dir_path, file_name_string)
    
    # אם הקובץ כבר קיים לא ממשיכים הלאה
    if os.path.exists(file_path):
        tkMessageBox.showinfo(
                reverse("הודעה") if is_heb_locale else "Message",
                reverse(f"הקובץ: \n'{file_name_string}' \nכבר קיים בתיקיית: {cu_dir_path}")
                if is_heb_locale else
                f"File: \n'{file_name_string}' \nAlready exists in dir: {cu_dir_path}"
            )
        return

    # שימוש בקובץ זמני
    temp_path = file_path + ".part"

    progress_win = Tkinter.Toplevel(ws)
    progress_win.title(reverse("הורדת קובץ") if is_heb_locale else "Downloading file")

    progress_label = Tkinter.Label(progress_win, text=reverse("מתחיל בהורדה...") if is_heb_locale else "Starting download...")
    progress_label.pack(padx=10, pady=5)

    progress_bar = ttk.Progressbar(progress_win, length=300, mode="determinate")
    progress_bar.pack(padx=10, pady=5)

    cancel_flag = threading.Event()

    def cancel_download():
        cancel_flag.set()
        progress_label.config(text=reverse("הביטול התבקש, מוחק קובץ חלקי...") if is_heb_locale else "Cancellation requested, deleting partial file...")

    cancel_button = Tkinter.Button(progress_win, text=reverse("בטל") if is_heb_locale else "Cancel", command=cancel_download)
    cancel_button.pack(padx=10, pady=5)

    def download():
        try:
            with urlopen(url_string) as response, open(temp_path, 'wb') as out_file:
                total = int(response.headers.get('Content-Length', 0))
                downloaded = 0
                block_size = 8192

                while True:
                    if cancel_flag.is_set():
                        break

                    buffer = response.read(block_size)
                    if not buffer:
                        break

                    out_file.write(buffer)
                    downloaded += len(buffer)
                    progress = (downloaded / total) * 100 if total > 0 else 0
                    mb_done = downloaded / (1024 * 1024)
                    mb_total = total / (1024 * 1024) if total > 0 else 0
                    progress_bar["value"] = progress
                    progress_label.config(
                        text=f"{mb_done:.2f}/{mb_total:.2f} MB ({progress:.1f}%)"
                        if not is_heb_locale else
                        f"{progress:.1f}% ({mb_done:.2f}/{mb_total:.2f} MB)"
                    )
                    progress_win.update_idletasks()

            # ביטול או הורדה חלקית
            if cancel_flag.is_set() or (total > 0 and downloaded < total):
                try:
                    os.remove(temp_path)
                except:
                    pass
                tkMessageBox.showinfo(
                    reverse("הודעה") if is_heb_locale else "Message",
                    reverse("ההורדה בוטלה והקובץ נמחק") if is_heb_locale else "Download cancelled, file deleted"
                )
                progress_win.destroy()
                return

            # הצלחה
            os.rename(temp_path, file_path) # שינוי שם הקובץ הזמני לשם הקובץ הסופי שצריך להיות
            tkMessageBox.showinfo(
                reverse("הודעה") if is_heb_locale else "Message",
                reverse(f"הקובץ '{file_name_string}' הורד בהצלחה. התוכנה תיסגר וצריך להפעילה מחדש.")
                if is_heb_locale else
                f"File '{file_name_string}' downloaded successfully. The program will now close and need to restart."
            )
            ws.destroy()

        except Exception as e:
            try:
                os.remove(temp_path)
            except:
                pass
            tkMessageBox.showerror(
                reverse("שגיאה") if is_heb_locale else "Error",
                reverse(f"שגיאה בהורדת הקובץ '{file_name_string}':\n{e}") if is_heb_locale else f"Error downloading file '{file_name_string}':\n{e}"
            )
            progress_win.destroy()

    threading.Thread(target=download, daemon=True).start()

            
# פונקצייה מאוד חשובה ויסודית שהכל מתחיל ממנה
# פונקצייה לקבלת ועיבוד קלט מהמשתמש של תאריך שעה מקום ואיזור הזמן
# פונקצייה זו קובעת גם את האפאמאריס שיהיה בשימוש כתלות במספר השנה הלועזית
# לאחר הגדרת האפאמאריס המתאים, פונקצייה זו גם קובעת את סולם הזמן המתאים לשימוש באמצעות קריאה לפונקצייה שקובעת זאת
def time_location_timezone():    
    
    # תיקון קבלת מיקרו שניות
    # אם מיקרושניות מוגדרות ידנית על ידי המשתמש הן רק בין אפס לתשע ולכן צריך להכפיל אותן כדי שיהיו בערכים הרגילים שלהן
    if int(microseconds.get()) <= 9:
        ms=(int(microseconds.get()) * 100000)
    else:
        ms= int(microseconds.get())
    
    # הגדרת קלט הזמן                                                
    input_date_time = datetime(int(greg_year.get()), 
                           int(greg_month.get()), 
                           int(greg_day.get()), 
                           int(hours.get()), 
                           int(minutes.get()), 
                           int(seconds.get()),
                            ms)
    
    ##########################################################
    # הגדרה !מאוד! חשובה מהו סולם הזמן של סקייפילד שיהיה בשימוש לכל התוכנה קלט ופלט של זמנים
    # סולם הזמן המקובל היום הוא יו.טי.סי. והוא מתחשב בדלטא_טי החל משנת 1972 ושומרים שלא יתרחק מ-יו.טי.1. באמצעות שניות קפיצה
    # סולם זמן יו.טי.1 מתחשב תמיד! בדלטא_טי ולכן ומשקף את סיבוב כדור הארץ האמיתי ולכן הוא בשימוש עבור רוב השנים למעט 1972 עד 2072
    global is_ut1
    is_ut1 = False if (input_date_time.year >1972 and input_date_time.year <2072) else True
    #print("is_ut1",is_ut1)
    ########################################################
    
    # אם המשתמש בחר באופצייה הנקראת בחירה ידנית
    if city.get() in ["בחירה-ידנית", "Choose manually"]:
        
        # הצבת התאים המתאימים לבחירת מיקום ידנית באיזור המיקום
        cb5.grid(column=8, row=1)
        cb4.grid(column=2, row=1)
        cb3.grid(column=1, row=1)
        cb3_Label.grid(column=1, row=2, columnspan=2)
        cb2.grid(column=5, row=1)
        cb1.grid(column=4, row=1)
        cb1_Label.grid(column=4, row=2, columnspan=2)
        
        # הגדרת מיקום גיאוגרפי שהמשתמש מזין ידנית
        User_choice_lat=float(f'{lat_part_1.get()}.{lat_part_2.get()}')
        User_choice_lon=float(f'{lon_part_1.get()}.{lon_part_2.get()}')
        User_choice_elevation = float(elevation_part.get())
        location = wgs84.latlon(User_choice_lat, User_choice_lon, User_choice_elevation)
        
       
    # בכל מקרה אחר, הנתונים של המיקום נלקחים מתוך קובץ האקסל של המיקומים בהתאמה לבחירת המשתמש  
    # ברירת המחדל של המיקומים זה המיקום הראשון ברשימת המיקומים
    else:
        # ביטול ההצבה של תיבות להזנת מיקום ידני
        cb5.grid_forget()
        cb4.grid_forget()
        cb3.grid_forget()
        cb2.grid_forget()
        cb1.grid_forget()
        cb3_Label.grid_forget()
        cb1_Label.grid_forget()
        
        # קליטת המיקום מקובץ המיקומים 
        for i in range (len(locations)):
            if city.get() in [ reverse(locations[i]["location_name_heb"]), locations[i]["location_name_en"] ]:
                location = locations[i]["skyfield_location"]
      
    ###############################################################################
    # חישוב איזור זמן רגיל באמצעות get_tz מיועד רק! עבור שנים שלאחר תחילת שנת 1918 שמאז יש התייחסות לשעון חורף וקיץ וכו
    # לפני שנת 1918 אין!!! להשתמש באיזור הזמן הרגיל אלא באיזור זמן מתואם הקרוב למיקום לפי 15 מעלות אורך כדי שהזמנים ההיסטוריים יהיו כמו שנהג אז
    # הגדרת המשתנה שקובע האם ללכת לפי איזור זמן של tzfpy או לפי איזור זמן ידני
    is_tzfpy_timezone = True if input_date_time >= datetime(1918,1,1) else False
    
    if is_tzfpy_timezone:    
        timezone_location_name = get_tz(location.longitude.degrees, location.latitude.degrees)
    else:
        # הגדרה של איזור זמן כללי לפי הפרש מגריניץ. שימו לב שזה נכון במדוייק רק לקו האורך שמתחלק בדיוק ל-15 כגון קו אורך 30 או 45 וכו
        # לפני שנת 1918 אין שעון קיץ ולדוגמא ישראל תמיד תהיה שעתיים אחרי גריניץ
        utc_different = abs(round(location.longitude.degrees/15)) % 24
        timezone_location_name = f"Etc/GMT-{utc_different}" if location.longitude.degrees >= 0 else f"Etc/GMT+{utc_different}"
    
    # הגדרת איזור הזמן לפי שם איזור הזמן שנקבע
    location_timezone = timezone(timezone_location_name)
    ###################################################################################    
            
    
    # הגדרת הזמן 
    # זמן של עכשיו לחישוב רציף או זמן מהמשתמש לכל שאר האפשרויות
    
    # במקרה שמדובר בעדכון רציף
    if choice_time.get() == "עכשיו מתעדכן":
        
        ###########################
        # השורות הבאות זו תיאוריה שלא הוכיחה את עצמה ואולי אפילו גרמה לבעיות
        # משום מה הזמן הנלקח רגיל מהמחשב מתאים ל-יו.טי.1 ואינו יוצר בעיות ולכן אין להתייחס לשורות הבאות
        # הנושא הזה בוטל גם בכל המקומות האחרים בתוכנה אך הושאר בסולמית למקרה שיהיה צורך חוזר בעתיד
        # במקרה שהתוכנה מוגדרת על סולם זמן יו.טי.1. יש בעיה בכך שהשעון של המחשב הוא בסולם זמן יו.טי.סי 
        # לכן הפתרון הבא שממיר את הזמן כך שהסופי הוא יו.טי.1. אם זה סולם הזמן הנוכחי של התוכנה
        # מכייון שהפתרון הזה אולי קצת מסרבל את החישוב הרציף, עשיתי שהוא יהיה רק אם באמת יש צורך בו כלומר רק כאשר התוכנה משתמשת ב יו.טי.1
        # בדרך כלל בהווה התוכנה תשתמש ב יו.טי.סי לפחות עד שנת 2075
        #time = skyfield_to_cu_time(ts.now(), location_timezone) if is_ut1 else datetime.now().astimezone(location_timezone)
        ##########################
        
        # בכוונה תחילה עשיתי את החישוב הרציף באסטימזון ולא בלוקליז כדי שאם לדוגמא המיקום הוא ניו יורק אז השעון יהיה על הזמן בניו יורק
        time = datetime.now().astimezone(location_timezone)
        #-----------------------------------
        # הפיכת כל הקומבובוקסים של השעון העליון להיות לא זמינים למשתמש כדי שלא יוכל לשנות אותם בשעה שמוגדר חישוב רציף
        # זה לא חובה אלא מונע בלבול, אבל אם עושים את זה חייבים לבטל את זה כאשר לא מוגדר עכשיו מתעדכן וכדלהלן
        for combobox in [greg_year_cb,greg_month_cb,greg_day_cb,hours_cb,minutes_cb,seconds_cb,microseconds_cb]:
            combobox.state(["disabled"])
        
        # עדכון של השעון העליון בזמן המדוייק של החישוב. זה לא חובה אלא תוספת ליופי
        set_date_time(time)
        #------------------------------------
    
    # בכל מקרה שלא מדובר בעכשיו מתעדכן רציף
    else:
        
        # בכוונה תחילה עשיתי את החישוב שאינו רציף בלוקליז ולא באסטימזון להיפך מבמצב של עכשיו מתעדכן וראו שם לעיל
        time = location_timezone.localize(input_date_time)
        #####################################################
        # אני לא מבין למה אבל כאן עובד דווקא החישוב כמו בשורה הקודמת בלי המרה מ-יו.טי.סי. ל- יו.טי.1 ולכן כאן !אסור! להפעיל את השורה הבאה
        #time = skyfield_to_cu_time(ts.from_datetime(time), location_timezone)
        #####################################################
        
        #-------------------------------------
        # החזרת כל הקומבובוקסים של השעון העליון להיות !זמינים! למשתמש במצב ההתחלתי שהוגדר בהם: קריאה בלבד
        # זה חובה רק אם לעיל מגדירים את זה להיות לא זמין בעכשיו מתעדכן
        for combobox in [greg_year_cb,greg_month_cb,greg_day_cb,hours_cb,minutes_cb,seconds_cb,microseconds_cb]:
            combobox.state(["!disabled"])
        #-------------------------------------
        
    
    # איזור הטיפול בטווחי השנים הנתמכים בתוכנה לפי האפאמאריס הקיים
    # הצהרה על משתנים גלובליים הדרושים להלן
    global eph
    global eph_440
    global eph_441s
    
    # הגדרת טווח הזמן שיש בכל אפאמאריס
    dates_440 = time.date() >= datetime(1551,1,1).date() and time.date() <= datetime(2649,12,31).date()
    dates_441s = time.date() >= datetime(1,1,3).date() and time.date() <= datetime(2999,12,31).date()
    

    # אפשרות ראשונה הכי טובה: אם התאריך שהזין המשתמש נמצא בטווח של אפאמאריס 440 ואפאמריס זה קיים, יש להשתמש בו כי הוא הכי מדוייק
    if dates_440 and eph_440 != False:
        eph = eph_440
        #return time,location,location_timezone
    
    # אפשרות שנייה: רק אם התאריך לא בטווח של אפאמאריס 440, והתאריך נמצא בטווח של אפאמאריס 441 ואפאמאריס זה קיים, יש להשתמש בו
    elif dates_441s and eph_441s != False:
        eph = eph_441s
        #return time,location,location_timezone
    
    # אפשרות שלישית: טווח הזמן בתוך 441 אבל אפאמאריס 441 לא קיים
    elif dates_441s and eph_441s == False:
        # מגדרים את השעון העליון לעכשיו, מוציאים הודעת שגיאה וקוראים שוב לפונקצייה זו על הזמן החדש
        #set_date_time(skyfield_to_cu_time(ts.now(), location_timezone))
        set_date_time(datetime.now().astimezone(location_timezone))
        msg=reverse("התוכנה חזרה לתאריך הנוכחי\nמפני שהתאריך שהזנת אינו בטווח שבין 1.1.1551 לבין 31.12.2649\nלשם תמיכה בתאריכים שבין 3.1.1 לבין 31.12.2999 צריך קובץ נוסף\nשם הקןבץ הוא de441s.bsp וניתן להורידו בחלון אפשרויות נוספות")
        en_msg="The software has returned to the current date\nBecause the date you entered is not in the range between 1.1.1551 and 31.12.2649\nIn order to support dates between 3.1.1 and 31.12.2999 we need an additional file\nthe name of the file is de441s.bsp and it can be downloaded from the the additional options window"
        tkMessageBox.showinfo(reverse("שגיאה: חסר קובץ מתאים לחישוב התאריך המבוקש") if is_heb_locale else "Error: A suitable file is missing to calculate the requested date",msg if is_heb_locale else en_msg)          
        return time_location_timezone()
    
    # אפשרות רביעית: במקרה שמתוך ממיר התאריכים מגיע תאריך שאינו מכוסה אפילו לא על ידי אפאמאריס 441
    elif not dates_441s:
        # מגדרים את השעון העליון לעכשיו, מוציאים הודעת שגיאה וקוראים שוב לפונקצייה זו על הזמן החדש
        #set_date_time(skyfield_to_cu_time(ts.now(), location_timezone))
        set_date_time(datetime.now().astimezone(location_timezone))
        if is_heb_locale:
            tkMessageBox.showinfo(reverse("שגיאה"),reverse("התאריך שהזנת אינו נתמך ולכן התוכנה חזרה לתאריך הנוכחי"))
        else:
            tkMessageBox.showinfo("Error","The date you entered is not supported so the software reverted to the current date")
        return time_location_timezone()
     
    
    #######################################
    # כדי לחסוך בחישובים מיותרים: בניתי מילון שמחזיק את הערך של חצות בממוצע שנתי כל עוד שהמיקום והשנה לא השתנו
    # מילון זה מחזיק גם את סולם הזמן שבשימוש ומידת השגיאה של סולם הזמן
    # אם המיקום והשנה המבוקשים שונים מהמיקום והשנה שיש במילון אז מחליפים את המילון במילון מתאים למיקום והשנה הנוכחיים
    # הערך הזה חשוב גם למשוואת הזמן וגם לידיעת שגיאת סולם הזמן ולכן הוא מוגדר כאן כדי שיוגדר תמיד מיד, ויהיה זמין לכל התוכנה
    global mean_transit_and_error_timescale_dict
    if not (time.year == mean_transit_and_error_timescale_dict["year"] and location == mean_transit_and_error_timescale_dict["location"]):
        year_mean_transit = calcolate_local_year_mean_transit(time.year, location)
        mean_transit_and_error_timescale_dict = {
            "year":time.year,
            "location":location,
            "year_mean_transit":year_mean_transit,
            "seconds_error_timescale":calculate_seconds_error_timescale(year_mean_transit),
            "year_timescale": "UT1" if is_ut1 else "UTC"
        }

    ###########################################
        
    # החזרת שלושה פרמטרים: זמן בשעון מקומי, מיקום, ואיזור זמן
    return time,location,location_timezone




# משתנים גלובליים חשובים מאוד עבור all_calculations כדי למנוע חישוב כבד של זיחות ושקיעות וכדומה כשאין צורך בחישוב חדש
Today_SR, Today_SS, LAST_SS, NEXT_SR, LAST_SS_0_833, seconds_equation_of_time, str_equation_of_time = [None] * 7
Today_SR_MGA, Today_SS_MGA, LAST_SS_MGA, NEXT_SR_MGA = [None] * 4
last_stamp = None

# פונקציית זו היא הפונקצייה הראשית של התוכנה והיא קוראת לכל הפונקציות האחרות ומפעילה את כל החישובים    
def all_calculations():
    
    # אם כפתור הפעלת החישובים לא פעיל יש לצאת מייד מהפונקצייה
    if C1.get() != 1:
        return
    
    #########################################################################################
    # משתנה נורא חשוב שמתחיל מדידה שמשמעותה כמה זמן לקח החישוב של כל הפונקצייה הזו
    # לפי זה נדע כל כמה זמן לקרוא שוב לפונקצייה הזו בחישובים רציפים
    perf_counter_start = pytime.perf_counter()
    ########################################################################################
          
    # דבר ראשון, תיקון קלט התאריך באמצעות פונקצייה כדי שלא יוזנו תאריכים שאינם קיימים וכדומה
    fixing_greg_day()

    # קבלת שעה מקום ואיזור הזמן מהמשתמש
    time,location,location_timezone=time_location_timezone()

    # חישוב נתונים אסטרונומיים על בסיס השעה המקום ואיזור הזמן
    print_astro_calculations(time,location,location_timezone)

    
    # הצהרה על המשתנים הגלובליים
    global Today_SR, Today_SS, LAST_SS, NEXT_SR, LAST_SS_0_833, seconds_equation_of_time, str_equation_of_time
    global Today_SR_MGA, Today_SS_MGA, LAST_SS_MGA, NEXT_SR_MGA
    global last_stamp
    
    # שמירת חותמת של כל הנתונים החשובים שאם אחד מהם משתנה חייבים לחשב מחדש זריחות ושקיעות
    stamp = (location.latitude.degrees, location.longitude.degrees, location.elevation.m, time.date(), time.utcoffset(), location_timezone, Halachic_method_MGA.get(), Halachic_method_GRA.get())
    
    # בכל מקרה כזה צריך לעדכן חישובים
    need_update = stamp != last_stamp # זה עוזר גם לשנייה הראשונה כי אז last_stamp הוא None וגם לפעמים הבאות שאז הוא לא שווה אם משתנה משהו בתוך החותמת
    
    # לאחר שבדקנו אם צריך עדכון: עדכון המשתנה החיצוני בחותמת העכשווית לצורך הבדיקה הבאה
    last_stamp = stamp
    
    # במקרה שצריך עדכון מחשבים מחדש זריחות ושקיעות וחצות וזה מעדכן את המשתנים הגלובליים שמחוץ לפונקצייה בערכים החדשים
    if need_update:
        
        
        print("צריך עדכון")
        print("stamp: ", stamp)
        print("last_stamp: ", last_stamp)
        print("")
        
        ########################################################################
        # החלק העליון של התוכנה פועל תמיד, אבל החלק שתלוי בחישובי זריחה ושקיעה לא פועל במקום שאין בו זריחה ושקיעה בכל יום כגון באיזור הקוטב הצפוני
        # לכן צריך לנסות, ואם לא מצליחים לחשב שקיעות אז לא לחשב שעות זמניות ולא לחשב כמה שעות עברו מהשקיעה
        try:
            # קריאה לפונקציית חישוב שעות זמניות על זריחות ושקיעות בגובה המוגדר לפי הגדרת המשתמש בשעון הזמני
            # תחילה חישוב הזריחות והשקיעות הדרושות: זריחה ושקיעה של היום עבור שעה זמנית ביום, שקיעה קודמת וזריחה הבאה עבור שעה זמנית בלילה              
            # תחילה יש לקבל מה האופק שהמשתמש רוצה
            gethorizon_GRA = Halachic_method_GRA.get()
            Today_SR,Today_SS,_,_,_,_ = calculate_rising_seting(time,location,location_timezone,horizon=gethorizon_GRA, body="sun",PLUS_MINUS = "NONE")
            _,LAST_SS,_,_,_,_ = calculate_rising_seting(time,location,location_timezone,horizon=gethorizon_GRA, body="sun",PLUS_MINUS = "MINUS")
            NEXT_SR,_,_,_,_,_ = calculate_rising_seting(time,location,location_timezone,horizon=gethorizon_GRA, body="sun",PLUS_MINUS = "PLUS")           
        except IndexError:         
            Today_SR, Today_SS, LAST_SS, NEXT_SR = [None] * 4
            
        #######################################################################    
        try:
            
            # שיטה לא נכונה, אבל יש שחושבים כך: שעות זמניות מעלות השחר עד צאת הכוכבים של הגאונים. נקטתי לדוגמא מינוס 4 מעלות לצאת הכוכבים
            # במקרה זה צריך לחשב יותר חישובים מהרגיל כי הזריחה והשקיעה הם לא באותו גובה שמש תחת האופק
            if Halachic_method_MGA.get() > 10:
                Today_SR_MGA,_,_,_,_,_ = calculate_rising_seting(time,location,location_timezone,horizon=-16, body="sun",PLUS_MINUS = "NONE")
                _,Today_SS_MGA,_,_,_,_ = calculate_rising_seting(time,location,location_timezone,horizon=-4, body="sun",PLUS_MINUS = "NONE")
                _,LAST_SS_MGA,_,_,_,_ = calculate_rising_seting(time,location,location_timezone,horizon=-4, body="sun",PLUS_MINUS = "MINUS")
                NEXT_SR_MGA,_,_,_,_,_ = calculate_rising_seting(time,location,location_timezone,horizon=-16, body="sun",PLUS_MINUS = "PLUS")
            
            # בכל מקרה אחר החישוב הוא לזריחה ולשקיעה באותו גובה תחת האופק
            else:
                # תחילה יש לקבל מה האופק שהמשתמש רוצה
                gethorizon_MGA = Halachic_method_MGA.get()
                Today_SR_MGA,Today_SS_MGA,_,_,_,_ = calculate_rising_seting(time,location,location_timezone,horizon=gethorizon_MGA, body="sun",PLUS_MINUS = "NONE")
                _,LAST_SS_MGA,_,_,_,_ = calculate_rising_seting(time,location,location_timezone,horizon=gethorizon_MGA, body="sun",PLUS_MINUS = "MINUS")
                NEXT_SR_MGA,_,_,_,_,_ = calculate_rising_seting(time,location,location_timezone,horizon=gethorizon_MGA, body="sun",PLUS_MINUS = "PLUS")

        except IndexError:           
            Today_SR_MGA, Today_SS_MGA, LAST_SS_MGA, NEXT_SR_MGA = [None] * 4
            
        ##############################################################################
 
        try: 
            # חישוב מתי הייתה השקיעה האחרונה של מינוס 0.833 באמצעות פונקציית חישוב זריחות ושקיעות
            _,LAST_SS_0_833,_,_,_,_ = calculate_rising_seting(time,location,location_timezone,horizon=-0.833, body="sun",PLUS_MINUS = "MINUS")          
        except IndexError:            
            LAST_SS_0_833 = None
            
        #################################################################################
            
        try:    
            # חישוב משוואת הזמן והגדרתה למשבצת המתאימה וחישוב מספר השניות שיש במשוואת הזמן 
            _, _, seconds_equation_of_time, str_equation_of_time  = calculate_transits_and_equation_of_time(time,location,location_timezone)
        except IndexError:
            seconds_equation_of_time, str_equation_of_time = [None] * 2
            
        ###################################################################################
            
              
        
    # חישוב השעות הזמניות לפי הזריחות והשקיעות שהוגדרו לעיל
    # גם format_dt וגם convert_seconds יודעים לטפל במצבים שחוזר none כי אין זריחה ושקיעה
    temporal_time, seconds_in_temporal_hour, sunrise_determines, sunset_determines, day_night_str = calculate_temporal_time(time, Today_SR, Today_SS, NEXT_SR, LAST_SS)
    # הדפסות עבור שעון שעה זמנית
    print_day_or_night_GRA.set(day_night_str)
    print_Sunrise_determines_GRA.set(format_dt(sunrise_determines))
    print_Sunset_determines_GRA.set(format_dt(sunset_determines))
    print_temporal_hour_GRA.set(temporal_time)
    print_minutes_in_temporal_hour_GRA.set(convert_seconds(seconds_in_temporal_hour))
    #print_minutes_in_day_or_night_GRA.set(minutes_in_day_or_night)
           
    ####################################################################
    
    # חישוב השעות הזמניות לפי הזריחות והשקיעות שהוגדרו לעיל
    temporal_time_MGA, seconds_in_temporal_hour_MGA, sunrise_determines_MGA, sunset_determines_MGA, day_night_str_MGA = calculate_temporal_time(time, Today_SR_MGA, Today_SS_MGA, NEXT_SR_MGA, LAST_SS_MGA)
    # הדפסות עבור שעון שעה זמנית
    print_day_or_night_MGA.set(day_night_str_MGA)
    print_Sunrise_determines_MGA.set(format_dt(sunrise_determines_MGA))
    print_Sunset_determines_MGA.set(format_dt(sunset_determines_MGA))
    print_temporal_hour_MGA.set(temporal_time_MGA)
    print_minutes_in_temporal_hour_MGA.set(convert_seconds(seconds_in_temporal_hour_MGA))
       
    ####################################################################
            
    if LAST_SS_0_833:
        # חישוב כמה שניות עברו מהשקיעה האחרונה 0.833- שהייתה ועד עכשיו
        seconds_from_last_sunset = (time - LAST_SS_0_833).total_seconds()
        # החזרת והדפסת סטרינג מעוצב של שעות דקות ושניות שעברו מהשקיעה באמצעות פונקציית המרת שנייות
        print_hours_from_last_sunset.set(convert_seconds(seconds_from_last_sunset, to_hours=True))
    else:
        print_hours_from_last_sunset.set("שגיאה")

    ####################################################################
    
    # ניסיון לחישוב משוואת הזמן והדפסתה
    if seconds_equation_of_time and str_equation_of_time:  
     
        # ניסיון לחישוב שעון מקומי אמיתי
        # שימו לב: שעון מקומי ממוצע מודפס בפונקציית אול_כלכוליישנס כי חישובו לא תלוי בחישוב חצות ולכן אין צורך לעשות לו ניסיון
           
        # חישוב השעה בשעון גריניץ לצורך חישוב שעון מקומי ממוצע
        utc_time = time.astimezone(timezone('utc'))
        ###########################
        # אני לא מבין למה אבל כאן עובד דווקא החישוב כמו בשורה הקודמת בלי המרה מ-יו.טי.סי. ל- יו.טי.1 ולכן אסור להפעיל את השורה הבאה
        #utc_time = skyfield_to_cu_time(ts.from_datetime(time), location_timezone)
        ############################
        
        # חישוב שעון מקומי ממוצע
        lmt=localmeantime(utc_time,location.longitude.degrees)
        
        # חישוב שעון מקומי אמיתי באמצעות הוספת מספר השניות של משוואת הזמן על השעון המקומי הממוצע - והדפסת השעה המקומית האמיתית
        #Local_solar_time = lmt + timedelta(seconds=seconds_equation_of_time)
        #########################
        # אם משתמשים במשוואת זמן מדוייקת בפונקציית חישוב חצות ומשוואת הזמן, יש לקחת בחשבון גם את שגיאת סולם הזמן כדי שחצות יהיה בשעה 12:00 בשעון מקומי אמיתי
        # זה עדיין משאיר את שעון מקומי ממוצע בשגיאה
        corrected_seconds_equation_of_time = seconds_equation_of_time + mean_transit_and_error_timescale_dict["seconds_error_timescale"]
        Local_solar_time = lmt + timedelta(seconds=corrected_seconds_equation_of_time)
        
        print_LSoT_time.set(f'{Local_solar_time:%H:%M:%S}')
        print_equation_of_time.set(str_equation_of_time)
        
    else:
        print_LSoT_time.set("שגיאה")
        print_equation_of_time.set("שגיאה")

    ######################################################
     
    
    # הפרש מ-UTC בשעות כשבר עשרוני
    utc_offset_hours = time.utcoffset().total_seconds() / 3600
    # הפרש השעות מגריניץ לתצוגה יפה. עשיתי סימני מינוס ופלוס בנפרד בגלל בעיות תצוגה של עברית מימין לשמאל
    #utc_offset_str = f"UTC{'+' if utc_offset_hours >= 0 else '-'}{int(abs(utc_offset_hours)):02d}{f':{int(round((abs(utc_offset_hours)-int(abs(utc_offset_hours)))*60)):02d}' if utc_offset_hours % 1 else ''}"
    utc_offset_str = f'utc{time.strftime("%z")[:3]}'
    
    # המרת הזמן לזמן של סקייפילד
    #time_skyfield = datetime_to_skyfield_time(time)
        
    #------------------------
    # הדפסות תאריכים ושעות של כל החישובים הנ"ל
    
    greg_date = dates.GregorianDate(1880, 10, 20).from_pydate(time)
    # הגדרת תאריך עברי מקביל לתאריך הלועזי, ולמחרתו
    heb_date = greg_date.to_heb()
    
    # חישוב השעה בשעון גריניץ, והדפסתה
    # הזמן באיזור הזמן גרינץ
    utc_time = time.astimezone(timezone('utc'))
    print_utc_time.set(f'{utc_time:%H:%M:%S}')
    
    # קריאה לפונקציית חישוב שעון מקומי ממוצע, והדפסתו
    lmt=localmeantime(utc_time,location.longitude.degrees)
    #########################
    # אם משתמשים במשוואת זמן מדוייקת בפונקציית חישוב חצות ומשוואת הזמן, יש לקחת בחשבון גם את שגיאת סולם הזמן כדי שחצות יהיה בשעה 12:00 בשעון מקומי אמיתי
    # התיקון הבא יכול לתקן גם את הדפסת שעון מקומי ממוצע 
    lmt = lmt + timedelta(seconds=mean_transit_and_error_timescale_dict["seconds_error_timescale"])
    ##########################
    print_lmt_time.set(f'{lmt:%H:%M:%S}')
    
    # הדפסת השעה בשעון מקומי מתואם
    print_time.set(f'{time:%H:%M:%S}')
    
    # הגדרת הפרש השעות בין שעון מתואם גריניץ לשעון מתואם מקומי, והדפסתו
    print_GMT_difference.set(utc_offset_str)
    
    # הדפסת שם איזור הזמן
    print_location_timezone.set(location_timezone)
    
    # הדפסת שם המקום
    print_location.set(city.get())
    
    # הדפסת התאריך הלועזי עם היום בשבוע, ואם התאריך לפני שנת 1924 אז הדפסת המילה "גרגוריאני" ליד התאריך
    # יוון הייתה המדינה האחרונה שעברה מלוח יוליאני לגרגוריאני וזה היה בשנת 1923
    #is_gregorian = "(גרגוריאני)" if greg.date() < datetime(1924,1,1).date() else ""
    print_greg_date.set(f'{reverse(heb_string_day(greg_date.weekday())) if is_heb_locale else en_string_day(greg_date.weekday())} - {greg_date:%d/%m/%Y}')
    
    # משתנה ששומר את המילה "מוצאי" אם מדובר בזמן שהוא לאחר השקיעה אבל לפני השעה 12 בלילה שאז התאריך העברי העקרוני מקדים ביום את התאריך הלועזי
    # הסיבה שהגדרתי גם את זה שהשעה היא אחרי 12 בצהריים כי בשעה 1 בלילה זה גם לפני 12 בלילה, ואז לא צריך לכתוב מוצאי כי התאריך הלועזי כבר התחלף
    #heb_date_is_next_greg_date = bool(s_alt <= -0.833 and greg.time() > dt.time(12,0,0,0) and greg.time() < dt.time(23,59,59,999999))
    
    
    # מאחרי השקיעה התאריך העברי המתאים הוא התאריך של היום הלועזי הבא
    # מחזיר משתנה בוליאני כלומר טרו או פאלס כדי למנוע שגיאה כששולחים את זה לקוטלין באנדרואיד
    heb_date_is_next_greg_date = bool(Today_SS and time > Today_SS)
    
    # עדכון התאריך העברי כולל שינוי צבע הרקע של התאריך העברי לפי המשתנה
    if heb_date_is_next_greg_date:
        heb_date += 1
   
    # מהשקיעה עד 12 בלילה מוסיפים את המילה ליל כי היום בשבוע והתאריך העברי מקבלים לתאריך הלועזי של מחר
    leil_string = "ליל: " if heb_date_is_next_greg_date else ""
    heb_date_string = reverse(f'{leil_string}{heb_string_day(heb_date.weekday())} - {heb_date.hebrew_date_string(True)}')   
    # הדפסת התאריך העברי
    print_heb_date.set(heb_date_string)
    
    '''
    # דרך לטיפול בתאריך העברי שישתנה אחרי השקיעה. אבל יש לזכור שזה יוצר בלבול וגם בעיה במקומות שבהם אין זריחה/שקיעה
    # הדפסת תאריך עברי לפי יום או לילה: התאריך העברי המקביל-או למחרתו: באמצעות בדיקה האם השמש מעל או מתחת לאופק ומה השעה
    # יש שלושה מצבים לטיפול: 1. אחרי השקיעה ולפני 12 בלילה. 2. אחרי 12 בלילה ולפני עלות השחר. 3. אחרי הזריחה ולפני השקיעה
    # במקרה שהשמש תחת האופק כלומר שזה לילה, והשעה היא לפני 12 בלילה אבל אחרי 12 בצהריים - אז התאריך הלועזי הוא אור לתאריך הלועזי הבא
    if s_alt <= -0.833 and greg.time() > dt.time(12,0,0,0) and greg.time() < dt.time(23,59,59,999999):
        print_heb_date.set(f' אור ל: {heb_string_day(heb_1.weekday())} - {heb_1.hebrew_date_string(True)}')
    # במקרה שהשעה היא אחרי 12 בלילה אבל לפני 12 בצהריים והשמש נמוכה מגובה מינוס 16 מעלות שזה לפני עלות השחר - אז התאריך הלועזי הוא אור לתאריך הלועזי הנוכחי
    elif s_alt < -16.0 and greg.time() < dt.time(12,0,0,0) and greg.time() >= dt.time(0,0,0,0):
        print_heb_date.set(f' אור ל: {heb_string_day(heb.weekday())} - {heb.hebrew_date_string(True)}')
    # בכל מקרה אחר, כלומר אחרי הזריחה ולפני השקיעה - התאריך העברי שווה בדיוק לתאריך הלועזי הנוכחי
    else:
        print_heb_date.set(f' {heb_string_day(heb.weekday())} - {heb.hebrew_date_string(True)}')
        '''
    
    # חישוב האם שבת. שבת מוגדרת מהשקיעה של סוף יום שישי עד השקיעה של סוף שבת וכדלעיל
    is_shabat = heb_date.weekday() == 7
    
    # האם המיקום הוא בישראל שכך אין יום טוב שני
    is_location_in_israel = location_timezone in ["Israel", "Asia/Jerusalem"] # יש בעיה בגלל שלפני שנת 1918 location_timezone הוא רק הפרש מ utc
    
     # אם זה לא חג המשתנה מחזיר None
    holiday_name = heb_date.holiday(israel=is_location_in_israel, hebrew=True, prefix_day=True)
    
    # רק אם החג ברשימה הזו זה יום טוב. אם לא ברשימה הזו זה לא יום טוב אלא חג כמו פורים או חול המועד
    is_yom_tov = holiday_name in ['ראש השנה', 'יום כיפור', 'סוכות', 'שמיני עצרת', 'שמחת תורה', 'פסח', 'שבועות',]
    # חלופה לרשימת החגים שהם יום טוב
    #heb_date.month == 7 and heb_date.day in [1,10,15,22] or heb_date.month == 1 and heb_date.day in [15,22] or heb_date.month == 3 and heb_date.day == 6
    # חישוב האם ראש חודש
    is_rosh_chodesh = heb_date.day in [30,1]
    # חישוב האם תענית
    is_taanit = heb_date.fast_day()
    # הגדרת חג קטן עבור חול המועד ראש חודש ותעניות
    is_lite_holiday = (holiday_name and not is_yom_tov) or is_rosh_chodesh or is_taanit
    
    global HEB_DATE_FG, HEB_DATE_BG
    # קביעת קוד מספרי שקובע עבור הקוד של אנדרואיד באיזה רקע יוצג התאריך העברי
    HEB_DATE_FG, HEB_DATE_BG  = ("black", "yellow") if is_shabat or is_yom_tov else ("black", "cyan") if is_lite_holiday else ("white", "black")
    
    # מחזיר מחרוזת ריקה או עם שם שבת חג וחג קטן 
    holiday_line_string = f"{'שבת קודש' if is_shabat else ''}  {holiday_name if holiday_name else ''}  {'ראש חודש' if is_rosh_chodesh else ''}  {is_taanit if is_taanit else ''}"
        
    
    '''
    # איזור שאחראי להגדיר ששעון ההלכה לא ייכנס אוטומטית למצב שינה בשבת ובחג. אך לא מחושב יום טוב שני
    # פונקציית עזר פנימית לבדיקה האם נמצאים מהשקיעה ועד מוצאי היום העברי
    # כברירת מחדל מוצאי היום העברי זה כשהשמש מינוס 4.6 מעלות תחת האופק
    # מוצאי שבת בלוחות הרגילים זה כשהשמש מינוס 8.5 מעלות תחת האופק
    def is_sunset_until_motsaei(degrees_for_motsaei = -4.6):
        return Today_SS and time > Today_SS and s_alt > degrees_for_motsaei
    
    # חישוב תוספות לשבת כלומר מיום שישי חצי שעה לפני השקיעה עד השקיעה וכן בשבת מהשקיעה ועד צאת שבת שבלוחות
    greg_weekday = greg_date.weekday() # חישוב היום בשבוע של התאריך הלועזי בדווקא
    half_hour_before_sunset_until_sunset =  Today_SS and time >= (Today_SS - timdelta(seconds=1800) and time < Today_SS # 1800 שניות זה חצי שעה לפני השקיעה  
    is_tosafot_leshabat = (greg_weekday == 6 and half_hour_before_sunset_until_sunset) or (greg_weekday == 7 and is_sunset_until_motsaei(degrees_for_motsaei = -8.5))
    shabat_before_motsaei_6 = (greg_weekday == 7 and is_sunset_until_motsaei(degrees_for_motsaei= -6)) 
    '''
    
    #####################################
    global hc_greg, hc_holiday
    hc_greg = f'{greg_date:%d/%m/%Y}'
    hc_holiday = reverse(holiday_line_string)
    ###################################
      
    # חישוב האם קו הרוחב הגיאוגרפי של המיקום הוא צפוני או דרומי, והדפסת קו הרוחב
    location_lat_N_S = f"{reverse('צפון') if is_heb_locale else 'North'}" if location.latitude.degrees > 0 else f"{reverse('דרום') if is_heb_locale else 'South'}"
    print_location_lat.set(f'{abs(round(location.latitude.degrees, 4))} {location_lat_N_S}')
    
    # חישוב האם קו האורך הגיאוגרפי של המיקום הוא מזרח או מערב, והדפסת קו האורך
    location_lon_E_W = f"{reverse('מערב') if is_heb_locale else 'West'}" if location.longitude.degrees < 0 else f"{reverse('מזרח') if is_heb_locale else 'East'}"
    print_location_lon.set(f'{abs(round(location.longitude.degrees, 4))} {location_lon_E_W}')
    
    # הדפסת גובה המיקום
    print_location_elevation.set(int(location.elevation.m))
    
    
    
    
    ############################################################################
    ############################################################################
    ############################################################################
    '''
    sozkash_gra = None
    sozat_gra = None
    chatzot = None
    mincha_gedola = None
    mincha_ketana = None
    pelag_hamincha = None
    
    if sunrise_today and sunset_today:
        day_len = sunset_today - sunrise_today  # timedelta
        sozkash_gra = (sunrise_today + (day_len / 12) * 3)
        sozat_gra = (sunrise_today + (day_len / 12) * 4)
        chatzot = (sunrise_today + (day_len / 12) * 6)
        mincha_gedola = (sunrise_today + (day_len / 12) * 6.5)
        mincha_ketana = (sunrise_today + (day_len / 12) * 9.5)
        pelag_hamincha = (sunrise_today + (day_len / 12) * 10.75)
    
    sozkash_mga = None
    sozat_mga = None
    
    if mga_sunrise_today and mga_sunset_today:
        mga_day_len = mga_sunset_today - mga_sunrise_today # timedelta
        sozkash_mga = (mga_sunrise_today + (mga_day_len / 12) * 3)
        sozat_mga = (mga_sunrise_today + (mga_day_len / 12) * 4)
    '''
    
    
    # איזור הדפסת זמנים בשעון רגיל. כל האיזור עדיין בבניה
    sunrise, sunset = Today_SR, Today_SS
    mga_sunrise, mga_sunset = Today_SR_MGA, Today_SS_MGA
    #חישוב מספר השקיעה מהזריחה לשקיעה
    seconds_day_gra = (sunset - sunrise) / 12 if sunrise and sunset else None
    seconds_day_mga = (mga_sunset - mga_sunrise) / 12 if mga_sunrise and mga_sunset else None
    
    def hhh(start_time, delta_per_hour, hour, round_minute=False, with_seconds=True):
        if not delta_per_hour:
            return reverse("שגיאה")

        # חישוב הזמן
        dt = start_time + (delta_per_hour * hour)

        # עיגול לדקה הקרובה (אם הופעל)
        if round_minute:
            if dt.second >= 30:
                dt += timedelta(minutes=1)
            dt = dt.replace(second=0, microsecond=0)

        # פורמט החזרה
        if with_seconds:
            return dt.strftime("%H:%M:%S")
        else:
            return dt.strftime("%H:%M")    
        
    global zmanim_list
    misheiakir = ""
    tset_hacochavim = ""
    
    zmanim_list = [
        #["זמנים בשעון רגיל - וכן שעונים כדלהלן"],
        [f"עלות השחר: {reverse(hhh(mga_sunrise, seconds_day_mga, 0))}  |  משיכיר: {reverse(hhh(misheiakir, 0, 0))}"], 
        [f"זריחה גרא: {reverse(hhh(sunrise, seconds_day_gra, hour=0))}"],
        [f"סוף שמע: מגא - {reverse(hhh(mga_sunrise, seconds_day_mga, hour=3))}, גרא - {reverse(hhh(sunrise, seconds_day_gra, hour=3))}"], 
        [f"סוז''ת: מגא - {reverse(hhh(mga_sunrise, seconds_day_mga, hour=4))}, גרא - {reverse(hhh(sunrise, seconds_day_gra, hour=4))}"],
        [f"חצות היום - וכנגדו בלילה: {reverse(hhh(sunrise, seconds_day_gra, hour=6))}"],
        [f"מנחה: גדולה - {reverse(hhh(sunrise, seconds_day_gra, hour=6.5))}, קטנה - {reverse(hhh(sunrise, seconds_day_gra, hour=9.5))}"],
        [f"פלג המנחה - {reverse(hhh(sunrise, seconds_day_gra, hour=10.75))}"],
        [f"שקיעה גרא: {reverse(hhh(sunrise, seconds_day_gra, hour=12))}"],
        [f"כוכבים: גאונים - {reverse(hhh(tset_hacochavim, 0, 0))}, רת - {reverse(hhh(mga_sunrise, seconds_day_mga, hour=12))}"],
    ]

    
   
    #######################################################################################################
    
    # חישוב כמה זמן לקח הפעולה של הפונקצייה הזו
    calc_time = pytime.perf_counter() - perf_counter_start
    #print(f"calc time: {calc_time:.3f}s") # אם רוצים להדפיס. במחשב חזק לקח 0.031 s ובמחשב האיטי לקח 0.310 s שזה פי עשר יותר לאט
     
    # רק אם מוגדר על חישוב מתעדכן רציף אז יש לרענן כל שנייה מחדש את הנתונים ע"י קריאות חוזרות לפונקציית כל החישובים
    if choice_time.get() == "עכשיו מתעדכן":
        # יעד: חישוב פעם בשנייה.
        # במחשב חזק שזמן החישוב לוקח מעט - מחכים יותר עד הקריאה החוזרת
        # במחשב חלש העדכונים יותר תכופים.
        # העדכונים תמיד מכוונים לעדכון פעם בשנייה
        delay_ms = max(0, int((1.0 - calc_time) * 1000))
        # אחרי הזמן שעבר - קוראים שוב לפונקצייה הנוכחית
        ws.after(delay_ms, all_calculations)
        

    
# פונקצייה להדפסות לתוך התאים המתאימים של כל הנתונים על השמש הירח וכוכבי הלכת וכן התאריכים והזמנים
def print_astro_calculations(time,location,location_timezone):
    
    
    # כמה לעגל כל מספר
    #R_num = 6
    
    # אם רוצים לעשות שכל התאריכים לפני שהתחיל הלוח הגרגוריאני יהיו לפי הלוח היוליאני ולא לפי הגרגוריאני
    #from skyfield.api import GREGORIAN_START
    #ts.julian_calendar_cutoff = GREGORIAN_START
    
    # המרת הזמן המקומי לזמן של סקייפילד
    time = cu_to_skyfield_time(time)
    
    
    # כל החישובים על השמש
    body = "sun"
    
    # הפעלת הפונקצייה שמחשבת את כל הנתונים על השמש שזהו הגוף המוגדר כעת
    s_alt,s_az,ra,dec,ha,dec_N_S,lat,lon,dist,lat_N_S,percent,apparent_diameter,thickness,_,elongation,ecliptic_elongation,elongation_E_W,_,_ = astro_calculations(body,time,location,location_timezone)
     
    #################################################
    # משתנים גלובליים של נתונים עבור שעון ההלכה
    global hc_sun_alt, hc_sun_az
    hc_sun_alt = f"{round(s_alt, 3) :2.3f}°"
    hc_sun_az = f"{round(s_az, 1) :2.1f}°"
    #########################################
    
    # הכנסת החישובים לתוך התאים המתאימים
    # עיגלתי את נתוני גובה השמש במקום החמישי כי הייתה סטייה קטנה בלחיצה על כפתור של: לכוון את השעון העליון לשעה שבה השמש בגובה מסויים
    ##### זה מה שהיה בהתחלה והשארתי בינתיים לסימן    sun_alt.set(f"{format(round(alt, 5), 'f')}°")
    
    sun_alt.set(f"{round(s_alt, 5) :2.6f}°") 
    sun_az.set(f"{round(s_az, 6) :2.6f}°") 
    sun_ra.set(ra)
    sun_dec.set(f"{abs(round(dec, 6)) :2.6f}° {dec_N_S}") 
    sun_ha.set(ha)
    sun_lat.set(f"{abs(round(lat, 6)) :2.6f}° {lat_N_S}") 
    sun_lon.set(f"{round(lon, 6) :2.6f}°") 
    sun_dist.set(f"{dist :,.1f} km")

    # הכנסת החישוב המתאים לתא שיש בו בחירה מתחלפת
    if elongation_percent_thickness.get() in [reverse("אֵלוֹנְגַּצְיָה (מהשמש)"), "Elongation"]:
        sun_elongation_percent_thickness.set("--")
    elif elongation_percent_thickness.get() in [reverse("אורך ראשון (מהשמש)"), "Ecliptic Elongation"]:
        sun_elongation_percent_thickness.set("--")
    elif elongation_percent_thickness.get() in [reverse("אחוזי תאורה"), "Fraction Illuminated"]:
        sun_elongation_percent_thickness.set("--")
    elif elongation_percent_thickness.get() in [reverse("קוטר זוויתי נראה"), "Apparent Diameter"]:
        sun_elongation_percent_thickness.set(f"{round(apparent_diameter,4)}'")
    
    #---------------------
    # מכאן והלאה חישובים על גוף נבחר ראשון שזה כוכבי לכת נראים
    
    # הגדרה מהו הגוף הנבחר הראשון
    if body1.get() in [reverse("נוגה"), 'Venus']:
        body = "venus"
    elif body1.get() in [reverse("צדק"), 'Jupiter']:
        body = "jupiter barycenter"
    elif body1.get() in [reverse("מאדים"), 'Mars']:
        body = "mars barycenter"
    elif body1.get() in [reverse("שבתאי"), 'Saturn']:
        body = "saturn barycenter"
    elif body1.get() in [reverse("כוכב-חמה"), 'Mercury']:
        body = "mercury"
    elif body1.get() in [reverse("ירח"), 'Moon']:
        body = "moon"
    elif body1.get() in [reverse("אוראנוס"), 'Uranus']:
        body = "uranus barycenter"
    elif body1.get() in [reverse("נפטון"), 'Neptune']:
        body = "neptune barycenter"
    elif body1.get() in [reverse("פלוטו"), 'Pluto']:
        body = "pluto barycenter"
    # למקרה שגיאה שלא יישאר על השמש
    else:
        body = "ABCDEFG"

    # הפעלת הפונקצייה שמחשבת את כל הנתונים על הגוף הנבחר הראשון
    alt,az,ra,dec,ha,dec_N_S,lat,lon,dist,lat_N_S,percent,apparent_diameter,thickness,slon,elongation,ecliptic_elongation,elongation_E_W,_,_ = astro_calculations(body,time,location,location_timezone)
    
    
    ######################################################    
    # משתנים גלובליים של נתונים עבור שעון ההלכה
    global hc_body_alt, hc_body_az
    hc_body_alt = f"{round(alt, 3) :2.3f}°"
    hc_body_az = f"{round(az, 1) :2.1f}°"
    ####################################################

    
    # הכנסת החישובים לתוך התאים המתאימים
    body1_alt.set(f"{round(alt, 6) :2.6f}°") 
    body1_az.set(f"{round(az, 6) :2.6f}°") 
    body1_ra.set(ra)
    body1_dec.set(f"{abs(round(dec, 6)) :2.6f}° {dec_N_S}") 
    body1_ha.set(ha)
    body1_lat.set(f"{abs(round(lat, 6)) :2.6f}° {lat_N_S}") 
    body1_lon.set(f"{round(lon, 6) :2.6f}°") 
    body1_dist.set(f"{dist :,.1f} km")
    
    # הכנסת החישוב המתאים לתא שיש בו בחירה מתחלפת
    if elongation_percent_thickness.get() in [reverse("אֵלוֹנְגַּצְיָה (מהשמש)"), "Elongation"]:
        body1_elongation_percent_thickness.set(f"{round(elongation, 6) :2.6f}° {elongation_E_W}")
    elif elongation_percent_thickness.get() in [reverse("אורך ראשון (מהשמש)"), "Ecliptic Elongation"]:
        body1_elongation_percent_thickness.set(f"{round(ecliptic_elongation, 6) :2.6f}° {elongation_E_W}")
    elif elongation_percent_thickness.get() in [reverse("אחוזי תאורה"), "Fraction Illuminated"]:
        body1_elongation_percent_thickness.set(f"{round(percent, 6) :2.6f} %")
    elif elongation_percent_thickness.get() in [reverse("קוטר זוויתי נראה"), "Apparent Diameter"]:
        body1_elongation_percent_thickness.set(f"{round(thickness,4)}' / {round(apparent_diameter,4)}'")
        
        
    
    #----------------------------
    # מכאן והלאה חישובים על גוף נבחר שני שזה כוכבי שבת
    
    # הצהרה על משתנים גלובליים של המיקומים ושמותיהם
    global stars
    
    # הגדרת הגוף שעליו יבוצעו החישובים לפי הכוכב שהמשתמש בחר להציג באופציית בחירת הכוכבים
    for i in range(len(stars)):
        if body2.get() in [ reverse(stars[i]["name_he"]), stars[i]["name_en"] ]:
            body = stars[i]["skyfield Star"]
        
    
    # הפעלת הפונקצייה שמחשבת את כל הנתונים על הגוף הנבחר השני שהוא כוכב שבת
    alt,az,ra,dec,ha,dec_N_S,lat,lon,dist,lat_N_S,percent,apparent_diameter,thickness,slon,elongation,ecliptic_elongation,elongation_E_W,_,_ = astro_calculations(body,time,location,location_timezone,body_type = "STAR")
    
    
    
    # הכנסת החישובים לתוך התאים המתאימים
    # עיגלתי את נתוני הגובה במקום החמישי כי הייתה סטייה קטנה לחישוב לדוגמא של שש עשרה מעלות בדיוק
    body2_alt.set(f"{round(alt, 6) :2.6f}°") 
    body2_az.set(f"{round(az, 6) :2.6f}°") 
    body2_ra.set(ra)
    body2_dec.set(f"{abs(round(dec, 6)) :2.6f}° {dec_N_S}") 
    body2_ha.set(ha)
    body2_lat.set(f"{abs(round(lat, 6)) :2.6f}° {lat_N_S}") 
    body2_lon.set(f"{round(lon, 6) :2.6f}°") 
    body2_dist.set(f"{dist :.1f} au")
    
    # הכנסת החישוב המתאים לתא שיש בו בחירה מתחלפת
    if elongation_percent_thickness.get() in [reverse("אֵלוֹנְגַּצְיָה (מהשמש)"), "Elongation"]:
        body2_elongation_percent_thickness.set(f"{round(elongation, 6) :2.6f}° {elongation_E_W}") 
    elif elongation_percent_thickness.get() in [reverse("אורך ראשון (מהשמש)"), "Ecliptic Elongation"]:
        body2_elongation_percent_thickness.set(f"{round(ecliptic_elongation, 6) :2.6f}° {elongation_E_W}") 
    elif elongation_percent_thickness.get() in [reverse("אחוזי תאורה"), "Fraction Illuminated"]:
        body2_elongation_percent_thickness.set("--")
    elif elongation_percent_thickness.get() in [reverse("קוטר זוויתי נראה"), "Apparent Diameter"]:
        body2_elongation_percent_thickness.set("--")
    
    
    
    ###################################################################
    # משתנים גלובליים של נתונים עבור שעון ההלכה
    global hc_moon_phase_percent
    # חישוב האחוז שהירח עשה מתוך המסלול החודשי שלו
    # תחילה מחושב במעלות בין 0 ל- 360 ואחר כך אני ממיר לאחוזים בין 0 ל- 100
    # אמצע החודש יהיה 50 אחוז מהמסלול הרבעים יהיו 25 ו- 75 בהתאמה
    skyfield_phase = almanac.moon_phase(eph, time)
    moon_phase_percent = skyfield_phase.degrees / 360 * 100
    hc_moon_phase_percent = f"{moon_phase_percent:2.1f}%" if body1.get() in [reverse("ירח"), 'Moon'] else f""
    ####################################################################
     
    # הדפסת יום יוליאני
    print_JD.set(f'{time.tdb :02.6f}')
       
    # הדפסת דלטא טי לפי שעות דקות ושניות כולל הדפסה אם דלטא טי במינוס
    #print_delta_t.set(f'{time.delta_t :02.1f}') # הדפסה רק לפי שניות בוטלה
    print_delta_t.set(f'{"-" if time.delta_t < 0 else ""}{convert_seconds(abs(int(time.delta_t)), to_hours=True)}')
    
    
    #----------------------
    
    
####################################################################################################################
####################################################################################################################
       # יצירת תיבת טקסט עם סוגי מידע שונים: 1. זמני היום. 2. מידע על תחנת החלל. 3. כוכבים ראשונים. 4. ירח ראשון. 5. ירח אחרון 
####################################################################################################################
####################################################################################################################
     

# פונקצייה ראשית ליצירת תיבת טקסט2 עם זמני היום או זמני הירח או כוכבים ראשונים. מכילה מספר פונקציות משניות    
def print_halachic_times():
    
    # אם כפתור הפעלת החישובים לא פעיל, יש לצאת מייד מהפונקצייה
    if C1.get() != 1:
        return
    
    # ראשית כל עצירת החישובים הרציפים של התוכנה הראשית כדי לא להכביד על המערכת
    if choice_time.get() == "עכשיו מתעדכן":
        choice_time.set("עכשיו (לפי המחשב)")
    
    # תחילה מוגדרות כל הפונקציות המשניות לצורך הפונקצייה הראשית, ורק בסוף מוגדרת הפונקצייה הראשית
    
    '''
    # בוטל כי הועבר לתוך מידע על שנה עברית
    # מונקצייה משנית להוספת מידע על התקופה לקובץ טקסט2
    def txt2_add_tkufa():
        
        # פתיחת תיבת טקסט2 לעריכה ומחיקת כל מה שיש בה
        txt2.configure(state="normal")
        txt2.delete(1.0, END)
        
        # הכנסת נתונים כלליים לתיבת הטקסט
        txt2.insert("end", f'\nבטא: מידע חלקי על תקופת שמואל בשנת {heb.hebrew_year(True)}\n')
        #txt2.insert("end", f'\n\nשימו לב! כל החישובים בוצעו לפי תאריכים לועזיים\n')
        tshuva = kama_tkufat_nissan_shmuel_lifnei_mold_nisan(heb.year)
        txt2.insert("end", f'\n\nתקופת שמואל בשנת {heb.hebrew_year(True)} מקדימה את מולד ניסן ב: ימים - {tshuva[1]}; שעות - {tshuva[0]}; חלקים - {tshuva[2]}\n')
        
        # הגדרת העיצוב של הטקסט בתיבת הטקסט שיהיה ממורכז
        txt2.tag_configure("center", justify='center')
        txt2.tag_add("center", 1.0, "end")

        # סגירת תיבת הטקסט לקריאה בלבד
        txt2.configure(state="disabled")
        '''
       
        
    
    # פונקצייה משנית להוספת זמני היום לקובץ טקסט2
    def txt2_add_times():
        
        # חישוב האם קו הרוחב הגיאוגרפי של המיקום הוא צפוני או דרומי, והדפסת קו הרוחב
        location_lat_N_S = 'צפון' if location.latitude.degrees > 0 else 'דרום'
        location_lat_for_print = f'{abs(round(location.latitude.degrees,4))} {location_lat_N_S}'

        # חישוב האם קו האורך הגיאוגרפי של המיקום הוא מזרח או מערב, והדפסת קו האורך
        location_lon_E_W = 'מערב' if location.longitude.degrees < 0 else 'מזרח'
        location_lon_for_print = f'{abs(round(location.longitude.degrees,4))} {location_lon_E_W}'
        
        # פתיחת תיבת טקסט2 לעריכה ומחיקת כל מה שיש בה
        txt2.configure(state="normal")
        txt2.delete(1.0, END)
        
        # הכנסת נתונים כלליים לתיבת הטקסט
        txt2.insert("end", f'\nרשימת זמני היום\n')
        txt2.insert("end", f'\n\nשימו לב! כל החישובים בוצעו לפי תאריכים לועזיים\n')
        
        txt2.insert("end", f'\nתאריך: ({heb_for_print})   {greg_for_print}')
        txt2.insert("end", f'\nשם המקום: {city_for_print}')
        txt2.insert("end", f'\nקו רוחב - {location_lat_for_print}, קו אורך - {location_lon_for_print}, גובה - {int(location.elevation.m)} מטר')

        # הגדרת הודעה השגיאה שתופיע במקרה שהשמש לא יורדת לגובה המתאים במיקום זה
        eror = "שגיאה! (לתאריך ומיקום נוכחיים)"
        
        # ניסיון חישוב זמני היום והוספתם לקובץ טקסט2
        # בגלל שיש מקומות שאין זריחה ושקיעה, ויש מקומות שאין עלות השחר לכדומה לכן הכל בניסיון וגם כל זמן שתלוי בגובה השמש נמצא בניסיון
        try:
            
            txt2.insert("end", f'\n\nעלות השחר ודמדומי בוקר\n')
            
            try:
                SR,_,_,_,_,_ = calculate_rising_seting(time,location,location_timezone,horizon=-25.9, body="sun")
                txt2.insert("end", f'\nעלות השחר 25.9°- (5 מיל 24):    {SR:%H:%M:%S}')    
            except IndexError:
                txt2.insert("end", f'\nעלות השחר 25.9°- (5 מיל 24):    {eror}')

            try:
                SR,_,_,_,_,_ = calculate_rising_seting(time,location,location_timezone,horizon=-19.75, body="sun")
                txt2.insert("end", f'\nעלות השחר 19.75°- (4 מיל 22.5):    {SR:%H:%M:%S}')
            except IndexError:
                txt2.insert("end", f'\nעלות השחר 19.75°- (4 מיל 22.5):    {eror}')
            
            try:
                SR,_,_,SR_az,_,_ = calculate_rising_seting(time,location,location_timezone,horizon=-18, body="sun")
                txt2.insert("end", f'\nתחילת דמדומים אסטרונומיים 18°-:    {SR:%H:%M:%S}    באזימוט:   {SR_az :02.1f}°')
            except IndexError:
                txt2.insert("end", f'\nתחילת דמדומים אסטרונומיים 18°-:    {eror}')

            try:
                SR,_,_,_,_,_ = calculate_rising_seting(time,location,location_timezone,horizon=-16, body="sun")
                txt2.insert("end", f'\nעלות השחר 16°- (4 מיל 18):    {SR:%H:%M:%S}')
            except IndexError:
                txt2.insert("end", f'\nעלות השחר 16°- (4 מיל 18):    {eror}')

            try:
                SR,_,_,SR_az,_,_ = calculate_rising_seting(time,location,location_timezone,horizon=-14, body="sun")
                txt2.insert("end", f'\nעלות השחר נראה (הרב ניימאן) 14°-:    {SR:%H:%M:%S}    באזימוט:   {SR_az :02.1f}°')
            except IndexError:
                txt2.insert("end", f'\nעלות השחר נראה (הרב ניימאן) 14°-:    {eror}')

            try:
                SR,_,_,_,_,_ = calculate_rising_seting(time,location,location_timezone,horizon=-12, body="sun")
                txt2.insert("end", f'\nתחילת דמדומים ימיים (והאיר המזרח) 12°-:    {SR:%H:%M:%S}')
            except IndexError:
                txt2.insert("end", f'\nתחילת דמדומים ימיים (והאיר המזרח) 12°-:    {eror}')
                
            try:
                SR,_,_,_,_,_ = calculate_rising_seting(time,location,location_timezone,horizon=-10.5, body="sun")
                txt2.insert("end", f'\nמשיכיר את חבירו ברחוק 4 אמות 10.5°-:    {SR:%H:%M:%S}')
            except IndexError:
                txt2.insert("end", f'\nמשיכיר את חבירו ברחוק 4 אמות 10.5°-:    {eror}')
            
            try:
                SR,_,_,_,_,_ = calculate_rising_seting(time,location,location_timezone,horizon=-6, body="sun")
                txt2.insert("end", f'\nתחילת דמדומים אזרחיים 6°-:    {SR:%H:%M:%S}')
            except IndexError:
                txt2.insert("end", f'\nתחילת דמדומים אזרחיים 6°-:    {eror}')
            
            txt2.insert("end", f'\n\nהנץ\n')
            
            # חישוב השפעת גובה העיר במקרה שהעיר גבוהה או נמוכה
            if location.elevation.m != 0:
                Z = calculate_elevation_rise_set(location.elevation.m)
                SR,SS,_,_,_,_ = calculate_rising_seting(time,location,location_timezone,horizon=Z, body="sun")
                txt2.insert("end", f'\nכשאין הסתרות!! זריחה נראית בגובה העיר {str(round(Z,2))[1:]}°{"-" if Z < 0 else "+"}:    {SR:%H:%M:%S}')
            
            SR,SS,_,_,_,_ = calculate_rising_seting(time,location,location_timezone,horizon=-0.833, body="sun")
            txt2.insert("end", f'\nזריחה נראית במישור 0.833°-:    {SR:%H:%M:%S}')
            
            SR,SS,_,SR_az,_,_ = calculate_rising_seting(time,location,location_timezone,horizon=0, body="sun")
            txt2.insert("end", f'\nזריחה גיאומטרית 0°:    {SR:%H:%M:%S}    באזימוט:   {SR_az :02.1f}°')
            
            
            txt2.insert("end", f'\n\nשעות זמניות וחצות\n')
            
            SR,SS,_,_,_,_ = calculate_rising_seting(time,location,location_timezone,horizon=-0.833, body="sun")
            # חישוב כמה שניות יש בין השקיעה האחרונה לזריחה הקרובה בחלוקה לשתיים עשרה, שזה אומר כמה שניות יש בשעה זמנית של הלילה
            sec_TH = (SS - SR) / 12
            # חישוב מספר הדקות והשניות שיש בשעה זמנית אחת של היום, והדפסתם בפורמט של דקות ושניות
            minutes_in_temporal_hour = convert_seconds(sec_TH.total_seconds())
            txt2.insert("end", f'\nאורך שעה זמנית של היום (דקות ושניות):    {minutes_in_temporal_hour}')
            
            try:
                SR,SS,_,_,_,_ = calculate_rising_seting(time,location,location_timezone,horizon=-16, body="sun")
                txt2.insert("end", f'\nסוף זמן שמע מג"א (לפי 16°-):    {(SR) + (((SS - SR) / 12) *3):%H:%M:%S}')
            except IndexError:
                txt2.insert("end", f'\nסוף זמן שמע מג"א (לפי 16°-):    {eror}')
            
            
            SR,SS,_,_,_,_ = calculate_rising_seting(time,location,location_timezone,horizon=-0.833, body="sun")
            txt2.insert("end", f'\nסוף זמן שמע גר"א (שעה 3):    {(SR) + (((SS - SR) / 12) *3):%H:%M:%S}')
            
            try:
                SR,SS,_,_,_,_ = calculate_rising_seting(time,location,location_timezone,horizon=-16, body="sun")
                txt2.insert("end", f'\nסוף זמן תפילה מג"א (לפי 16°-):    {(SR) + (((SS - SR) / 12) *4):%H:%M:%S}')
            except IndexError:
                txt2.insert("end", f'\nסוף זמן תפילה מג"א (לפי 16°-):    {eror}')
               
            SR,SS,_,_,_,_ = calculate_rising_seting(time,location,location_timezone,horizon=-0.833, body="sun")
            txt2.insert("end", f'\nסוף זמן תפילה גר"א (שעה 4):    {(SR) + (((SS - SR) / 12) *4):%H:%M:%S}')
            
            SR,SS,_,_,_,_ = calculate_rising_seting(time,location,location_timezone,horizon=-0.833, body="sun")
            txt2.insert("end", f'\nסוף זמן ביעור חמץ בערב פסח (שעה 5):    {(SR) + (((SS - SR) / 12) *5):%H:%M:%S}')
            
            day_transit,_,_,_ = calculate_transits_and_equation_of_time(time,location,location_timezone)
            txt2.insert("end", f'\nחצות היום (כשעה 6 - וכעין זה חצות הלילה):    {day_transit:%H:%M:%S}')
                
            SR,SS,_,_,_,_ = calculate_rising_seting(time,location,location_timezone,horizon=-0.833, body="sun")
            txt2.insert("end", f'\nמנחה גדולה (שעה 6.5):    {(SR) + (((SS - SR) / 12) *6.5):%H:%M:%S}')
            
            SR,SS,_,_,_,_ = calculate_rising_seting(time,location,location_timezone,horizon=-0.833, body="sun")
            txt2.insert("end", f'\nסוף זמן מוסף לכתחילה (שעה 7):    {(SR) + (((SS - SR) / 12) *7):%H:%M:%S}')
            
            SR,SS,_,_,_,_ = calculate_rising_seting(time,location,location_timezone,horizon=-0.833, body="sun")
            txt2.insert("end", f'\nסמוך למנחה קטנה (שעה 9):    {(SR) + (((SS - SR) / 12) *9):%H:%M:%S}')
            
            SR,SS,_,_,_,_ = calculate_rising_seting(time,location,location_timezone,horizon=-0.833, body="sun")
            txt2.insert("end", f'\nמנחה קטנה (שעה 9.5):    {(SR) + (((SS - SR) / 12) *9.5):%H:%M:%S}')
             
            SR,SS,_,_,_,_ = calculate_rising_seting(time,location,location_timezone,horizon=-0.833, body="sun")
            txt2.insert("end", f'\nפלג המנחה (שעה 10.75):    {(SR) + (((SS - SR) / 12) *10.75):%H:%M:%S}')
            
            txt2.insert("end", f'\n\nשקיעה\n')
            
            _,SS,_,_,_,SS_az = calculate_rising_seting(time,location,location_timezone,horizon=0, body="sun")
            txt2.insert("end", f'\nשקיעה גיאומטרית 0°:    {SS:%H:%M:%S}    באזימוט:   {SS_az :02.1f}°')
            
            _,SS_N,_,_,_,_ = calculate_rising_seting(time,location,location_timezone,horizon=-0.833, body="sun")
            txt2.insert("end", f'\nשקיעה נראית במישור 0.833°-:    {SS_N:%H:%M:%S}')
            
            # חישוב השפעת גובה העיר במקרה שהעיר גבוהה או נמוכה
            if location.elevation.m != 0:
                Z = calculate_elevation_rise_set(location.elevation.m)
                SR,SS,_,_,_,_ = calculate_rising_seting(time,location,location_timezone,horizon=Z, body="sun")
                txt2.insert("end", f'\nכשאין הסתרות!! שקיעה נראית בגובה העיר {str(round(Z,2))[1:]}°{"-" if Z < 0 else "+"}:    {SS:%H:%M:%S}')
  
            txt2.insert("end", f'\n\nצאת הכוכבים ודמדומי ערב\n')
             
            try:
                _,SS,_,_,_,_ = calculate_rising_seting(time,location,location_timezone,horizon=-3.65, body="sun")
                # חישוב הפרש הדקות משקיעה מישורית נראית 0.833 עד צאת הכוכבים
                SHEIYA = (SS - SS_N).total_seconds()
                txt2.insert("end", f'\nצאת הכוכבים 3.65°- (3/4 מיל 18):    {SS:%H:%M:%S}     (דקות משקיעה מישורית: {convert_seconds(SHEIYA)})')
            except IndexError:
                txt2.insert("end", f'\nצאת הכוכבים 3.65°- (3/4 מיל 18):    {eror}')
                
            try:
                _,SS,_,_,_,_ = calculate_rising_seting(time,location,location_timezone,horizon=-4, body="sun")
                txt2.insert("end", f'\nצאת הכוכבים 4°- (20 דקות משקיעה גיאומטרית, ממוצע שנתי בארץ ישראל):     {SS:%H:%M:%S}')
            except IndexError:
                txt2.insert("end", f'\nצאת הכוכבים 4°- (20 דקות משקיעה גיאומטרית, ממוצע שנתי בארץ ישראל):     {eror}')
            
            try:
                _,SS,_,_,_,_ = calculate_rising_seting(time,location,location_timezone,horizon=-4.37, body="sun")
                # חישוב הפרש הדקות משקיעה מישורית נראית 0.833 עד צאת הכוכבים
                SHEIYA = (SS - SS_N).total_seconds()
                txt2.insert("end", f'\nצאת הכוכבים 4.37°- (3/4 מיל 22.5):    {SS:%H:%M:%S}     (דקות משקיעה מישורית: {convert_seconds(SHEIYA)})')
            except IndexError:
                txt2.insert("end", f'\nצאת הכוכבים 4.37°- (3/4 מיל 22.5):     {eror}')
            
            try:
                _,SS,_,_,_,_ = calculate_rising_seting(time,location,location_timezone,horizon=-4.61, body="sun")
                # חישוב הפרש הדקות משקיעה מישורית נראית 0.833 עד צאת הכוכבים
                SHEIYA = (SS - SS_N).total_seconds()
                txt2.insert("end", f'\nצאת הכוכבים 4.61°- (3/4 מיל 24):    {SS:%H:%M:%S}     (דקות משקיעה מישורית: {convert_seconds(SHEIYA)})')
            except IndexError:
                txt2.insert("end", f'\nצאת הכוכבים 4.61°- (3/4 מיל 24):     {eror}')

            try:
                _,SS,_,_,_,_ = calculate_rising_seting(time,location,location_timezone,horizon=-6, body="sun")
                txt2.insert("end", f'\nסוף דמדומים אזרחיים (וצאת כוכבים קטנים) 6°-:    {SS:%H:%M:%S}')
            except IndexError:
                txt2.insert("end", f'\nסוף דמדומים אזרחיים (וצאת כוכבים קטנים) 6°-:     {eror}')

            try:
                _,SS,_,_,_,_ = calculate_rising_seting(time,location,location_timezone,horizon=-8.5, body="sun")
                # חישוב הפרש הדקות משקיעה מישורית נראית 0.833 עד צאת הכוכבים
                SHEIYA = (SS - SS_N).total_seconds()
                txt2.insert("end", f'\nצאת שבת לוחות הגרימ"ט 8.5°-:    {SS:%H:%M:%S}     (דקות משקיעה מישורית: {convert_seconds(SHEIYA)})')
            except IndexError:
                txt2.insert("end", f'\nצאת שבת לוחות הגרימ"ט 8.5°-:     {eror}')

            try:
                _,SS,_,_,_,_ = calculate_rising_seting(time,location,location_timezone,horizon=-12, body="sun")
                txt2.insert("end", f'\nסוף דמדומים ימיים 12°-:    {SS:%H:%M:%S}')
            except IndexError:
                txt2.insert("end", f'\nסוף דמדומים ימיים 12°-:     {eror}')

            try:
                _,SS,_,_,_,SS_az = calculate_rising_seting(time,location,location_timezone,horizon=-14, body="sun")
                txt2.insert("end", f'\nסוף דמדומים נראים (מקביל לרב ניימאן שבבוקר) 14°-:    {SS:%H:%M:%S}    באזימוט:   {SS_az :02.1f}°')
            except IndexError:
                txt2.insert("end", f'\nסוף דמדומים נראים (מקביל לרב ניימאן שבבוקר) 14°-:     {eror}')
                
            try:
                _,SS,_,_,_,_ = calculate_rising_seting(time,location,location_timezone,horizon=-16, body="sun")
                # חישוב הפרש הדקות משקיעה מישורית נראית 0.833 עד צאת הכוכבים
                SHEIYA = (SS - SS_N).total_seconds()
                txt2.insert("end", f'\nצאת הכוכבים רבינו תם 16°- (4 מיל 18):    {SS:%H:%M:%S}     (דקות משקיעה מישורית: {convert_seconds(SHEIYA)})')
            except IndexError:
                txt2.insert("end", f'\nצאת הכוכבים רבינו תם 16°- (4 מיל 18):     {eror}')

            try:
                _,SS,_,_,_,SS_az = calculate_rising_seting(time,location,location_timezone,horizon=-18, body="sun")
                txt2.insert("end", f'\nסוף דמדומים אסטרונומיים 18°-:    {SS:%H:%M:%S}    באזימוט:   {SS_az :02.1f}°')
            except IndexError:
                txt2.insert("end", f'\nסוף דמדומים אסטרונומיים 18°-:     {eror}')

            try:
                _,SS,_,_,_,_ = calculate_rising_seting(time,location,location_timezone,horizon=-19.75, body="sun")
                # חישוב הפרש הדקות משקיעה מישורית נראית 0.833 עד צאת הכוכבים
                SHEIYA = (SS - SS_N).total_seconds()
                txt2.insert("end", f'\nצאת הכוכבים רבינו תם 19.75°- (4 מיל 22.5):    {SS:%H:%M:%S}     (דקות משקיעה מישורית: {convert_seconds(SHEIYA)})')
            except IndexError:
                txt2.insert("end", f'\nצאת הכוכבים רבינו תם 19.75°- (4 מיל 22.5):     {eror}')

            try:
                _,SS,_,_,_,_ = calculate_rising_seting(time,location,location_timezone,horizon=-25.9, body="sun")
                # חישוב הפרש הדקות משקיעה מישורית נראית 0.833 עד צאת הכוכבים
                SHEIYA = (SS - SS_N).total_seconds()
                txt2.insert("end", f'\nצאת הכוכבים רבינו תם 25.9°- (5 מיל 24):    {SS:%H:%M:%S}     (דקות משקיעה מישורית: {convert_seconds(SHEIYA)})')
            except IndexError:
                txt2.insert("end", f'\nצאת הכוכבים רבינו תם 25.9°- (5 מיל 24):     {eror}')

            txt2.insert("end", f'\n\nזמני הירח\n')
            
            MR,MS,_,MR_az,_,_ = calculate_rising_seting(time,location,location_timezone,horizon=0, body="moon",PLUS_MINUS = "PLUS")
            if time.date() == MR.date():
                txt2.insert("end", f'\nזריחת הירח:   {MR:%H:%M:%S}    באזימוט:   {MR_az :02.1f}°')
            else:
                txt2.insert("end", f'\nאין זריחת ירח במיקום גיאוגרפי זה בתאריך לועזי:    {time:%d/%m/%Y}')
            
            MR,MS,_,_,_,MS_az = calculate_rising_seting(time,location,location_timezone,horizon=0, body="moon",PLUS_MINUS = "PLUS")
            if time.date() == MS.date():    
                txt2.insert("end", f'\nשקיעת הירח:   {MS:%H:%M:%S}    באזימוט:   {MS_az :02.1f}°')
            else:
                txt2.insert("end", f'\nאין שקיעת ירח במיקום גיאוגרפי זה בתאריך לועזי:    {time:%d/%m/%Y}')
                
            hitkabzut,nigud = hitkabzut_nigud_calculations(time,location,location_timezone,body="moon",PLUS_MINUS="PLUS",plus_minus_days=50)
            txt2.insert("end", f'\nמולד ירח אמיתי קרוב:    {hitkabzut:%d/%m/%Y}     בשעה   {hitkabzut:%H:%M:%S}')
            txt2.insert("end", f'\nניגוד ירח אמיתי קרוב (ירח מלא):    {nigud:%d/%m/%Y}     בשעה   {nigud:%H:%M:%S}')
            
            txt2.insert("end", f'\n\nתקופות אמיתיות\n')
            
            Vernal_Equinox,Summer_Solstice,Autumnal_Equinox,Winter_Solstice=Real_tkufot(time,location,location_timezone,PLUS_MINUS="PLUS",plus_minus_days=400)
            txt2.insert("end", f'\nשוויון אביב הבא:    {Vernal_Equinox:%d/%m/%Y}     בשעה:   {Vernal_Equinox:%H:%M:%S}')
            txt2.insert("end", f'\nשוויון סתיו הבא:    {Autumnal_Equinox:%d/%m/%Y}     בשעה:   {Autumnal_Equinox:%H:%M:%S}')
            txt2.insert("end", f'\nהיפוך קיץ הבא:    {Summer_Solstice:%d/%m/%Y}     בשעה:   {Summer_Solstice:%H:%M:%S}')
            txt2.insert("end", f'\nהיפוך חורף הבא:    {Winter_Solstice:%d/%m/%Y}     בשעה:   {Winter_Solstice:%H:%M:%S}')
        
            txt2.insert("end", f'\n\n')   

        # במקרה שיש שגיאה בחישוב הזריחות והשקיעות
        except IndexError:
            txt2.insert("end", "\n שגיאה\nעבור המיקום הנוכחי בתאריך הנוכחי\n התוכנה אינה יכולה לחשב זמני זריחות/שקיעות/חצות")
            
        # ===== רוורס לכל הטקסט =====
        full_text = txt2.get("1.0", "end-1c")
        txt2.delete("1.0", "end")
        txt2.insert("1.0", reverse(full_text))
        
        # הגדרת העיצוב של הטקסט בתיבת הטקסט שיהיה ממורכז
        txt2.tag_configure("center", justify='center')
        txt2.tag_add("center", 1.0, "end")

        # סגירת תיבת הטקסט לקריאה בלבד
        txt2.configure(state="disabled")
       
    #########################################################################################################
    
    # פונקצייה משנית להוספת מועדי ראיית תחנת החלל הבינלאומית לקובץ טקסט2
    # נעזרתי בצ'אט גיפיטי בחלקים של מיון האירועים
    # אני מדפיס רק את האירועים שנראים בעין. כלומר: רק אירועים שמתרחשים לאחר השקיעה או לפני הזריחה ורק אירועים שבהם אור השמש פוגע בתחנה
    # האירועים האפשריים הם: זריחה שקיעה ושיא הגובה. זריחה ושקיעה של הלויין מוגדרים רק כשהוא בגובה 10 מעלות 
    # לפעמים בכל זאת לא יראו את הלויין כי הוא בבהירות נראית נמוכה כתלות במרחק שלו

    def txt2_add_iss():
        
        
        '''
        # דברים חשובים לעבודה עם קבצים בסקייפילד

        # הקדמה לצורך הסתמכות על תעודת אבטחה בנטפרי שנמצאת בכונן סי
        import certifi

        def my_where():
            return r'C:\netfree-ca.crt'

        certifi.where = my_where
        #---------------------

        '''
        
        
        # חישוב האם קו הרוחב הגיאוגרפי של המיקום הוא צפוני או דרומי, והדפסת קו הרוחב
        location_lat_N_S = 'צפון' if location.latitude.degrees > 0 else 'דרום'
        location_lat_for_print = f'{abs(round(location.latitude.degrees,4))} {location_lat_N_S}'

        # חישוב האם קו האורך הגיאוגרפי של המיקום הוא מזרח או מערב, והדפסת קו האורך
        location_lon_E_W = 'מערב' if location.longitude.degrees < 0 else 'מזרח'
        location_lon_for_print = f'{abs(round(location.longitude.degrees,4))} {location_lon_E_W}'
        
        # פתיחת תיבת טקסט2 לעריכה ומחיקת כל מה שיש בה
        txt2.configure(state="normal")
        txt2.delete(1.0, END)
    
        # הכנסת נתונים כלליים לתיבת הטקסט
        txt2.insert("end", f'\n רשימת זמנים קרובים להווה - שאפשר לראות בעין את תחנת החלל הבינלאומית\n')
        txt2.insert("end", f'\n התחנה נראית ככוכב הנע במהירות על פני הרקיע')
        txt2.insert("end", f'\n כל ראייה מורכבת משלושה שלבים וכדלהלן')
        txt2.insert("end", f'\n התחלה - בגובה 10 מעלות מהאופק; שיא-גובה התחנה מעל האופק; סיום - בגובה 10 מעלות')
        txt2.insert("end", f'\n שימו לב! כל שלב שכתוב עליו "חשוך" - לא ניתן לראותו')
        txt2.insert("end", f'\n הבהירות אינה מדוייקת ומשמשת להערכה בלבד, וככל שהמספר שלה גבוה - הניראות יורדת\n')
        txt2.insert("end", f'\n---------------------\n')
        txt2.insert("end", f'\n התאריכים חושבו עבור המיקום הבא, בשבעת הימים הסמוכים (לפני ואחרי) להווה, כדלהלן\n')
        
        txt2.insert("end", f'\nתאריך: ({heb_for_print})   {greg_for_print}')
        txt2.insert("end", f'\nשם המקום: {city_for_print}')
        txt2.insert("end", f'\nקו רוחב - {location_lat_for_print}, קו אורך - {location_lon_for_print}, גובה - {int(location.elevation.m)} מטר')
        #txt2.insert("end", f'\n\n')
        txt2.insert("end", f'\n\n---------------------\n')
        
        # אם רוצים שתיבת הטקסט תדעדכן בכותרת לפני שיוכנסו לתוכה התוצאות
        # כרגע אני מעדיף לא להשתמש בזה
        #ws.update()
        #ph_times.update()
        
        #------------------------------------
        # כל הטיפול בקבלת נתונים על המיקום של תחנת החלל
        
        # אפשרות ראשונה: נתונים ידניים על תחנת החלל
        global ts # הצהרה על משתנה גלובלי שמחזיק את סולם הזמן המתוקן של סקייפילד שהכנתי עבור כל התוכנה
        line1 = '1 25544U 98067A   24026.04106847  .00025248  00000+0  44985-3 0  9997'
        line2 = '2 25544  51.6424 304.6603 0005048 131.8734 346.9261 15.49934868436359'
        iss_from_string = EarthSatellite(line1, line2, 'ISS (ZARYA)', ts)

        # אפשרות שנייה: שימוש בקובץ מידע על לויינים
        
        # הנתיב שממנו מורידים את קובץ הלווינים
        stations_url = 'http://celestrak.org/NORAD/elements/stations.txt'
        
        # הנתיב בתיקיית התוכנה שבו צריך להיות קובץ הלווינים
        stations_path = os.path.join(cu_dir_path, "stations.txt")
        
        #############
        # זו הדרך המקורית של סקייפילד להוריד קובץ אבל לא ברור שיכול לשמור במיקום ספציפי
        #print(load.days_old(stations_path))
        #if load.days_old(stations_path) > 7.0:
        #    try:
        #        load.download(stations_url)
        #    except:
        #        pass
        ##############
        
        # אם קובץ הלווינים לא קיים, או אם הוא קיים אך נוצר לפני יותר מ 7 ימים ולכן הוא לא עדכני 
        # כאן השתמשתי ב datetime.now() ובלי בדיקה האם יו.טי.1 כי קובץ הלויינים קיבל תאריך הורדה לפי יו.טי.סי. וגם אין לזה משמעות חישובית
        if not os.path.exists(stations_path) or datetime.now() - datetime.fromtimestamp(os.path.getctime(stations_path)) > timedelta(days=7):
            # ניסיון להוריד קובץ חדש, לשמור אותו בתיקיית התוכנה, ולהשתמש בו
            try:
                # הורדת קובץ לויינים עדכני
                urlretrieve(stations_url, stations_path)
                # טעינת קובץ הלויינים העדכני
                satellites = load.tle_file(stations_path)
                # הגדרת תחנת החלל הבינלאומית
                by_name = {sat.name: sat for sat in satellites}
                iss = by_name['ISS (ZARYA)']
            # במקרה של שגיאה בהורדת הקובץ
            except:
                # אם יש קובץ ישן יש להשתמש בו כי אני מניח שהוא יותר עדכני מהנתונים הידניים
                if os.path.exists(stations_path):
                    # טעינת קובץ הלויינים העדכני
                    satellites = load.tle_file(stations_path)
                    # הגדרת תחנת החלל הבינלאומית
                    by_name = {sat.name: sat for sat in satellites}
                    iss = by_name['ISS (ZARYA)']
                # אם אין קובץ ישן ולא מצליחים להוריד חדש משתמשים בנתונים הידניים על תחנת החלל
                else:
                    iss = iss_from_string

    
        # אם קובץ הלווינים כן קיים - והוא עדכני כי אם לא היה עדכני היה נכנס לאיף הראשון        
        elif os.path.exists(stations_path):
            try:
                # ניסיון טעינת קובץ הלויינים
                satellites = load.tle_file(stations_path)
                # הגדרת תחנת החלל הבינלאומית
                by_name = {sat.name: sat for sat in satellites}
                iss = by_name['ISS (ZARYA)']
            except:
                # אם לא מצליחים להשתמש בקובץ הלויינים - משתמשים בנתונים הידניים על תחנת החלל
                iss = iss_from_string
        
        #------------------------------------
        
        # מכאן והלאה ניסיון חישוב כל הנתונים על החללית
        # ניסיון בגלל שאולי השמש כלל לא מגיעה במיקום זה לגובה 0 מעלות תחת האופק או שהיא כלל לא שוקעת
        try:
                 
            # הגדרה של עכשיו בסקייפילד
            # כרגע אני משאיר את זה כך בלי בדיקה האם יו.טי.1 כי זה לא ממש רלוונטי לעניין תוקף קובץ הלויינים ושבוע קדימה ואחורה
            ts_now = ts.now()
            
            txt2.insert("end", f'\nהמידע על מיקום התחנה לצורך חישוב הנתונים עודכן בתאריך {iss.epoch.utc_datetime():%d/%m/%Y}\n')
            
            # אם המידע על תחנת החלל לא מעודכן מה 14 יום האחרונים יש להוציא הודעה
            days = ts_now - iss.epoch
            if abs(days) > 14:
                txt2.insert("end", f'\nשימו לב! המידע על התחנה לא נכון כי הוא ישן מידי\n')
                txt2.insert("end", f'\n נסו להתחבר לרשת ואז לפתוח מחדש את דוח רשימת ראייות תחנת החלל\n')
                txt2.insert("end", f'\n כמו כן ניתן להוריד קובץ נתונים עדכני מהכתובת הבאה ולשים אותו בתיקיית כוכבים וזמנים\n')
                txt2.insert("end", f'\n {stations_url}\n\n')
                
            txt2.insert("end", f'\n********************************************************************************************\n')
            
            # חיפוש אירועים של החללית מהיום. רק אירועים שבין 7 ימים אחורה מהרגע לבין 7 ימים קדימה מהרגע
            t, events = iss.find_events(location, ts_now-7, ts_now+7, altitude_degrees=10.0)
            
            # שמות עבור סוגי האירועים
            event_names = 'התחלה', 'שיא-גובה', 'סיום'

            # יצירת מערך ראשי לשמירת כל האירועים
            data_array = []            
            
            # תחילת מיון הנתונים
            for i in range(0, len(t+1), 3):
                group = events[i:i+3]
                group_times = [ti for ti in t[i:i+3]]

                # יצירת תת-מערך לכל סוג אירוע
                event_data = []

                for ti, event, in zip(t[i:i+3], group):
                    # הגדרה שמחזירה טרו כשהחללית נמצאת במקום שהשמש מאירה עליה
                    is_sunlit = iss.at(ti).is_sunlit(eph)
                    #is_sunlit = "מואר" if sunlit_flag else "חשוך"
                    # הגדרת סוג האירוע האם זה זריחה מעל 10 מעלות או שיא הגובה או שקיעה מעל 10 מעלות
                    event_name = event_names[event]
                    local_time = skyfield_to_cu_time(ti, location_timezone)
                    # בדיקת אזימוט וגובה החללית טופוצנטרי. בחללית לא משתמשים באובסרב ובאפרנט
                    iss_topocentric = (iss - location).at(ti)
                    alt, az, distance = iss_topocentric.altaz()
                    # בדיקת אזימוט וגובה השמש טופוצנטרי בשעת האירוע הלוויני
                    # השמש כפי שנראה/נמדד ממיקום הצופה
                    sun_topocentric = (eph['earth'] + location).at(ti).observe(eph['sun']).apparent()
                    sun_alt, sun_az, _ = sun_topocentric.altaz()
                    magnitude = "לא ידוע"
                    
                    
                    # ניסיון חישוב מגניטודה של תחנת החלל
                    # זה לא תואם לבהירות כפי שבאתר https://www.heavens-above.com/ ואולי הבעיה בחישוב הזוית שמש-ירח-צופה
                    # ראו https://github.com/skyfielders/python-skyfield/issues/936
                    distance_to_satellite = distance.km  # This is in KM
                    iss_phase_angle = eph['earth'].at(ti).observe(eph['earth'] + iss).apparent().phase_angle(eph['sun'])
                    pa = iss_phase_angle.radians  # Convert the phase angle to radians
                    intrinsic_magnitude = -1.8  # -1.8 is std. mag for iss
                    term_1 = intrinsic_magnitude
                    term_2 = 5.0 * math.log10(distance_to_satellite / 1000.0)
                    arg = math.sin(pa) + (math.pi - pa) * math.cos(pa)
                    term_3 = -2.5 * math.log10(arg)
                    apparent_magnitude = term_1 + term_2 + term_3
                    magnitude = apparent_magnitude
                    

                    # יצירת מילון שמכיל את כל הנתונים והוספתו לתוך תת-המערך
                    data_entry = {"event": event, "event_name": event_name, "local_time": local_time, "is_sunlit": is_sunlit, "alt": alt.degrees, "az": az.degrees, "sun_alt": sun_alt.degrees, "sun_az" : sun_az.degrees, "magnitude": magnitude}
                    event_data.append(data_entry)

                # הוספת התת-מערך למערך הכללי
                data_array.append(event_data)

                
            # מיון כלל האירועים לשני מערכים נפרדים שהוגדרו למעלה: אחד מכיל את האירועים שהתרחשו בעבר והשני את האירועים שיתרחשו בעתיד. מיון האירועים נעשה לפי שעת זריחת הלווין
            # מערך ריק שיכיל רק את האירועים הנראים הבאים
            arr_next_visible_events = []
            # מערך ריק שיכיל רק את האירועים הנראים הקודמים
            arr_last_visible_events = []
            # הגדרה של הרגע הנוכחי
            #datetime_now = skyfield_to_cu_time(ts.now(), location_timezone)
            datetime_now = datetime.now().astimezone(location_timezone)
            # מעבר על כל הנתונים ומיונם. אם זריחת הלווין היא לפני עכשיו הכל מוכנס למערך של עבר ובכל מקרה אחר מוכנס למערך של עתיד
            for i in range(len(data_array)):
                if data_array[i][0]["local_time"] < datetime_now:
                    arr_last_visible_events.append(data_array[i])
                else:
                    arr_next_visible_events.append(data_array[i])
        
            txt2.insert("end", f'\n### רשימת אירועים עתידיים שיתרחשו בשבעת הימים הבאים ###\n\n\n')
            
            # אם ברשימת האירועים העתידיים יש אירועים יש להדפיסם. אם אין אירועים יש להדפיס הודעה שאין אירועים
            if len(arr_next_visible_events) >= 1:
                
                for events_list in arr_next_visible_events:  # עובר על כל רשימה במערך העתידי
                    # בודק אם יש לפחות אירוע אחד שעונה על התנאים שמאפשרים ראייה: גובה שמש קטן ממינוס ארבע מעלות (כדי שיהיה חושך מינימלי) והשמש מאירה על החללית
                    if any(event['sun_alt'] <= -4 and event['is_sunlit'] for event in events_list):
                        # הדפס את הפרטים של כל האירועים ברשימה
                        for event in events_list:
                            # הדפסת התאריך המתאים עבור שלושת האירועים רק אם האירוע הוא זריחה כדי שהתאריך לא יודפס שלוש פעמים
                            if event["event"] == 0:
                                txt2.insert("end", f"בתאריך {event['local_time']:%d/%m/%Y}\n")
                            # שאר הנתונים מודפסים עבור כל אירוע
                            txt2.insert("end", f"{event['event_name']} ({round(event['alt'])}°, {'מואר' if event['is_sunlit'] else 'חשוך'}) - בשעה {event['local_time']:%H:%M:%S}; באזימוט {round(event['az'])}° ({get_side_name(event['az'])}); בהירות {round(event['magnitude'],1)}")
                            txt2.insert("end", f'\n')  # ירידת שורה בין האירועים
                        txt2.insert("end", f'\n\n')  # שורה ריווח בין אירועים שבימים שונים

            else:
                txt2.insert("end", f'\nאין אירועים עתידיים שיתרחשו בשבעת הימים הבאים\n\n')
                
            txt2.insert("end", f'---------------------\n')
            
            txt2.insert("end", f'\n### רשימת אירועי עבר שהתרחשו בשבעת הימים האחרונים ###\n\n\n')
            
            # אם ברשימת האירועים שקרו בעבר יש אירועים - יש להדפיסם. אם אין אירועים יש להדפיס הודעה שאין אירועים
            if len(arr_last_visible_events) >= 1:
                
                for events_list in arr_last_visible_events:  # עובר על כל רשימה במערך של אירועי העבר
                    # בודק אם יש לפחות אירוע אחד שעונה על התנאים שמאפשרים ראייה: גובה שמש קטן ממינוס ארבע מעלות (כדי שיהיה חושך מינימלי) והשמש מאירה על החללית
                    if any(event['sun_alt'] <= -4 and event['is_sunlit'] for event in events_list):
                        # הדפס את הפרטים של כל האירועים ברשימה
                        for event in events_list:
                            # הדפסת התאריך המתאים עבור שלושת האירועים רק אם האירוע הוא זריחה כדי שהתאריך לא יודפס שלוש פעמים
                            if event["event"] == 0:
                                txt2.insert("end", f"בתאריך {event['local_time']:%d/%m/%Y}\n")
                            # שאר הנתונים מודפסים עבור כל אירוע
                            txt2.insert("end", f"{event['event_name']} ({round(event['alt'])}°, {'מואר' if event['is_sunlit'] else 'חשוך'}) - בשעה {event['local_time']:%H:%M:%S}; באזימוט {round(event['az'])}° ({get_side_name(event['az'])}); בהירות {round(event['magnitude'],1)}")
                            txt2.insert("end", f'\n')  # ירידת שורה בין האירועים
                        txt2.insert("end", f'\n\n')  # שורה ריווח בין אירועים שבימים שונים
                
            else:
                txt2.insert("end", f'\nאין אירועי עבר שהתרחשו בשבעת הימים האחרונים\n\n')


        # במקרה שיש שגיאה בחישוב הזריחות והשקיעות
        except IndexError:
            txt2.insert("end", "\n\n !שגיאה בניסיון חישוב הנתונים של ראיות תחנת החלל הבינלאומית")
        
        # ===== רוורס לכל הטקסט =====
        full_text = txt2.get("1.0", "end-1c")
        txt2.delete("1.0", "end")
        txt2.insert("1.0", reverse(full_text))
        
        # הגדרת העיצוב של הטקסט בתיבת הטקסט שיהיה ממורכז
        txt2.tag_configure("center", justify='center')
        txt2.tag_add("center", 1.0, "end")

        # סגירת תיבת הטקסט לקריאה בלבד
        txt2.configure(state="disabled")
       
    
    #####################################################################################
    
    
    # פונקצייה משנית להוספת כוכבי השבת הראשונים אחרי השקיעה בערב/האחרונים לפני הזריחה בבוקר לקובץ טקסט2
    # כברירת מחדל: מחושבים כוכבי השבת הראשונים לאחר השקיעה בערב
    def txt2_add_stars(which = "evening"):
        
        
        '''
        # דברים חשובים לעבודה עם כוכבי שבת בסקייפילד

        # הקדמה לצורך הסתמכות על תעודת אבטחה בנטפרי שנמצאת בכונן סי
        import certifi

        def my_where():
            return r'C:\netfree-ca.crt'

        certifi.where = my_where
        #---------------------

        from skyfield.api import Star, load
        from skyfield.data import hipparcos

        # ייבוא כל הכוכבים שברשימה לתוך פנדס דאטאפריים
        with load.open(hipparcos.URL) as f:
            df = hipparcos.load_dataframe(f)

        # סינון הכוכבים עד גודל 2 
        df = df[df['magnitude'] <= 2.0]

        # ייצוא הכוכבים שנשארו לקובץ סי אס וי
        df.to_csv("stars.csv", sep=',', encoding="cp1255")

        # רשימת מספרי היפרכוס של כוכבים חשובים
        Sirius = Star.from_dataframe(df.loc[32349])
        '''
        
        
        # חישוב האם קו הרוחב הגיאוגרפי של המיקום הוא צפוני או דרומי, והדפסת קו הרוחב
        location_lat_N_S = 'צפון' if location.latitude.degrees > 0 else 'דרום'
        location_lat_for_print = f'{abs(round(location.latitude.degrees,4))} {location_lat_N_S}'

        # חישוב האם קו האורך הגיאוגרפי של המיקום הוא מזרח או מערב, והדפסת קו האורך
        location_lon_E_W = 'מערב' if location.longitude.degrees < 0 else 'מזרח'
        location_lon_for_print = f'{abs(round(location.longitude.degrees,4))} {location_lon_E_W}'
        
        # פתיחת תיבת טקסט2 לעריכה ומחיקת כל מה שיש בה
        txt2.configure(state="normal")
        txt2.delete(1.0, END)
    
        # הכנסת נתונים כלליים לתיבת הטקסט
        txt2.insert("end", f'\nשימו לב! ההגדרות עבור הבוקר הם היפוך מההגדרות שנאמרו בעֵרֶב, ונועדו רק לתרגול הראִייה\n')
        
        txt2.insert("end", f'\nרשימת כוכבי שֶׁבֶת {"ראשונים" if which == "evening" else "אחרונים"} הנראים {"לאחר השקיעה" if which == "evening" else "לפני הזריחה"} בתאריך ובמיקום הבאים\nבשעה שהשמש בגובה 4 מעלות תחת האופק\n')
        
        
        txt2.insert("end", f'\nתאריך: ({heb_for_print})   {greg_for_print}')
        txt2.insert("end", f'\nשם המקום: {city_for_print}')
        txt2.insert("end", f'\nקו רוחב - {location_lat_for_print}, קו אורך - {location_lon_for_print}, גובה - {int(location.elevation.m)} מטר')

        # ניסיון בגלל שאולי השמש כלל לא מגיעה במיקום זה לגובה 4 מעלות תחת האופק או שהיא כלל לא שוקעת
        try:
            
            # קבלת נתוני הכוכבים מקובץ סי אס וי באמצעות פונקצייה שהגדרתי למעלה
            stars = get_stars(stars_path,cu_dir_path)
            
            # חישוב שעת ואזימוט זריחה ושקיעה מישוריים
            SR_N,SS_N,_,SR_N_az,_,SS_N_az = calculate_rising_seting(time,location,location_timezone,horizon=-0.833, body="sun")
            
            # חישוב השעה והאזימוט שהשמש בגובה 4 מעלות תחת האופק
            SR_4,SS_4,_,SR_4_az,_,SS_4_az = calculate_rising_seting(time,location,location_timezone,horizon=-4, body="sun")

            # המרת הזמן שהשמש בגובה 4 מעלות תחת האופק לזמן של סקייפילד לצורך חישוב נתונים אסטרונומיים של הכוכב על זמן זה
            SS_OR_SR_4_skyfield_time = cu_to_skyfield_time(SS_4 if which == "evening" else SR_4)
            
            txt2.insert("end", f'\n\n---------------------\n')
            txt2.insert("end", f'\nשימו לב! ככל שמִסְפָּר הבהירות *נמוך* יותר, הבהירות הנראית *גבוהה* יותר')
            txt2.insert("end", f"\nשימו לב! בהירות ביטלג'וז ו-אנטארס אינה קבועה, ועשויה להיות שונה מהדרגה הרשומה")
            txt2.insert("end", f"\nהכוכבים: ארקטורוס, ביטלג'וז ו-אנטארס הם בצבע אדום\n")

            txt2.insert("end", f'\nשימו לב! לעיתים *סיריוס* נראה גם {"לפני השקיעה" if which == "evening" else "לאחר הזריחה"}. *אין* לצרפו למניין שלוש הכוכבים')
            txt2.insert("end", f'\nשלוש הכוכבים שבחגורת הצייד (אלנילם-אלניטק-מינטקה) הם כוכבים קטנים רצופים\n')
            txt2.insert("end", f'\n---------------------\n')
            
            
            # חישוב השפעת גובה העיר במקרה שהעיר גבוהה או נמוכה
            #if location.elevation.m != 0:
            #    Z = calculate_elevation_rise_set(location.elevation.m)
            #    SR,SS,_,_,_,_ = calculate_rising_seting(time,location,location_timezone,horizon=Z, body="sun")
            #    txt2.insert("end", f'\nכשאין הסתרות!! בערך שקיעה נראית בגובה העיר {str(round(Z,2))[1:]}°:    {SS:%H:%M:%S}')
  
             
            
            if which == "evening":
                # חישוב הפרש הדקות משקיעה מישורית נראית 0.833 עד שמש בגובה מינוס 4
                SHEIYA = (SS_4 - SS_N).total_seconds()
                txt2.insert("end", f'\nשקיעה נראית במישור (0.833°-):    {SS_N :%H:%M:%S}      באזימוט:   {SS_N_az :02.1f}°')
                txt2.insert("end", f'\nדקות שיחלפו בתאריך ובמיקום הנוכחיים, מהשקיעה עד שהשמש תרד לגובה 4°-:   {convert_seconds(SHEIYA)}   דקות')
                txt2.insert("end", f'\n\nהשמש נמצאת בגובה מינוס 4 מעלות בשעה:     {SS_4 :%H:%M:%S}      באזימוט:   {SS_4_az :02.1f}°')
                txt2.insert("end", f'\n\nהסתלקות! האדמימות !במזרח! --- האזימוט שנמצא בדיוק מול השמש בזמן זה הוא:     {SS_4_az - 180 :02.1f}°')
            
            else:
                # חישוב הפרש הדקות משעה שהשמש בגובה מינוס 4 עד זריחה מישורית נראית 0.833
                SHEIYA = (SR_N - SR_4).total_seconds()
                txt2.insert("end", f'\nזריחה נראית במישור (0.833°-):    {SR_N :%H:%M:%S}      באזימוט:   {SR_N_az :02.1f}°')
                txt2.insert("end", f'\nדקות שיחלפו בתאריך ובמיקום הנוכחיים, משעה שהשמש בגובה 4°- עד הזריחה:   {convert_seconds(SHEIYA)}   דקות')
                txt2.insert("end", f'\n\nהשמש נמצאת בגובה מינוס 4 מעלות בשעה:     {SR_4 :%H:%M:%S}      באזימוט:   {SR_4_az :02.1f}°')
                txt2.insert("end", f'\n\nהתחלת! האדמימות !במערב! --- האזימוט שנמצא בדיוק מול השמש בזמן זה הוא:     {SR_4_az + 180 :02.1f}°')
            
            txt2.insert("end", f'\n\nלהלן הכוכבים שגובהם בזמן זה מעל 20 מעלות\nאו שהם {"במערב" if which == "evening" else "במזרח"} המואר (= 45 מעלות מכל צד של אזימוט השמש) - וגובהם מעל 50 מעלות\n')

            # משתנה שמגדיר איזה מעלות זה מבחינתי הצד המערבי/המזרחי שמואר בפועל בגלל השמש, לצורך שימוש להלן
            # מערב/מזרח הוא תמיד 90 מעלות: 45 מעלות מימין אזימוט השקיעה/הזריחה של מינוס 4 מעלות ו- 45 מעלות משמאל אזימוט השקיעה/הזריחה של מינוס 4 מעלות
            bright_sky_area = range(int(SS_4_az)-45,int(SS_4_az)+46) if which == "evening" else range(int(SR_4_az)-45,int(SR_4_az)+46)
            
            #red_east = range(int(SS_4_az-180)-45,int(SS_4_az-180)+46)
            

            for i in range(len(stars)):

                # הגדרות משתנים נפרדים לכוכב, לשמו, ולבהירותו
                body = stars[i]["skyfield Star"]
                name = stars[i]["name_he"] if is_heb_locale else stars[i]["name_en"]
                brightness = stars[i]["magnitude"]

                # הכוכבים שייחשבו ברשימה זו הם רק אלו שהבהירות שלהם קטנה מ 1.5 וגם הכוכב אלנילם שבחגורת הצייד מפני שהוא קטן רצוף
                if brightness <= 1.5 or name == "אַלְנִילַם (ח-צייד)":

                    # הפעלת הפונקצייה שמחשבת את כל הנתונים על הגוף המוגדר כעת שזה כוכב שבת בשעה שהשמש בגובה מינוס 4
                    alt,az,ra,dec,ha,dec_N_S,lat,lon,dist,lat_N_S,percent,apparent_diameter,thickness,_,elongation,ecliptic_elongation,elongation_E_W,_,_ = astro_calculations(body,SS_OR_SR_4_skyfield_time,location,location_timezone,body_type = "STAR")
                    
                    #print("name",name,"az in bright_sky_area",int(az) in bright_sky_area )
                    
                    # אם הגובה של הכוכב יותר מ-20 מעלות והוא לא נמצא בצד השמיים המואר, או אם הוא בצד השמיים המואר אבל בגובה 50 מעלות ומעלה
                    # חייבים להשתמש באינט על האזימוט כי הריינג' של האיזור המואר של הרקיע הוא במספרים שלמים. אחרת מתקבלת טעות
                    if (int(az) not in bright_sky_area and alt >= 20) or (alt >= 50):
                        txt2.insert("end", f'\n\n{name}          בהירות: {brightness}          גובה: {alt: 02.2f}°          אזימוט: {az: 02.1f}°')
                    else:
                        pass
                        '''
                        if alt < 0:
                            txt2.insert("end", f'\n\n{name} נמצא מתחת האופק ולכן אינו מחושב')
                        elif int(az) in bright_sky_area and alt < 50:
                            txt2.insert("end", f'\n\n{name} נמצא {"במערב" if which == "evening" else "במזרח"} המואר בגובה נמוך מ-60 מעלות ולכן אינו מחושב')
                        elif int(az) not in bright_sky_area and alt < 20:
                            txt2.insert("end", f'\n\n{name} אינו מחושב כי גובהו פחות מ-20 מעלות')
                        '''

        # במקרה שיש שגיאה בחישוב הזריחות והשקיעות
        except IndexError:
            txt2.insert("end", "\n\n ! שגיאה בחישוב השקיעה !\n\n במיקום ובתאריך שהוגדרו, השמש לא יורדת לגובה 4 מעלות תחת האופק")
        
        
        # ===== רוורס לכל הטקסט =====
        full_text = txt2.get("1.0", "end-1c")
        txt2.delete("1.0", "end")
        txt2.insert("1.0", reverse(full_text))   
        
        # הגדרת העיצוב של הטקסט בתיבת הטקסט שיהיה ממורכז
        txt2.tag_configure("center", justify='center')
        txt2.tag_add("center", 1.0, "end")

        # סגירת תיבת הטקסט לקריאה בלבד
        txt2.configure(state="disabled")
       
    ############################################################################################################
    
    # פונקצייה משנית להוספת ירח חדש לקובץ טקסט2
    def txt2_add_new_moon(month = "PLUS"):
        
        # דבר ראשון, הגדרת פונקצייה משנית משנית של הדפסות עבור כל נתוני הירח
        # משתנה עבור יום בדיקת הראייה, ומשתנה התקבצות זה כדי לבדוק כמה שעות עברו מהמולד
        def print_all_about_first_moon (moon_search_day, hitkabzut):
            
            # החלק העליון של התוכנה פועל תמיד, אבל החלק שתלוי בחישובי זריחה ושקיעה לא פועל במקום שאין בו זריחה ושקיעה בכל יום כגון באיזור הקוטב הצפוני
            try:

                # חישוב שעת שקיעה גיאומטרית הראשונה של הירח הבא לאחר שעת המולד: התוצאה תהיה יום ראשון לחישוב אפשרות הראייה
                MR,MS,MR_alt,MR_az,MS_alt,MS_az = calculate_rising_seting(moon_search_day,location,location_timezone,horizon= 0, body="moon",PLUS_MINUS = "PLUS")
                
                # קביעת משתנה ששומר מהו התאריך הלועזי של יום ראשון לחישוב אפשרות הראייה לצורך ריטרן בסוף עבור חיפוש היום הבא
                sight_day_greg = MS
                
                # חישוב שעת שקיעה גיאומטרית של השמש בתאריך שבו הירח שוקע לראשונה לאחר המולד
                # הדגשה: חישוב כללי של זריחה ושקיעה ביום זה, ולא חישוב של שקיעה הבאה
                SR,SS,SR_alt,SR_az,SS_alt,SS_az = calculate_rising_seting(MS,location,location_timezone,horizon= 0, body="sun",PLUS_MINUS = "NONE")
                
                # חישובי תאריך עברי של יום הראייה שבינתיים הוא השקיעה הבאה הראשונה לאחר המולד 
                sight_day_heb = dates.GregorianDate(1880, 10, 20).from_pydate(MS).to_heb()
                sight_day_heb_for_print = f'{heb_string_day(sight_day_heb.weekday())} - {sight_day_heb.hebrew_date_string(True)}'
                
                # המרת זמן השקיעה הגיאומטרית של השמש ביום הראייה לזמן של סקייפילד וחישוב גובה ואזימוט של הירח על זמן זה
                # חשוב לחשב זאת בשלב זה לפני הבדיקה האם שקיעת הירח היא לאחר שקיעת השמש, כי המידע הזה דרוש למקרה ששקיעת הירח אכן לפני שקיעת השמש
                SS_skyfield_time = cu_to_skyfield_time(SS)
                malt, maz, _ = (eph['earth'] + location).at(SS_skyfield_time).observe(eph['moon']).apparent().altaz()
                
                # תאריך החישובים 
                txt2.insert("end", f'\nהתאריך עבורו בוצעו חישובי ראייה ראשונה')
                txt2.insert("end", f'\n\n{MS:%d/%m/%Y}  ({sight_day_heb_for_print})')
                  
                # רק במקרה שהירח אכן שוקע אחרי השמש ביום זה, יש לחשב את נותני הירח ולהוסיפת לטקסט
                if MS > SS:

                    SHEIYA = (MS - SS).total_seconds() / 60
                    KESHET_REIYA = SHEIYA / 4
                    
                    # חישוב שעת הראייה לפי 0.6 של השהייה בין השקיעות הגיאומטריות
                    time_of_vision = SS + timedelta(seconds = (MS - SS).total_seconds() * 0.6)
                    
                    # גיל הירח בשעות מהמולד האמיתי עד שעת הראייה
                    AGE = time_of_vision - hitkabzut
                    AGE = (AGE.days * 24) + ((AGE.total_seconds() / 60) / 60)
                    
                    # המרת הזמן המקומי לזמן של סקייפילד וחישוב כל נתונים אסטרונומיים של הירח על זמן זה
                    time_ov = cu_to_skyfield_time(time_of_vision)
                    alt,az,ra,dec,ha,dec_N_S,lat,lon,dist,lat_N_S,percent,apparent_diameter,thickness,slon,elongation,ecliptic_elongation,elongation_E_W,salt,saz = astro_calculations("moon",time_ov,location,location_timezone)
                    
                    
                    # קריטריון הראייה של הופמן

                    # שורש ריבועי מייצגים בפייתון כך
                    # ** (0.5)))
                    # מקדם קלות הראייה לפי הופמן מורכב מהפרש רומים בין השמש לירח בשעת הראייה שזה 0.6 של השהייה יחד עם השורש של עובי סהר הירח
                    # הנוסחה היא: הפרשי הגובה בין השמש לירח, פלוס 7.37, כפול שורש עובי הסהר 
                    vision_factor = abs(alt-salt) + (7.37 * (thickness ** (0.5))) 
                    # אבל הפרשי הגובה הם בין מרכז השמש לבין מרכז הירח ואילו מרכז הסהר נמוך ממרכז הירח לכן ניתן להוסיף להפרשי הגובה עוד רבע מהקוטר הזוויתי הנראה של הירח כדלהלן
                    #vision_factor = (abs(alt-salt) + (apparent_diameter / 4 / 60)) + (7.37 * (thickness ** (0.5))) 
                    
                    # נרמול של מקדם הראייה הופמן כך שאפס פירושו שאין ראייה בעיין כלל ואחד פירושו שיש ראייה ודאית בעיין ובין אפס לאחד זה טווח אי הוודאות
                    normal_vision_factor = (vision_factor - 12.2) / 5.2 
                    
                    txt2.insert("end", f'\n\n\nתקציר אפשרות ראיית הירח ביום זה על פי מקדם קלות הראייה של הופמן')
                    if normal_vision_factor <= -0.7:
                        txt2.insert("end", f'\n\n\nערך מקדם: {normal_vision_factor :02.2f}; הירח לא ייראה ביום זה - אפילו במשקפת')
                    elif normal_vision_factor > -0.7 and normal_vision_factor < 0:
                        txt2.insert("end", f'\n\nערך מקדם: {normal_vision_factor :02.2f}; תיתכן ראייה בעזרת משקפת או טלסקופ בלבד')
                    elif normal_vision_factor >= 0 and normal_vision_factor < 0.5:
                        txt2.insert("end", f'\n\nערך מקדם: {normal_vision_factor :02.2f}; תיתכן ראייה בעין - בקושי רב!')
                    elif normal_vision_factor >= 0.5 and normal_vision_factor < 1:
                        txt2.insert("end", f'\n\nערך מקדם: {normal_vision_factor :02.2f}; הירח צפוי להיראות בעין - ייתכן קושי')
                    elif normal_vision_factor >= 1:
                        txt2.insert("end", f'\n\nערך מקדם: {normal_vision_factor :02.2f}; ראייה קלה בעין - כשאין עננים')
                        
                    
                    txt2.insert("end", f'\n\n\nפירוט הנתונים')
                    txt2.insert("end", f'\nשקיעת השמש (גיאומטרית) בשעה:    {SS:%H:%M:%S}    באזימוט:  {SS_az :02.1f}°')
                    txt2.insert("end", f'\nבשעה זו הירח נמצא בגובה:    {malt.degrees :02.2f}°    באזימוט:    {maz.degrees :02.1f}°')
                    txt2.insert("end", f'\n\nשקיעת הירח (גיאומטרית) בשעה:    {MS:%H:%M:%S}    באזימוט:  {MS_az :02.1f}°')
                    txt2.insert("end", f'\nשְׁהִיָיה - הפרש דקות בין השקיעות הגיאומטריות:    {SHEIYA :02.2f}') 
                    
                    txt2.insert("end", f'\n\nשעת הראייה המיטבית ליום זה לפי הופמן (0.6 של השְׁהִיָיה):    {time_of_vision:%H:%M:%S}')
                    txt2.insert("end", f'\nבשעת הראייה הירח נמצא בגובה:    {alt :02.2f}°    באזימוט:    {az :02.1f}°')
                    txt2.insert("end", f'\nבשעת הראייה השמש נמצאת בגובה:    {salt :02.2f}°    באזימוט:    {saz :02.1f}°')
                    
                    txt2.insert("end", f'\nהפרשי שמש-ירח בשעת הראייה; גובה:    {abs(alt-salt) :02.2f}°    אזימוט:    {abs(az-saz) :02.1f}°')  
                    
                    #txt2.insert("end", f'\nקוטר נראה של כל הירח, בדקות קשת, בשעת הראייה:    {apparent_diameter :02.2f}')
                    
                    txt2.insert("end", f'\nעובי סהר הירח, בדקות קשת, בשעת הראייה:    {thickness :02.2f}')
                    
                    
                    #txt2.insert("end", f'\nמקדם קלות הראייה קריטריון הופמן רום-סהר לשעת הראייה:    {vision_factor :02.2f}')
                    txt2.insert("end", f'\nמקדם קלות הראייה הופמן רום-סהר לשעת הראייה - מנורמל:    {normal_vision_factor :02.2f}')
                    
                    txt2.insert("end", f'\n\nמספר השעות שחלפו מהמולד האמיתי עד שעת הראייה:    {AGE :02.2f}')
                    txt2.insert("end", f'\nאחוזי התאורה של הירח בשעת הראייה:    {percent :02.2f}')            
                    txt2.insert("end", f'\nמרחק הירח מכדור הארץ, בקילומטרים, בשעת הראייה:    {dist :,.1f}')
                       
                    
                    # חישובי ראיית הירח לפי שיטת הרמב"ם
                    # חישוב שעת הראייה של הרמב"ם: שעה שהשמש בגובה 4 מעלות תחת האופק בתאריך שבו הירח שוקע לראשונה לאחר המולד
                    # הדגשה: חישוב כללי של זריחה ושקיעה ביום זה, ולא חישוב של שקיעה הבאה
                    _,SS4,_,_,_,_ = calculate_rising_seting(MS,location,location_timezone,horizon= -4, body="sun",PLUS_MINUS = "NONE")
                    
                    # המרת הזמן המקומי לזמן של סקייפילד וחישוב כל נתונים אסטרונומיים של הירח על זמן זה
                    time_ov_SS4 = cu_to_skyfield_time(SS4)
                    alt,az,ra,dec,ha,dec_N_S,lat,lon,dist,lat_N_S,percent,apparent_diameter,thickness,slon,elongation,ecliptic_elongation,elongation_E_W,salt,saz = astro_calculations("moon",time_ov_SS4,location,location_timezone)
                    ORECH_RISHON = ecliptic_elongation
                    KITSEI_REIYA = int(ORECH_RISHON) + KESHET_REIYA
                    
                    # הגדרת אורך ראשון המינמלי הדרוש לראיית הירח לפי שיטת הרמב"ם
                    Required_ORECH_RISHON = 9 if lon >270 or lon <90 else 10
                    
                    txt2.insert("end", f'\n\n--------------')
                    
                    txt2.insert("end", f'\n\nנתוני ראיית הירח לשיטת הרמב"ם בהלכות קידוש החודש')
                    
                    txt2.insert("end", f'\n[קריטריון: אורך ראשון מעל 9 או 10 (תלוי בעונה) וקיצי ראייה מעל 22]')
                    
                    txt2.insert("end", f'\n\n\nתקציר אפשרות ראיית הירח ביום זה על פי קריטריון הרמב"ם')
                    
                    # היתכנות ראייה לפי קשת ראייה (הלכות קידוש החודש פרק יז, הלכות טו-טז)
                    # if KESHET_REIYA > 9 and KITSEI_REIYA > 22:
                    
                    # היתכנות ראייה לפי אורך ראשון (הלכות קידוש החודש פרק יז, הלכות ג-ד)
                    # וראו מאמרו של לווינגר: חיזוי הראייה
                    if ORECH_RISHON > Required_ORECH_RISHON and KITSEI_REIYA > 22:
                        txt2.insert("end", f'\n\nקיצי הראייה: {KITSEI_REIYA :02.2f}°; לפי קריטריון הרמב"ם: הירח ייראה ביום זה')
                    else:
                        txt2.insert("end", f'\n\nקיצי הראייה: {KITSEI_REIYA :02.2f}°; לפי קריטריון הרמב"ם: הירח !לא! ייראה ביום זה')
                    
                    txt2.insert("end", f'\n\n\nפירוט הנתונים')
                    txt2.insert("end", f'\n\nשעת הראייה של הרמב"ם: כמו שליש שעה לאחר השקיעה הגיאומטרית')
                    txt2.insert("end", f'\nגובה השמש בזמן זה בממוצע שנתי בארץ ישראל: 4 מעלות תחת האופק')
                    txt2.insert("end", f'\nשעת הראייה של הרמב"ם ליום זה (שמש בגובה מינוס 4 מעלות):    {SS4:%H:%M:%S}')
                    txt2.insert("end", f'\nבשעת הראייה של הרמב"ם, הירח נמצא בגובה:    {alt :02.2f}°    באזימוט:    {az :02.1f}°')
                    txt2.insert("end", f'\nנתוני השמש על המלקה בשעת הראייה של הרמב"ם; אורך:    {slon :02.2f}°    רוחב:    {(0.0) :02.2f}°')     
                    txt2.insert("end", f'\nנתוני הירח על המלקה בשעת הראייה של הרמב"ם; אורך:    {lon :02.2f}°    רוחב:    {lat :02.2f}° {lat_N_S}')
                    txt2.insert("end", f'\nאלונגציה אמיתית בין השמש והירח בשעת הראייה של הרמב"ם:    {elongation :02.2f}°')
                    txt2.insert("end", f'\nאורך ראשון - אלונגציה על המלקה בשעת הראייה של הרמב"ם:    {ORECH_RISHON :02.2f}°')
                    txt2.insert("end", f'\nקשת ראייה - המרת השְׁהִיָיה למעלות (4 דקות לכל מעלה):    {KESHET_REIYA :02.2f}°')
                    txt2.insert("end", f'\nסכום קיצי הראייה - האורך הראשון וקשת הראייה יחד : {KITSEI_REIYA :02.2f}°')
                    
                    if normal_vision_factor < 1.0:
                        txt2.insert("end", f'\n\n\nשימו לב! מקדם קלות הראייה המנורמל קטן מ-1')
                        txt2.insert("end", f'\nלפיכך מובאים להלן נתונים גם עבור היום הבא')
                        
                else:
                    # הגדרת מקדם הראייה המנורמל על ערך פחות מ-1 כדי שיחושבו הערכים עבור היום הבא
                    normal_vision_factor = -10
                    txt2.insert("end", f'\n\nשקיעת השמש (גיאומטרית) בשעה:    {SS:%H:%M:%S}    באזימוט:  {SS_az :02.1f}°')
                    txt2.insert("end", f'\nבשעה זו הירח נמצא בגובה:    {malt.degrees :02.2f}°    באזימוט:    {maz.degrees :02.1f}°')
                    txt2.insert("end", f'\nשקיעת הירח (גיאומטרית) בשעה:    {MS:%H:%M:%S}    באזימוט:  {MS_az :02.1f}°')
                    # מקרה כזה ייתכן כשרוחב הירח גדול ובאיזור גאגרפי מתאים כגון בארץ ישראל ראש חודש כסלו ה'תשפ"ד
                    txt2.insert("end", f'\n\nשימו לב! למרות שהמולד כבר עבר, הירח עדיין שוקע לפני השמש ביום זה')
                    txt2.insert("end", f'\nהירח בלתי ניתן לצפייה ביום זה, ולפיכך מובאים להלן נתונים עבור היום הבא')
            
            
            # במקרה שיש שגיאה בחישוב הזריחות והשקיעות
            except IndexError:
                txt2.insert("end", "\n ! שגיאה !\nעבור המיקום הנוכחי בתאריך הנוכחי התוכנה אינה יכולה לחשב זמני שקיעות")
                sight_day_greg = "NONE"
                normal_vision_factor = "NONE"

            txt2.insert("end", f'\n\n')

            return sight_day_greg, normal_vision_factor
        
        # כאן מתחילה הפונקצייה המשנית עצמה txt2_add_new_moon
        
        # חישוב האם קו הרוחב הגיאוגרפי של המיקום הוא צפוני או דרומי, והדפסת קו הרוחב
        location_lat_N_S = 'צפון' if location.latitude.degrees > 0 else 'דרום'
        location_lat_for_print = f'{abs(round(location.latitude.degrees,4))} {location_lat_N_S}'

        # חישוב האם קו האורך הגיאוגרפי של המיקום הוא מזרח או מערב, והדפסת קו האורך
        location_lon_E_W = 'מערב' if location.longitude.degrees < 0 else 'מזרח'
        location_lon_for_print = f'{abs(round(location.longitude.degrees,4))} {location_lon_E_W}'
        
        txt2.configure(state="normal")
        txt2.delete(1.0, END)
    
        if month == "MINUS":
            txt2.insert("end", f'\n\nמידע על ראיית הירח החדש !הקודם! לתאריך בקשת המידע\n')
        else:
            txt2.insert("end", f'\n\nמידע על ראיית הירח החדש !הבא! אחרי תאריך בקשת המידע\n')
        txt2.insert("end", f'\n\nשימו לב! כל החישובים בוצעו לפי תאריכים לועזיים\n')
        
        txt2.insert("end", f'\n---------------------\n')
        
        txt2.insert("end", f'\nרוב נתוני ראיית הירח חושבו לפי שיטות שהובאו במאמר הבא')
        txt2.insert("end", f'\nר"ע הופמן, תכנון מחושב של קריטריוני אפשרות ראיית הירח החדש')
        txt2.insert("end", f'\nיודעי בינה ד (תשס"ז), עמודים 71-54\n\n')
        txt2.insert("end", f'---------------------\n')
        
        txt2.insert("end", f'\nתאריך ומקום בקשת המידע')
        txt2.insert("end", f'\n\n({heb_for_print})   {greg_for_print}')
        txt2.insert("end", f'\nשם המקום: {city_for_print}')
        txt2.insert("end", f'\nקו רוחב - {location_lat_for_print}; קו אורך - {location_lon_for_print}; גובה - {int(location.elevation.m)} מטר')


        if month == "MINUS":
            # מידע על ירח חדש הקודם
            hitkabzut,nigud = hitkabzut_nigud_calculations(time,location,location_timezone,body="moon",PLUS_MINUS="MINUS",plus_minus_days=50)
        else:
            # מידע על ירח חדש הבא
            hitkabzut,nigud = hitkabzut_nigud_calculations(time,location,location_timezone,body="moon",PLUS_MINUS="PLUS",plus_minus_days=50)
        # הגדרת תאריך עברי מקביל לתאריך הלועזי, ולמחרתו
        hitkabzut_heb = dates.GregorianDate(1880, 10, 20).from_pydate(hitkabzut).to_heb()
        hitkabzut_heb_for_print = f'{heb_string_day(hitkabzut_heb.weekday())} - {hitkabzut_heb.hebrew_date_string(True)}'
        txt2.insert("end", f'\n\n--------------------------------------\n')
        txt2.insert("end", f'\nמולד ירח אמיתי')
        txt2.insert("end", f'\n\n({hitkabzut_heb_for_print})   {hitkabzut:%d/%m/%Y}    בשעה   {hitkabzut:%H:%M:%S}')
        txt2.insert("end", f'\n\n--------------------------------------\n')
        
        # הוספת כל נתוני הירח ביום השקיעה הראשונה שלאחר המולד לתוך טקסט2 באמצעות פונקציית print_all_about_first_moon
        # יום החיפוש הראשון הוא יום ההתקבצות
        moon_search_day = hitkabzut
        sight_day_greg, normal_vision_factor = print_all_about_first_moon (moon_search_day, hitkabzut)
        
        # כל עוד שמקדם הראייה המנורמל קטן מ-1 יש לבצע שוב את כל הפעולות עבור היום שלמחרת ולהוסיפם לטקסט2
        # משתנה בסיס החיפוש הוא שעת שקיעת הירח של היום הקודם והוספתי עוד דקה יותר מיממה למרות שלא מוכרחים כדי שלא תהיה שגיאה בחיפוש שקיעת הירח הבאה
        # כל זאת בתנאי שיום הראייה לא שווה "NONE" כי אם כן הייתה שגיאה בחישוב השקיעות ואין מה להמשיך לחשב
        while sight_day_greg != "NONE" and normal_vision_factor < 1.0: 
            txt2.insert("end", f'\n------------------------------------------------\n')
            moon_search_day = sight_day_greg + timedelta (days = 1, minutes = 1)
            sight_day_greg, normal_vision_factor = print_all_about_first_moon (moon_search_day, hitkabzut)
            
        # ===== רוורס לכל הטקסט =====
        full_text = txt2.get("1.0", "end-1c")
        txt2.delete("1.0", "end")
        txt2.insert("1.0", reverse(full_text))      
        
        # הגדרת העיצוב של הטקסט בתיבת הטקסט שיהיה ממורכז
        txt2.tag_configure("center", justify='center')
        txt2.tag_add("center", 1.0, "end")
        
        # סגירת תיבת הטקסט לקריאה בלבד
        txt2.configure(state="disabled")
    
    ############################################################################################################
    
    # פונקצייה משנית להוספת ירח ישן לקובץ טקסט2
    def txt2_add_last_moon(month = "PLUS"):
        
        # דבר ראשון, הגדרת פונקצייה משנית משנית של הדפסות עבור כל נתוני הירח
        # משתנה עבור יום בדיקת הראייה, ומשתנה התקבצות זה כדי לבדוק כמה שעות עברו מהמולד
        def print_all_about_last_moon (moon_search_day, hitkabzut):
            
            # החלק העליון של התוכנה פועל תמיד, אבל החלק שתלוי בחישובי זריחה ושקיעה לא פועל במקום שאין בו זריחה ושקיעה בכל יום כגון באיזור הקוטב הצפוני
            try:

                # חישוב שעת זריחה גיאומטרית האחרונה של הירח לפני שעת המולד: התוצאה תהיה יום ראשון לחישוב אפשרות הראייה
                MR,MS,MR_alt,MR_az,MS_alt,MS_az = calculate_rising_seting(moon_search_day,location,location_timezone,horizon= 0, body="moon",PLUS_MINUS = "MINUS")
                
                # קביעת משתנה ששומר מהו התאריך הלועזי של יום ראשון לחישוב אפשרות הראייה האחרונה לצורך ריטרן בסוף עבור חיפוש היום הקודם
                sight_day_greg = MR
                
                # חישוב שעת זריחה גיאומטרית של השמש בתאריך שבו הירח זורח לאחרונה לפני המולד
                # הדגשה: חישוב כללי של זריחה ושקיעה ביום זה, ולא חישוב של שקיעה הבאה
                SR,SS,SR_alt,SR_az,SS_alt,SS_az = calculate_rising_seting(MR,location,location_timezone,horizon= 0, body="sun",PLUS_MINUS = "NONE")
                
                # חישובי תאריך עברי של יום הראייה שבינתיים הוא הזריחה האחרונה לפני המולד 
                sight_day_heb = dates.GregorianDate(1880, 10, 20).from_pydate(MR).to_heb()
                sight_day_heb_for_print = f'{heb_string_day(sight_day_heb.weekday())} - {sight_day_heb.hebrew_date_string(True)}'
                
                # המרת זמן הזריחה הגיאומטרית של השמש ביום הראייה לזמן של סקייפילד וחישוב גובה ואזימוט של הירח על זמן זה
                # חשוב לחשב זאת בשלב זה לפני הבדיקה האם זריחת הירח היא לפני זריחת השמש, כי המידע הזה דרוש למקרה שזריחת הירח אכן לאחר זריחת השמש
                SR_skyfield_time = cu_to_skyfield_time(SR)
                malt, maz, _ = (eph['earth'] + location).at(SR_skyfield_time).observe(eph['moon']).apparent().altaz()
                
                # תאריך החישובים 
                txt2.insert("end", f'\nהתאריך עבורו בוצעו חישובי ראייה אחרונה')
                txt2.insert("end", f'\n\n{MR:%d/%m/%Y}  ({sight_day_heb_for_print})')
                  
                # רק במקרה שהירח אכן זורח לפני השמש ביום זה, יש לחשב את נתוני הירח ולהוסיפם לטקסט
                if MR < SR:

                    SHEIYA = (SR - MR).total_seconds() / 60
                    KESHET_REIYA = SHEIYA / 4
                    
                    # חישוב שעת הראייה לפי 0.6 של השהייה בין הזריחות הגיאומטריות
                    time_of_vision = SR - timedelta(seconds = (SR - MR).total_seconds() * 0.6)
                    
                    # מספר השעות שיחלפו משעת הראייה עד המולד האמיתי
                    AGE = hitkabzut - time_of_vision
                    AGE = (AGE.days * 24) + ((AGE.total_seconds() / 60) / 60)
                    
                    # המרת הזמן המקומי לזמן של סקייפילד וחישוב כל נתונים אסטרונומיים של הירח על זמן זה
                    time_ov = cu_to_skyfield_time(time_of_vision)
                    alt,az,ra,dec,ha,dec_N_S,lat,lon,dist,lat_N_S,percent,apparent_diameter,thickness,slon,elongation,ecliptic_elongation,elongation_E_W,salt,saz = astro_calculations("moon",time_ov,location,location_timezone)
                    
                    
                    # קריטריון הראייה של הופמן

                    # שורש ריבועי מייצגים בפייתון כך
                    # ** (0.5)))
                    # מקדם קלות הראייה לפי הופמן מורכב מהפרש רומים בין השמש לירח בשעת הראייה שזה 0.6 של השהייה יחד עם השורש של עובי סהר הירח
                    # הנוסחה היא: הפרשי הגובה בין השמש לירח, פלוס 7.37, כפול שורש עובי הסהר 
                    vision_factor = abs(alt-salt) + (7.37 * (thickness ** (0.5))) 
                    # אבל הפרשי הגובה הם בין מרכז השמש לבין מרכז הירח ואילו מרכז הסהר נמוך ממרכז הירח לכן ניתן להוסיף להפרשי הגובה עוד רבע מהקוטר הזוויתי הנראה של הירח כדלהלן
                    #vision_factor = (abs(alt-salt) + (apparent_diameter / 4 / 60)) + (7.37 * (thickness ** (0.5))) 
                    
                    # נרמול של מקדם הראייה הופמן כך שאפס פירושו שאין ראייה בעיין כלל ואחד פירושו שיש ראייה ודאית בעיין ובין אפס לאחד זה טווח אי הוודאות
                    normal_vision_factor = (vision_factor - 12.2) / 5.2 
                    
                    txt2.insert("end", f'\n\n\nתקציר אפשרות ראיית הירח ביום זה על פי מקדם קלות הראייה של הופמן')
                    if normal_vision_factor <= -0.7:
                        txt2.insert("end", f'\n\n\nערך מקדם: {normal_vision_factor :02.2f}; הירח לא ייראה ביום זה - אפילו במשקפת')
                    elif normal_vision_factor > -0.7 and normal_vision_factor < 0:
                        txt2.insert("end", f'\n\nערך מקדם: {normal_vision_factor :02.2f}; תיתכן ראייה בעזרת משקפת או טלסקופ בלבד')
                    elif normal_vision_factor >= 0 and normal_vision_factor < 0.5:
                        txt2.insert("end", f'\n\nערך מקדם: {normal_vision_factor :02.2f}; תיתכן ראייה בעין - בקושי רב!')
                    elif normal_vision_factor >= 0.5 and normal_vision_factor < 1:
                        txt2.insert("end", f'\n\nערך מקדם: {normal_vision_factor :02.2f}; הירח צפוי להיראות בעין - ייתכן קושי')
                    elif normal_vision_factor >= 1:
                        txt2.insert("end", f'\n\nערך מקדם: {normal_vision_factor :02.2f}; ראייה קלה בעין - כשאין עננים')
                    
                    txt2.insert("end", f'\n\n\nפירוט הנתונים')
                    txt2.insert("end", f'\n\nזריחת הירח (גיאומטרית) בשעה:    {MR:%H:%M:%S}    באזימוט:  {MR_az :02.1f}°')
                    txt2.insert("end", f'\nזריחת השמש (גיאומטרית) בשעה:    {SR:%H:%M:%S}    באזימוט:  {SR_az :02.1f}°')
                    txt2.insert("end", f'\nבשעה זו הירח נמצא בגובה:    {malt.degrees :02.2f}°    באזימוט:    {maz.degrees :02.1f}°')
                    
                    
                    txt2.insert("end", f'\nשְׁהִיָיה - הפרש דקות בין הזריחות הגיאומטריות:    {SHEIYA :02.2f}') 
                    
                    txt2.insert("end", f'\n\nשעת הראייה המיטבית ליום זה לפי הופמן (0.6 של השְׁהִיָיה):    {time_of_vision:%H:%M:%S}')
                    txt2.insert("end", f'\nבשעת הראייה הירח נמצא בגובה:    {alt :02.2f}°    באזימוט:    {az :02.1f}°')
                    txt2.insert("end", f'\nבשעת הראייה השמש נמצאת בגובה:    {salt :02.2f}°    באזימוט:    {saz :02.1f}°')
                    
                    txt2.insert("end", f'\nהפרשי שמש-ירח בשעת הראייה; גובה:    {abs(alt-salt) :02.2f}°    אזימוט:    {abs(az-saz) :02.1f}°')  
                    
                    #txt2.insert("end", f'\nקוטר נראה של כל הירח, בדקות קשת, בשעת הראייה:    {apparent_diameter :02.2f}')
                    
                    txt2.insert("end", f'\nעובי סהר הירח, בדקות קשת, בשעת הראייה:    {thickness :02.2f}')
                    
                    
                    #txt2.insert("end", f'\nמקדם קלות הראייה קריטריון הופמן רום-סהר לשעת הראייה:    {vision_factor :02.2f}')
                    txt2.insert("end", f'\nמקדם קלות הראייה הופמן רום-סהר לשעת הראייה - מנורמל:    {normal_vision_factor :02.2f}')
                    
                    txt2.insert("end", f'\n\nמספר השעות שיחלפו משעת הראייה עד המולד האמיתי:    {AGE :02.2f}')
                    txt2.insert("end", f'\nאחוזי התאורה של הירח בשעת הראייה:    {percent :02.2f}')            
                    txt2.insert("end", f'\nמרחק הירח מכדור הארץ, בקילומטרים, בשעת הראייה:    {dist :,.1f}')
                    
                    # חישובי ראיית הירח לפי שיטת הרמב"ם
                    # חישוב שעת הראייה של הרמב"ם: שעה שהשמש בגובה 4 מעלות תחת האופק בתאריך שבו הירח זורח לאחרונה לפני המולד
                    # הדגשה: חישוב כללי של זריחה ושקיעה ביום זה, ולא חישוב של זריחה הקודמת
                    SR4,_,_,_,_,_ = calculate_rising_seting(MR,location,location_timezone,horizon= -4, body="sun",PLUS_MINUS = "NONE")
                    # המרת הזמן המקומי לזמן של סקייפילד וחישוב כל נתונים אסטרונומיים של הירח על זמן זה
                    time_ov_SR4 = cu_to_skyfield_time(SR4)
                    alt,az,ra,dec,ha,dec_N_S,lat,lon,dist,lat_N_S,percent,apparent_diameter,thickness,slon,elongation,ecliptic_elongation,elongation_E_W,salt,saz = astro_calculations("moon",time_ov_SR4,location,location_timezone)
                    ORECH_RISHON = ecliptic_elongation
                    KITSEI_REIYA = int(ORECH_RISHON) + KESHET_REIYA
                    
                    # הגדרת אורך ראשון המינמלי הדרוש לראיית הירח לפי שיטת הרמב"ם
                    Required_ORECH_RISHON = 9 if lon >270 or lon <90 else 10
                    
                    txt2.insert("end", f'\n\n--------------')
                    
                    txt2.insert("end", f'\n\nנתוני ראיית הירח לשיטת הרמב"ם בהלכות קידוש החודש')
                    
                    txt2.insert("end", f'\n[קריטריון: אורך ראשון מעל 9 או 10 (תלוי בעונה) וקיצי ראייה מעל 22]')
                    
                    txt2.insert("end", f'\n\n\nתקציר אפשרות ראיית הירח ביום זה על פי קריטריון הרמב"ם')
                    
                    # היתכנות ראייה לפי קשת ראייה (הלכות קידוש החודש פרק יז, הלכות טו-טז)
                    # if KESHET_REIYA > 9 and KITSEI_REIYA > 22:
                    
                    # היתכנות ראייה לפי אורך ראשון (הלכות קידוש החודש פרק יז, הלכות ג-ד)
                    # וראו מאמרו של לווינגר: חיזוי הראייה
                    
                    if ORECH_RISHON > Required_ORECH_RISHON and KITSEI_REIYA > 22:
                        txt2.insert("end", f'\n\nקיצי הראייה: {KITSEI_REIYA :02.2f}°; לפי קריטריון הרמב"ם: הירח ייראה ביום זה')
                    else:
                        txt2.insert("end", f'\n\nקיצי הראייה: {KITSEI_REIYA :02.2f}°; לפי קריטריון הרמב"ם: הירח !לא! ייראה ביום זה')
                    
                    txt2.insert("end", f'\n\nשעת הראייה של הרמב"ם: כמו שליש שעה לפני הזריחה הגיאומטרית')
                    txt2.insert("end", f'\nגובה השמש בזמן זה בממוצע שנתי בארץ ישראל: 4 מעלות תחת האופק')
                    txt2.insert("end", f'\nשעת הראייה של הרמב"ם ליום זה (שמש בגובה מינוס 4 מעלות):    {SR4:%H:%M:%S}')
                    txt2.insert("end", f'\nבשעת הראייה של הרמב"ם, הירח נמצא בגובה:    {alt :02.2f}°    באזימוט:    {az :02.1f}°')
                    txt2.insert("end", f'\nנתוני השמש על המלקה בשעת הראייה של הרמב"ם; אורך:    {slon :02.2f}°    רוחב:    {(0.0) :02.2f}°')     
                    txt2.insert("end", f'\nנתוני הירח על המלקה בשעת הראייה של הרמב"ם; אורך:    {lon :02.2f}°    רוחב:    {lat :02.2f}° {lat_N_S}')
                    txt2.insert("end", f'\nאלונגציה אמיתית בין השמש והירח בשעת הראייה של הרמב"ם:    {elongation :02.2f}°')
                    txt2.insert("end", f'\nאורך ראשון - אלונגציה על המלקה בשעת הראייה של הרמב"ם:    {ORECH_RISHON :02.2f}°')
                    txt2.insert("end", f'\nקשת ראייה - המרת השְׁהִיָיה למעלות (4 דקות לכל מעלה):    {KESHET_REIYA :02.2f}°')
                    txt2.insert("end", f'\nסכום קיצי הראייה - האורך הראשון וקשת הראייה יחד : {KITSEI_REIYA :02.2f}°')
                    
                    if normal_vision_factor < 1.0:
                        txt2.insert("end", f'\n\n\nשימו לב! מקדם קלות הראייה המנורמל קטן מ-1')
                        txt2.insert("end", f'\nלפיכך מובאים להלן נתונים גם עבור היום הקודם')
                        
                else:
                    # הגדרת מקדם הראייה המנורמל על ערך פחות מ-1 כדי שיחושבו הערכים עבור היום הקודם
                    normal_vision_factor = -10
                    txt2.insert("end", f'\n\nזריחת השמש (גיאומטרית) בשעה:    {SR:%H:%M:%S}    באזימוט:  {SR_az :02.1f}°')
                    txt2.insert("end", f'\nבשעה זו הירח נמצא בגובה:    {malt.degrees :02.2f}°    באזימוט:    {maz.degrees :02.1f}°')
                    txt2.insert("end", f'\nזריחת הירח (גיאומטרית) בשעה:    {MR:%H:%M:%S}    באזימוט:  {MR_az :02.1f}°')
                    # מקרה כזה ייתכן כשרוחב הירח גדול ובאיזור גאגרפי מתאים כגון בארץ ישראל ראש חודש כסלו ה'תשפ"ד
                    txt2.insert("end", f'\n\nשימו לב! למרות שהמולד עדיין לא היה, הירח כבר זורח אחרי השמש ביום זה')
                    txt2.insert("end", f'\nהירח בלתי ניתן לצפייה ביום זה, ולפיכך מובאים להלן נתונים עבור היום הקודם')
            
            # במקרה שיש שגיאה בחישוב הזריחות והשקיעות
            except IndexError:
                txt2.insert("end", "\n ! שגיאה !\nעבור המיקום הנוכחי בתאריך הנוכחי התוכנה אינה יכולה לחשב זמני זריחות")
                sight_day_greg = "NONE"
                normal_vision_factor = "NONE"

            txt2.insert("end", f'\n\n')

            return sight_day_greg, normal_vision_factor
        
        # כאן מתחילה הפונקצייה המשנית עצמה txt2_add_last_moon
        
        # חישוב האם קו הרוחב הגיאוגרפי של המיקום הוא צפוני או דרומי, והדפסת קו הרוחב
        location_lat_N_S = 'צפון' if location.latitude.degrees > 0 else 'דרום'
        location_lat_for_print = f'{abs(round(location.latitude.degrees,4))} {location_lat_N_S}'

        # חישוב האם קו האורך הגיאוגרפי של המיקום הוא מזרח או מערב, והדפסת קו האורך
        location_lon_E_W = 'מערב' if location.longitude.degrees < 0 else 'מזרח'
        location_lon_for_print = f'{abs(round(location.longitude.degrees,4))} {location_lon_E_W}'
        
        txt2.configure(state="normal")
        txt2.delete(1.0, END)
    
        if month == "MINUS":
            txt2.insert("end", f'\n\nמידע על ראיית הירח האחרון !הקודם! לתאריך בקשת המידע\n')
        else:
            txt2.insert("end", f'\n\nמידע על ראיית הירח האחרון !הבא! אחרי תאריך בקשת המידע\n')
        
        txt2.insert("end", f'\n\nשימו לב! כל החישובים בוצעו לפי תאריכים לועזיים\n')
        
        txt2.insert("end", f'\nהערה חשובה: המושג "שעת הראייה המיטבית" נועד בעיקרו !רק! עבור הירח הראשון')
        txt2.insert("end", f'\nובכל זאת הובא כאן כדי שיתאפשר להתאמן בבוקר על ראיית הירח, בתנאי ראייה זהים לערב')
        txt2.insert("end", f'\n\n---------------------\n')
        
        txt2.insert("end", f'\nרוב נתוני ראיית הירח חושבו לפי שיטות שהובאו במאמר הבא')
        txt2.insert("end", f'\nר"ע הופמן, תכנון מחושב של קריטריוני אפשרות ראיית הירח החדש')
        txt2.insert("end", f'\nיודעי בינה ד (תשס"ז), עמודים 71-54\n\n')
        txt2.insert("end", f'---------------------\n')
        
        txt2.insert("end", f'\nתאריך ומקום בקשת המידע')
        txt2.insert("end", f'\n\n({heb_for_print})   {greg_for_print}')
        txt2.insert("end", f'\nשם המקום: {city_for_print}')
        txt2.insert("end", f'\nקו רוחב - {location_lat_for_print}; קו אורך - {location_lon_for_print}; גובה - {int(location.elevation.m)} מטר')

        if month == "MINUS":
            # מידע על ירח ישן הקודם
            hitkabzut,nigud = hitkabzut_nigud_calculations(time,location,location_timezone,body="moon",PLUS_MINUS="MINUS",plus_minus_days=50)
        else:
            # מידע על ירח ישן הבא
            hitkabzut,nigud = hitkabzut_nigud_calculations(time,location,location_timezone,body="moon",PLUS_MINUS="PLUS",plus_minus_days=50)
        
        # הגדרת תאריך עברי מקביל לתאריך הלועזי, ולמחרתו
        hitkabzut_heb = dates.GregorianDate(1880, 10, 20).from_pydate(hitkabzut).to_heb()
        hitkabzut_heb_for_print = f'{heb_string_day(hitkabzut_heb.weekday())} - {hitkabzut_heb.hebrew_date_string(True)}'
        txt2.insert("end", f'\n\n--------------------------------------\n')
        txt2.insert("end", f'\nמולד ירח אמיתי')
        txt2.insert("end", f'\n\n({hitkabzut_heb_for_print})   {hitkabzut:%d/%m/%Y}    בשעה   {hitkabzut:%H:%M:%S}')
        txt2.insert("end", f'\n\n--------------------------------------\n')
        
        # הוספת כל נתוני הירח ביום הזריחה האחרונה שלפני המולד לתוך טקסט2 באמצעות פונקציית print_all_about_last_moon
        # יום החיפוש הראשון הוא יום ההתקבצות
        moon_search_day = hitkabzut
        sight_day_greg, normal_vision_factor = print_all_about_last_moon (moon_search_day, hitkabzut)
        
        # כל עוד שמקדם הראייה המנורמל קטן מ-1 יש לבצע שוב את כל הפעולות עבור היום !הקודם! ולהוסיפם לטקסט2
        # משתנה בסיס החיפוש הוא שעת זריחת הירח של היום הקודם והוספתי עוד דקה יותר מיממה למרות שלא מוכרחים כדי שלא תהיה שגיאה בחיפוש שקיעת הירח הבאה
        # כל זאת בתנאי שיום הראייה לא שווה "NONE" כי אם כן הייתה שגיאה בחישוב השקיעות ואין מה להמשיך לחשב
        while sight_day_greg != "NONE" and normal_vision_factor < 1.0: 
            txt2.insert("end", f'\n------------------------------------------------\n')
            moon_search_day = sight_day_greg - timedelta (days = 1, minutes = 1)
            sight_day_greg, normal_vision_factor = print_all_about_last_moon (moon_search_day, hitkabzut)
            
        # ===== רוורס לכל הטקסט =====
        full_text = txt2.get("1.0", "end-1c")
        txt2.delete("1.0", "end")
        txt2.insert("1.0", reverse(full_text))
        
        # הגדרת העיצוב של הטקסט בתיבת הטקסט שיהיה ממורכז
        txt2.tag_configure("center", justify='center')
        txt2.tag_add("center", 1.0, "end")

        # סגירת תיבת הטקסט לקריאה בלבד
        txt2.configure(state="disabled")
    
    ###########################################################################################################
    
    # פונקצייה משנית לשמירה בשם של קובץ טקסט2 עבור כפתור השמירה    
    def save_txt2_to_path():
        C = txt2.get(1.0, END)
        # שם הקובץ עבור הכוכבים הראשונים או האחרונים
        if choice_print.get() == "STARS":
            file = asksaveasfilename(defaultextension=".txt", initialfile = f"{city_for_print}-רשימת-כוכבי-שבת-ראשונים-לתאריך-{greg:%d-%m-%Y}")
        # שם הקובץ עבור תחנת החלל הבינלאומית
        elif choice_print.get() == "ISS":
            file = asksaveasfilename(defaultextension=".txt", initialfile = f"{city_for_print}-ראייות-תחנת-החלל-הבינלאומית-סמוך-לתאריך-{greg:%d-%m-%Y}")
        # שם הקובץ עבור זמני היום
        elif choice_print.get() == "ZMANIM":
            file = asksaveasfilename(defaultextension=".txt", initialfile = f"{city_for_print}-רשימת-זמני-היום-לתאריך-{greg:%d-%m-%Y}")
        # שם הקובץ עבור מידע על התקופה
        #elif choice_print.get() == "TKUFA":
        #    file = asksaveasfilename(defaultextension=".txt", initialfile = f"{city_for_print}-בטא-מידע-על-תקופת-שמואל-{greg:%d-%m-%Y}")
        # שם הקובץ עבור ירח חדש הבא
        elif choice_print.get() == "NEXT_NEW_MOON":
            file = asksaveasfilename(defaultextension=".txt", initialfile = f"{city_for_print}-מידע-ירח-ראשון-הבא-לאחר-{greg:%d-%m-%Y}")
        # שם הקובץ עבור ירח אחרון בחודש
        elif choice_print.get() == "NEXT_LAST_MOON":
            file = asksaveasfilename(defaultextension=".txt", initialfile = f"{city_for_print}-מידע-ירח-אחרון-הבא-לאחר-{greg:%d-%m-%Y}")
        # שם הקובץ עבור ירח חדש הבא
        elif choice_print.get() == "PREVIOUS_NEW_MOON":
            file = asksaveasfilename(defaultextension=".txt", initialfile = f"{city_for_print}-מידע-ירח-ראשון-הקודם-לפני-{greg:%d-%m-%Y}")
        # שם הקובץ עבור ירח אחרון בחודש
        elif choice_print.get() == "PREVIOUS_LAST_MOON":
            file = asksaveasfilename(defaultextension=".txt", initialfile = f"{city_for_print}-מידע-ירח-אחרון-הקודם-לפני-{greg:%d-%m-%Y}")
        # שם הקובץ עבור ירח אחרון בחודש
        elif choice_print.get() == "STARS_EVENING":
            file = asksaveasfilename(defaultextension=".txt", initialfile = f"{city_for_print}-מידע-כוכבים-ראשונים-בערב-לתאריך-{greg:%d-%m-%Y}")
       # שם הקובץ עבור ירח אחרון בחודש
        elif choice_print.get() == "STARS_MORNING":
            file = asksaveasfilename(defaultextension=".txt", initialfile = f"{city_for_print}-מידע-כוכבים-אחרונים-בבוקר-לתאריך-{greg:%d-%m-%Y}")
      
        
        # שמירת הקובץ תוך אפשרות ציון הקידוד המתאים
        # אפשרויות קידוד: cu_encod או "utf-8"
        # איף פייל נועד למנוע שגיאה במקרה שסגרו את החלון כי החליטו לא לשמור את הקובץ
        if file:
            with open(file, 'w', encoding="utf-8") as f:
                f.write(reverse(C))
        
        
        # ביטול הסימון של וי ליד הכפתור לאחר ביצוע הפעולה 
        choice_print.set("NONE")
        
        # סגירת חלון הזמנים לאחר שמירת הקובץ
        ph_times.destroy()
    
    
    ###########################################################################################################
    # מכאן והלאה מתחילה הפונקצייה הראשית print_halachic_times
    
    # קבלת שעה מקום ואיזור הזמן מהמשתמש
    time,location,location_timezone=time_location_timezone()
    #-----------------------------
    # חישובי תחנת החלל הם בכוונה רק לפי עכשיו לפי המחשב כדי שלא יהיו בעיות בחישוב לפי נתונים לא מדוייקים כי קובץ הנתונים עדכני רק לימים סמוכים
    if choice_print.get() == "ISS":
        #time = skyfield_to_cu_time(ts.now(), location_timezone)
        time = datetime.now().astimezone(location_timezone)
    #-----------------------------
    time = time.replace(hour=0, minute=0, second=0, microsecond=0) # חשוב מאוד להתחיל את החישובים בתחילת היממה
    greg = time.astimezone(location_timezone)
    # הגדרת תאריך עברי מקביל לתאריך הלועזי, ולמחרתו
    heb = dates.GregorianDate(1880, 10, 20).from_pydate(greg).to_heb()
    heb_for_print = f'{heb_string_day(heb.weekday())} - {heb.hebrew_date_string(True)}'
    greg_for_print = f'{greg:%d/%m/%Y}'

    # שם המיקום
    city_for_print = city.get()

    # הגדרת החלון
    ph_times = Toplevel(ws)
    ph_times.minsize(625,625)
    ph_times.geometry(f"{round(625*magnification_factor)}x{round(685*magnification_factor)}+{round(135*magnification_factor)}+{round(1*magnification_factor)}")
    
    # הגדרת צבע לכל החלון
    ph_times.configure(bg=cu_color)

    # כפתור לפונקציית שמירת קובץ טקסט
    Button(ph_times, text=reverse("שמור זמנים לקובץ - וסגור חלון"),width=25,command=save_txt2_to_path).pack()

    # אזור נפרד לטקסט
    output_text2 = cu_PanedWindow(ph_times)

    # ברי גלילה לאיזור הטקסט
    # גלילה למעלה ולמטה
    Y_scrollbar = Scrollbar(output_text2, orient = 'vertical')
    Y_scrollbar.pack( side = RIGHT, fill = Y )

    # גלילה לימין ושמאל כרגע לא צריכה להיות בשימוש כי תיבת הטקסט עצמה לא מאפשרת חריגה של הטקסט לימין ושמאל
    X_scrollbar = Scrollbar(output_text2, orient = 'horizontal')
    X_scrollbar.pack( side = BOTTOM, fill = X )

    # חלון טקסט להצגת התוצאות
    txt2 = Text(output_text2, height=40, width=75, borderwidth=0, yscrollcommand = Y_scrollbar.set, xscrollcommand = X_scrollbar.set, font= "david 13")

    # הגדרת העיצוב של הטקסט בתיבת הטקסט: שיהיה ממורכז
    txt2.tag_configure("center", justify='center')
    txt2.tag_add("center", 1.0, "end")   

    # סגירה של תיבת הטקסט לקריאה בלבד ואריזה לתוך החלון
    txt2.configure(state="disabled")

    # חסימת כל תגובה לעכבר וכו של תיבת הטקסט
    #txt2.bindtags(("txt", "wnd", "all"))

    # לחילופין, חסימת שתי תגובות ספציפיות לעכבר עבור תיבת הטקסט
    txt2.bind("<Button>", lambda event: "break")
    txt2.bind("<Motion>", lambda event: "break")


    # אריזת תיבת הטקסט
    txt2.pack( side = LEFT, fill = BOTH )

    # הגדרת ברי הגלילה שפעולתם תתבצע על תיבת הטקסט
    Y_scrollbar.config( command = txt2.yview )
    X_scrollbar.config( command = txt2.xview )

    # אריזת האיזור הנפרד של טקסט התוצאות
    output_text2.pack()

    # הכנסת הנתונים המבוקשים להדפסה לתוך תיבת הטקסט לאחר 5 חלקי שניות
    if choice_print.get() == "ZMANIM":
        ph_times.after(5,txt2_add_times)
    elif choice_print.get() == "ISS":
        ph_times.after(5,txt2_add_iss)
    #elif choice_print.get() == "TKUFA":
    #    ph_times.after(5,txt2_add_tkufa)
    elif choice_print.get() == "NEXT_NEW_MOON":
        ph_times.after(5,txt2_add_new_moon(month = "PLUS"))
    elif choice_print.get() == "PREVIOUS_NEW_MOON":
        ph_times.after(5,txt2_add_new_moon(month = "MINUS"))
    elif choice_print.get() == "NEXT_LAST_MOON":
        ph_times.after(5,txt2_add_last_moon(month = "PLUS"))
    elif choice_print.get() == "PREVIOUS_LAST_MOON":
        ph_times.after(5,txt2_add_last_moon(month = "MINUS"))
    elif choice_print.get() == "STARS_EVENING":
        ph_times.after(5,txt2_add_stars(which = "evening"))
    elif choice_print.get() == "STARS_MORNING":
        ph_times.after(5,txt2_add_stars(which = "morning"))

####################################################################################################################
####################################################################################################################
####################################################################################################################

####################################################################################################################
                              # יצוא מידע על זמני היום לקובץ סי.אס.וי
####################################################################################################################        
        
# פונקצייה להוספת זמני היום לכל החודש/שנה העברית הנוכחית לקובץ אקסל או סי. אס. וי
def export_calendar_halacha_times():
    
    # אם כפתור הפעלת החישובים לא פעיל, יש לצאת מייד מהפונקצייה
    if C1.get() != 1:
        return
    
    # התחייבות המשתמש
    msg_box = tkinter.messagebox.askquestion(reverse(f'התחייבות לפני יצירת קובץ זמנים') if is_heb_locale else 'Commitment before creating a times file',f'\nאני מתחייב/ת שלא להשתמש בקבצים למטרות רווח בלא קבלת אישור מפורש מאת יוצר התוכנה' if is_heb_locale else '\nI undertake not to use these files for financial gain without receiving express permission from the creator of the software',icon='warning', default="no")
    
    # אם המשתמש לא מסכים - יוצאים מהפונקצייה
    if msg_box == 'no':
        return  
    
    # ראשית כל עצירת החישובים הרציפים של התוכנה הראשית כדי לא להכביד על המערכת
    if choice_time.get() == "עכשיו מתעדכן":
        choice_time.set("עכשיו (לפי המחשב)")
    
    
    # קבלת שעה מקום ואיזור הזמן מהמשתמש
    time,location,location_timezone=time_location_timezone()
    time = time.replace(hour=0, minute=0, second=0, microsecond=0)
    greg = time.astimezone(location_timezone)
    # הגדרת תאריך עברי מקביל לתאריך הלועזי, ולמחרתו
    heb = dates.GregorianDate(1880, 10, 20).from_pydate(greg).to_heb()
    heb_for_print = f'{heb_string_day(heb.weekday())} - {heb.hebrew_date_string(True)}'
    greg_for_print = f'{greg:%d/%m/%Y}'

    # חישוב האם קו הרוחב הגיאוגרפי של המיקום הוא צפוני או דרומי, והדפסת קו הרוחב
    location_lat_N_S = 'צפון' if location.latitude.degrees > 0 else 'דרום'
    location_lat_for_print = f'{abs(round(location.latitude.degrees,4))} {location_lat_N_S}'

    # חישוב האם קו האורך הגיאוגרפי של המיקום הוא מזרח או מערב, והדפסת קו האורך
    location_lon_E_W = 'מערב' if location.longitude.degrees < 0 else 'מזרח'
    location_lon_for_print = f'{abs(round(location.longitude.degrees,4))} {location_lon_E_W}'

    # שם המיקום
    city_for_print = city.get()

    # משתנה לקביעת הדפסת המידע של: האם מדובר בלוח זמנים חודשי או שנתי כולל החודש והשנה המדוברים
    if choice_zmanim_export.get() == "HEB_MONTH":
        chodshi_shnati = reverse(f"חודשי לחודש עברי {heb.month_name(True)} {heb.hebrew_year(True)}")
    elif choice_zmanim_export.get() == "HEB_YEAR":
        chodshi_shnati = reverse(f"שנתי לשנה עברית {heb.hebrew_year(True)}")
    elif choice_zmanim_export.get() == "GREG_MONTH":
        chodshi_shnati = reverse(f"חודשי לחודש גרגוריאני {greg.month}-{greg.year}")
    elif choice_zmanim_export.get() == "GREG_YEAR":
        chodshi_shnati = reverse(f"שנתי לשנה גרגוריאנית {greg.year}")
    
    # משתנה לקביעת מילים לומר בערך כמה זמן תארך ההמתנה לחישובים
    long_time = reverse("(כשתי דקות)") if choice_zmanim_export.get() in ["HEB_MONTH","GREG_MONTH"] else reverse("(כחצי שעה!)")
    
    # הגדרת השאלה    
    question = reverse(f'\nהאם ברצונך ליצור קובץ זמנֵי-הלכה {chodshi_shnati}?\nשים לב! אין להשתמש בתוכנה עד לסיום החישובים {long_time}')
    # שאילה האם המשתמש בטוח שברצונו ליצור קובץ זמנים חודשי/שנתי
    msg_box = tkinter.messagebox.askquestion(reverse(f'יצירת קובץ זמנֵי-הלכה {chodshi_shnati}'),question,icon='warning', default="no")
    
    # אם המשתמש ענה שהוא לא מאשר יש לצאת מיד מהפונקצייה
    if msg_box == 'no':
        return

    # הכנת מערך ריק עבור כל התאריכים
    all_dates = []


    # מילוי מערך התאריכים בתאריכי כל יום שבחודש העברי הנוכחי
    if choice_zmanim_export.get() == "HEB_MONTH":

        # מהו היום האחרון של חודש עברי 
        #end_month = 30 if heb.month in [] else 29

        # תאריך לועזי של א בחודש העברי הנוכחי
        heb_month_start = dates.HebrewDate(heb.year, heb.month, 1).to_greg()
        # תאריך לועזי של היום האחרון בחודש העברי הנוכחי. נמצא בניסיון כי אולי אין יום 30 בחודש העברי הנוכחי
        try:
            heb_month_end = dates.HebrewDate(heb.year, heb.month, 30).to_greg()
        except ValueError:
            heb_month_end = dates.HebrewDate(heb.year, heb.month, 29).to_greg()

        # הגדרת תאריך ההתחלה והסיום של החודש העברי הנוכחי ב-דייטטיים ואילו השעה תמיד מוגדרת על תשע בבוקר
        datetime_heb_month_start = datetime(heb_month_start.year, heb_month_start.month, heb_month_start.day, 9, 0 ,0 ,0)
        datetime_heb_month_end = datetime(heb_month_end.year, heb_month_end.month, heb_month_end.day, 9, 0 ,0 ,0)

        # הגדרת משתנה עבור תאריך שיש להוסיפו למערך התאריכים, שבתחילתו מוגדר לתאריך התחלת השנה 
        date_to_add = datetime_heb_month_start

        # המשתנה של התאריך שיש להוסיפו מתקדם ביממה אחת בכל צעד, וכל עוד שהוא לא מגיע לתאריך הסיום הוא מוסיף את התאריך לתוך מערך התאריכים
        while date_to_add <= datetime_heb_month_end:
            all_dates.append(date_to_add)
            date_to_add += timedelta(days=1)



    # מילוי מערך התאריכים בתאריכי כל יום שבשנה העברית הנוכחית
    elif choice_zmanim_export.get() == "HEB_YEAR":

        # תאריך לועזי של ראש השנה בשנה העברית הנוכחית
        heb_year_start = dates.HebrewDate(heb.year, 7, 1).to_greg()

        # תאריך לועזי של כט באלול בשנה העברית הנוכחית 
        heb_year_end = dates.HebrewDate(heb.year, 6, 29).to_greg()

        # הגדרת תאריך ההתחלה והסיום של השנה ב-דייטטיים ואילו השעה תמיד מוגדרת על תשע בבוקר
        datetime_heb_year_start = datetime(heb_year_start.year, heb_year_start.month, heb_year_start.day, 9, 0 ,0 ,0)
        datetime_heb_year_end = datetime(heb_year_end.year, heb_year_end.month, heb_year_end.day, 9, 0 ,0 ,0)

        # הגדרת משתנה עבור תאריך שיש להוסיפו למערך התאריכים, שבתחילתו מוגדר לתאריך התחלת השנה 
        date_to_add = datetime_heb_year_start

        # המשתנה של התאריך שיש להוסיפו מתקדם ביממה אחת בכל צעד, וכל עוד שהוא לא מגיע לתאריך הסיום הוא מוסיף את התאריך לתוך מערך התאריכים
        while date_to_add <= datetime_heb_year_end:
            all_dates.append(date_to_add)
            date_to_add += timedelta(days=1)   



    # מילוי מערך התאריכים בתאריכי כל יום שבחודש הגרגוריאני הנוכחי
    elif choice_zmanim_export.get() == "GREG_MONTH":

        # הגדרת תאריך ההתחלה והסיום של החודש הגרגוריאני ב-דייטטיים ואילו השעה תמיד מוגדרת על תשע בבוקר
        datetime_greg_month_start = datetime(greg.year, greg.month, 1, 9, 0 ,0 ,0)
        # מציאת היום האחרון בחודש
        greg_month_last_day = calendar.monthrange(greg.year, greg.month)[1]
        datetime_greg_month_end = datetime(greg.year, greg.month, greg_month_last_day, 9, 0 ,0 ,0)


        # הגדרת משתנה עבור תאריך שיש להוסיפו למערך התאריכים, שבתחילתו מוגדר לתאריך התחלת החודש 
        date_to_add = datetime_greg_month_start

        # המשתנה של התאריך שיש להוסיפו מתקדם ביממה אחת בכל צעד, וכל עוד שהוא לא מגיע לתאריך הסיום הוא מוסיף את התאריך לתוך מערך התאריכים
        while date_to_add <= datetime_greg_month_end:
            all_dates.append(date_to_add)
            date_to_add += timedelta(days=1) 



    # מילוי מערך התאריכים בתאריכי כל יום שבשנה הגרגוריאנית הנוכחית
    elif choice_zmanim_export.get() == "GREG_YEAR":

        # הגדרת תאריך ההתחלה והסיום של השנה הגרגוריאנית ב-דייטטיים ואילו השעה תמיד מוגדרת על תשע בבוקר
        datetime_greg_year_start = datetime(greg.year, 1, 1, 9, 0 ,0 ,0)
        datetime_greg_year_end = datetime(greg.year, 12, 31, 9, 0 ,0 ,0)

        # הגדרת משתנה עבור תאריך שיש להוסיפו למערך התאריכים, שבתחילתו מוגדר לתאריך התחלת השנה 
        date_to_add = datetime_greg_year_start

        # המשתנה של התאריך שיש להוסיפו מתקדם ביממה אחת בכל צעד, וכל עוד שהוא לא מגיע לתאריך הסיום הוא מוסיף את התאריך לתוך מערך התאריכים
        while date_to_add <= datetime_greg_year_end:
            all_dates.append(date_to_add)
            date_to_add += timedelta(days=1) 




    # בכל מקרה, הקמת מונה ששומר כמה תאריכים יש במערך התאריכים של כל החודש/השנה המבוקשים
    dates_counter = len(all_dates)

    # הגדרת משתנה ששומר מידע על המיקום
    information = f'זמני-הלכה {chodshi_shnati} למיקום: {city_for_print}, קו רוחב: {location_lat_for_print}, קו אורך: {location_lon_for_print}, גובה: {int(location.elevation.m)} מטר'

    # משתנה ששומר את כל הזמנים ואותו בסוף נשמור לקובץ סי אס וי. בתחילתו מובא המידע ושורה רווח
    zmanim = [[information],[""]]

    # הוספת הודעות הסבר
    zmanim.append(["שימו לב! במקביל לתאריך הלועזי: בכל אירוע שמתרחש עד השעה 12 בלילה, התאריך העברי הרשום מתייחס ליום שהסתיים! ולא ליום שהתחיל"])
    zmanim.append([f'שימו לב! סולם הזמן שבשימוש לשנה זו הוא {mean_transit_and_error_timescale_dict["year_timescale"]} ושיעור השגיאה השנתית שלו לשנה הנוכחית הוא {mean_transit_and_error_timescale_dict["seconds_error_timescale"]} שניות. השגיאה משפיעה רק על הזמן הרשום בשעון ולא על חישוב הנתונים'])
    if mean_transit_and_error_timescale_dict["year_timescale"] == "UT1":
        zmanim.append(["סולם הזמן שבשימוש לשנה זו, לוקח בחשבון את ה- דלטא-טי"])
    zmanim.append(["שימו לב! איזור הזמן עבור כל הזמנים הוא: שעון אזורי מתואם (לפי קו האורך הקרוב שמתחלק ל- 15) ומשנת 1918 והלאה הזמנים בקיץ הם לפי שעון קיץ"])
    
    # הוספת שורה רווח
    zmanim.append([])

    # מערך עבור שמות הזמנים
    zmanim_names = [
       'תאריך עברי','תאריך לועזי (גרגוריאני)','עלות השחר -25.9','עלות השחר -19.75','תחילת דמדומים -18','עלות השחר -16','עלות השחר -14','תחילת דמדומים -12','משיכיר -10.5','תחילת דמדומים -6','הנץ בגובה (כשאין הסתרות)','הנץ -0.833','הנץ 0','אורך שעה זמנית של היום','סוף זמן שמע מג"א -16','סוף זמן שמע גר"א (שעה 3)','סוף זמן תפילה מג"א -16','סוף זמן תפילה גר"א (שעה 4)','שעה 5 (סוף ביעור חמץ בערב פסח)','חצות היום (בערך שעה 6, וכעין זה חצות הלילה)','מנחה גדולה (שעה 6.5)',
        'סוף זמן מוסף לכתחילה (שעה 7)','סמוך למנחה קטנה (שעה 9)','מנחה קטנה (שעה 9.5)','פלג המנחה (שעה 10.75)','שקיעה 0','שקיעה -0.833','שקיעה בגובה (כשאין הסתרות)','צאת הכוכבים -3.65','צאת הכוכבים -4','צאת הכוכבים -4.37','צאת הכוכבים -4.61','סוף דמדומים -6','צאת שבת לוחות -8.5','סוף דמדומים -12','סוף דמדומים -14','צאת הכוכבים דר"ת -16','סוף דמדומים -18','צאת הכוכבים דר"ת -19.75','צאת הכוכבים דר"ת -25.9','זריחת הירח','שקיעת הירח'
            ]
    # הוספת מערך שמות הזמנים לתוך מערך הזמנים וזה יהיה שמות הטורים
    zmanim.append(zmanim_names)

    # הגדרת הודעה השגיאה שתופיע במקרה שהשמש לא יורדת לגובה המתאים במיקום זה
    eror = "שגיאה! (לתאריך ומיקום נוכחיים)"

    # ניסיון חישוב זמני היום והוספתם למערך הזמנים
    # בגלל שיש מקומות שאין זריחה ושקיעה, ויש מקומות שאין עלות השחר לכדומה לכן הכל בניסיון וגם כל זמן שתלוי בגובה השמש נמצא בניסיון
    try:

        # הצגת הודעה למשתמש בזמן ההמתנה לאיסוף הזמנים
        Waiting_halacha_times = Toplevel(ws)
        Waiting_halacha_times.geometry(f"{round(500*magnification_factor)}x{round(250*magnification_factor)}+{round(80*magnification_factor)}+{round(200*magnification_factor)}")
        # הגדרת צבע לכל החלון
        Waiting_halacha_times.configure(bg=cu_color)
        # מיקום חלון ההמתנה מעל החלון הראשי
        Waiting_halacha_times.wm_transient(ws)
        Waiting_halacha_times.title('נא להמתין לחישוב הנתונים' if is_heb_locale else "Please wait for data calculations")
        msg = f"\nנא המתינו בסבלנות לסיום חישוב הזמנים\nבסיום, תתבקשו לבחור היכן לשמור את הקובץ\n\nאין להשתמש בתוכנה במהלך חישוב הזמנים\nניתן לבטל את חישוב הזמנים על ידי סגירת חלון זה"
        en_msg = f"\nPlease wait patiently for the times calculation to finish\nAt the end, you will be asked to choose where to save the file\n\nDo not use the software during the time calculation\nYou can cancel the time calculation by closing this window"
        Label(Waiting_halacha_times, text=msg if is_heb_locale else en_msg, font="david 16" if is_heb_locale else "david 14",justify="center").pack()
        Label(Waiting_halacha_times, text="\nהתאריך המחושב כעת" if is_heb_locale else "\nThe currently calculated date", font="david 16",justify="center").pack()
        current_calculation = Label(Waiting_halacha_times, text="עדיין לא מחושב", font="david 16 bold",justify="center")
        current_calculation.pack()
        # חובה!!! עדכון ידני של חלון ההודעה כדי לוודא שהוא מוצג לפני ביצוע המשך הקוד
        Waiting_halacha_times.update()

        # עבור כל תאריך במערך התאריכים
        for date in all_dates:

            time = location_timezone.localize(date)
            time = time.replace(hour=0, minute=0, second=0, microsecond=0) # חשוב מאוד להתחיל את החישובים בתחילת היממה

            # הגדרת תאריך עברי מקביל לתאריך הלועזי, ולמחרתו
            heb = dates.GregorianDate(1880, 10, 20).from_pydate(time).to_heb()
            heb_for_print = f'{heb_string_day(heb.weekday())} - {heb.hebrew_date_string(True)}'

            # הגדרת תאריך לועזי להדפסה
            greg_for_print = f'{heb_string_day(heb.weekday())} - {time:%d/%m/%Y}'


            # הכנת מערך עבור כל הזמנים ובתחילתו התאריכים
            halacha_times = [heb_for_print,greg_for_print]

            # הקטנת מונה התאריכים באחד בכל יום שעובר כדי שנדע כמה תאריכים נשארו לחישוב
            dates_counter -=1 
            # משתנה שקובע האם מחושב כעת תאריך עברי או לועזי ולפי זה איזה תאריך להציג
            current_calculation_greg_or_heb = heb_for_print if choice_zmanim_export.get() in ["HEB_MONTH","HEB_YEAR"] else greg_for_print
            # להכניס לחלון ההמתנה את התאריך העברי/הלועזי שבו אוחזים כעת
            current_calculation.config(text=f"{current_calculation_greg_or_heb} (נותרו {dates_counter} תאריכים לחישוב)")
            # חובה!!! עדכון ידני של חלון ההודעה כדי לוודא שהוא מוצג לפני ביצוע המשך הקוד
            Waiting_halacha_times.update()


            # עלות השחר ודמדומי בוקר


            try:
                SR,_,_,_,_,_ = calculate_rising_seting(time,location,location_timezone,horizon=-25.9, body="sun")
                #txt2.insert("end", f'\nעלות השחר 25.9°- (5 מיל 24):    {SR:%H:%M:%S}')
                halacha_times.append(f'{SR:%H:%M:%S}')
            except IndexError:
                #txt2.insert("end", f'\nעלות השחר 25.9°- (5 מיל 24):    {eror}')
                halacha_times.append(f'{eror}')


            try:
                SR,_,_,_,_,_ = calculate_rising_seting(time,location,location_timezone,horizon=-19.75, body="sun")
                #txt2.insert("end", f'\nעלות השחר 19.75°- (4 מיל 22.5):    {SR:%H:%M:%S}')
                halacha_times.append(f'{SR:%H:%M:%S}')
            except IndexError:
                #txt2.insert("end", f'\nעלות השחר 19.75°- (4 מיל 22.5):    {eror}')
                halacha_times.append(f'{eror}')

            try:
                SR,_,_,SR_az,_,_ = calculate_rising_seting(time,location,location_timezone,horizon=-18, body="sun")
                #txt2.insert("end", f'\nתחילת דמדומים אסטרונומיים 18°-:    {SR:%H:%M:%S}    באזימוט:   {SR_az :02.1f}°')
                halacha_times.append(f'{SR:%H:%M:%S}')
            except IndexError:
                #txt2.insert("end", f'\nתחילת דמדומים אסטרונומיים 18°-:    {eror}')
                halacha_times.append(f'{eror}')

            try:
                SR,_,_,_,_,_ = calculate_rising_seting(time,location,location_timezone,horizon=-16, body="sun")
                #txt2.insert("end", f'\nעלות השחר 16°- (4 מיל 18):    {SR:%H:%M:%S}')
                halacha_times.append(f'{SR:%H:%M:%S}')
            except IndexError:
                #txt2.insert("end", f'\nעלות השחר 16°- (4 מיל 18):    {eror}')
                halacha_times.append(f'{eror}')

            try:
                SR,_,_,SR_az,_,_ = calculate_rising_seting(time,location,location_timezone,horizon=-14, body="sun")
                #txt2.insert("end", f'\nעלות השחר נראה (הרב ניימאן) 14°-:    {SR:%H:%M:%S}    באזימוט:   {SR_az :02.1f}°')
                halacha_times.append(f'{SR:%H:%M:%S}')
            except IndexError:
                #txt2.insert("end", f'\nעלות השחר נראה (הרב ניימאן) 14°-:    {eror}')
                halacha_times.append(f'{eror}')

            try:
                SR,_,_,_,_,_ = calculate_rising_seting(time,location,location_timezone,horizon=-12, body="sun")
                #txt2.insert("end", f'\nתחילת דמדומים ימיים (והאיר המזרח) 12°-:    {SR:%H:%M:%S}')
                halacha_times.append(f'{SR:%H:%M:%S}')
            except IndexError:
                #txt2.insert("end", f'\nתחילת דמדומים ימיים (והאיר המזרח) 12°-:    {eror}')
                halacha_times.append(f'{eror}')

            try:
                SR,_,_,_,_,_ = calculate_rising_seting(time,location,location_timezone,horizon=-10.5, body="sun")
                #txt2.insert("end", f'\nמשיכיר את חבירו ברחוק 4 אמות 10.5°-:    {SR:%H:%M:%S}')
                halacha_times.append(f'{SR:%H:%M:%S}')
            except IndexError:
                #txt2.insert("end", f'\nמשיכיר את חבירו ברחוק 4 אמות 10.5°-:    {eror}')
                halacha_times.append(f'{eror}')

            try:
                SR,_,_,_,_,_ = calculate_rising_seting(time,location,location_timezone,horizon=-6, body="sun")
                #txt2.insert("end", f'\nתחילת דמדומים אזרחיים 6°-:    {SR:%H:%M:%S}')
                halacha_times.append(f'{SR:%H:%M:%S}')
            except IndexError:
                #txt2.insert("end", f'\nתחילת דמדומים אזרחיים 6°-:    {eror}')
                halacha_times.append(f'{eror}')


            # הנץ

            # חישוב השפעת גובה העיר במקרה שהעיר גבוהה או נמוכה
            if location.elevation.m != 0:
                Z = calculate_elevation_rise_set(location.elevation.m)
                SR,SS,_,_,_,_ = calculate_rising_seting(time,location,location_timezone,horizon=Z, body="sun")
                #txt2.insert("end", f'\nכשאין הסתרות!! בערך זריחה נראית בגובה העיר {str(round(Z,2))[1:]}°{"-" if Z < 0 else "+"}:    {SR:%H:%M:%S}')
                halacha_times.append(f'{SR:%H:%M:%S}')
            else:
                halacha_times.append(f'העיר בגובה 0')

            SR,SS,_,_,_,_ = calculate_rising_seting(time,location,location_timezone,horizon=-0.833, body="sun")
            #txt2.insert("end", f'\nזריחה נראית במישור 0.833°-:    {SR:%H:%M:%S}')
            halacha_times.append(f'{SR:%H:%M:%S}')

            SR,SS,_,SR_az,_,_ = calculate_rising_seting(time,location,location_timezone,horizon=0, body="sun")
            #txt2.insert("end", f'\nזריחה גיאומטרית 0°:    {SR:%H:%M:%S}    באזימוט:   {SR_az :02.1f}°')
            halacha_times.append(f'{SR:%H:%M:%S}')


            # שעות זמניות וחצות

            SR,SS,_,_,_,_ = calculate_rising_seting(time,location,location_timezone,horizon=-0.833, body="sun")
            # חישוב כמה שניות יש בין השקיעה האחרונה לזריחה הקרובה בחלוקה לשתיים עשרה, שזה אומר כמה שניות יש בשעה זמנית של הלילה
            sec_TH = (SS - SR) / 12
            # חישוב מספר הדקות והשניות שיש בשעה זמנית אחת של היום, והדפסתם בפורמט של דקות ושניות
            minutes_in_temporal_hour = convert_seconds(sec_TH.total_seconds())
            #txt2.insert("end", f'\nאורך שעה זמנית של היום (דקות ושניות):    {minutes_in_temporal_hour}')
            halacha_times.append(f'{minutes_in_temporal_hour}')

            try:
                SR,SS,_,_,_,_ = calculate_rising_seting(time,location,location_timezone,horizon=-16, body="sun")
                #txt2.insert("end", f'\nסוף זמן שמע מג"א (לפי 16°-):    {(SR) + (((SS - SR) / 12) *3):%H:%M:%S}')
                halacha_times.append(f'{(SR) + (((SS - SR) / 12) *3):%H:%M:%S}')
            except IndexError:
                #txt2.insert("end", f'\nסוף זמן שמע מג"א (לפי 16°-):    {eror}')
                halacha_times.append(f'{eror}')

            SR,SS,_,_,_,_ = calculate_rising_seting(time,location,location_timezone,horizon=-0.833, body="sun")
            #txt2.insert("end", f'\nסוף זמן שמע גר"א (שעה 3):    {(SR) + (((SS - SR) / 12) *3):%H:%M:%S}')
            halacha_times.append(f'{(SR) + (((SS - SR) / 12) *3):%H:%M:%S}')

            try:
                SR,SS,_,_,_,_ = calculate_rising_seting(time,location,location_timezone,horizon=-16, body="sun")
                #txt2.insert("end", f'\nסוף זמן תפילה מג"א (לפי 16°-):    {(SR) + (((SS - SR) / 12) *4):%H:%M:%S}')
                halacha_times.append(f'{(SR) + (((SS - SR) / 12) *4):%H:%M:%S}')
            except IndexError:
                #txt2.insert("end", f'\nסוף זמן תפילה מג"א (לפי 16°-):    {eror}')
                halacha_times.append(f'{eror}')

            SR,SS,_,_,_,_ = calculate_rising_seting(time,location,location_timezone,horizon=-0.833, body="sun")
            #txt2.insert("end", f'\nסוף זמן תפילה גר"א (שעה 4):    {(SR) + (((SS - SR) / 12) *4):%H:%M:%S}')
            halacha_times.append(f'{(SR) + (((SS - SR) / 12) *4):%H:%M:%S}')

            SR,SS,_,_,_,_ = calculate_rising_seting(time,location,location_timezone,horizon=-0.833, body="sun")
            #txt2.insert("end", f'\nסוף זמן ביעור חמץ בערב פסח (שעה 5):    {(SR) + (((SS - SR) / 12) *5):%H:%M:%S}')
            halacha_times.append(f'{(SR) + (((SS - SR) / 12) *5):%H:%M:%S}')

            day_transit,_,_,_ = calculate_transits_and_equation_of_time(time,location,location_timezone)
            #txt2.insert("end", f'\nחצות היום (כשעה 6 - וכעין זה חצות הלילה):    {day_transit:%H:%M:%S}')
            halacha_times.append(f'{day_transit:%H:%M:%S}')

            SR,SS,_,_,_,_ = calculate_rising_seting(time,location,location_timezone,horizon=-0.833, body="sun")
            #txt2.insert("end", f'\nמנחה גדולה (שעה 6.5):    {(SR) + (((SS - SR) / 12) *6.5):%H:%M:%S}')
            halacha_times.append(f'{(SR) + (((SS - SR) / 12) *6.5):%H:%M:%S}')

            SR,SS,_,_,_,_ = calculate_rising_seting(time,location,location_timezone,horizon=-0.833, body="sun")
            #txt2.insert("end", f'\nסוף זמן מוסף לכתחילה (שעה 7):    {(SR) + (((SS - SR) / 12) *7):%H:%M:%S}')
            halacha_times.append(f'{(SR) + (((SS - SR) / 12) *7):%H:%M:%S}')

            SR,SS,_,_,_,_ = calculate_rising_seting(time,location,location_timezone,horizon=-0.833, body="sun")
            #txt2.insert("end", f'\nסמוך למנחה קטנה (שעה 9):    {(SR) + (((SS - SR) / 12) *9):%H:%M:%S}')
            halacha_times.append(f'{(SR) + (((SS - SR) / 12) *9):%H:%M:%S}')

            SR,SS,_,_,_,_ = calculate_rising_seting(time,location,location_timezone,horizon=-0.833, body="sun")
            #txt2.insert("end", f'\nמנחה קטנה (שעה 9.5):    {(SR) + (((SS - SR) / 12) *9.5):%H:%M:%S}')
            halacha_times.append(f'{(SR) + (((SS - SR) / 12) *9.5):%H:%M:%S}')

            SR,SS,_,_,_,_ = calculate_rising_seting(time,location,location_timezone,horizon=-0.833, body="sun")
            #txt2.insert("end", f'\nפלג המנחה (שעה 10.75):    {(SR) + (((SS - SR) / 12) *10.75):%H:%M:%S}')
            halacha_times.append(f'{(SR) + (((SS - SR) / 12) *10.75):%H:%M:%S}')


            # שקיעה

            _,SS,_,_,_,SS_az = calculate_rising_seting(time,location,location_timezone,horizon=0, body="sun")
            #txt2.insert("end", f'\nשקיעה גיאומטרית 0°:    {SS:%H:%M:%S}    באזימוט:   {SS_az :02.1f}°')
            halacha_times.append(f'{SS:%H:%M:%S}')

            _,SS_N,_,_,_,_ = calculate_rising_seting(time,location,location_timezone,horizon=-0.833, body="sun")
            #txt2.insert("end", f'\nשקיעה נראית במישור 0.833°-:    {SS_N:%H:%M:%S}')
            halacha_times.append(f'{SS_N:%H:%M:%S}')

            # חישוב השפעת גובה העיר במקרה שהעיר גבוהה או נמוכה
            if location.elevation.m != 0:
                Z = calculate_elevation_rise_set(location.elevation.m)
                SR,SS,_,_,_,_ = calculate_rising_seting(time,location,location_timezone,horizon=Z, body="sun")
                #txt2.insert("end", f'\nכשאין הסתרות!! בערך שקיעה נראית בגובה העיר {str(round(Z,2))[1:]}°{"-" if Z < 0 else "+"}:    {SS:%H:%M:%S}')
                halacha_times.append(f'{SS:%H:%M:%S}')
            else:
                halacha_times.append(f'העיר בגובה 0')

            # צאת הכוכבים ודמדומי ערב

            try:
                _,SS,_,_,_,_ = calculate_rising_seting(time,location,location_timezone,horizon=-3.65, body="sun")
                # חישוב הפרש הדקות משקיעה מישורית נראית 0.833 עד צאת הכוכבים
                #SHEIYA = (SS - SS_N).total_seconds()
                #txt2.insert("end", f'\nצאת הכוכבים 3.65°- (3/4 מיל 18):    {SS:%H:%M:%S}     (דקות משקיעה מישורית: {convert_seconds(SHEIYA)})')
                halacha_times.append(f'{SS:%H:%M:%S}')
            except IndexError:
                #txt2.insert("end", f'\nצאת הכוכבים 3.65°- (3/4 מיל 18):    {eror}')
                halacha_times.append(f'{eror}')

            try:
                _,SS,_,_,_,_ = calculate_rising_seting(time,location,location_timezone,horizon=-4, body="sun")
                #txt2.insert("end", f'\nצאת הכוכבים 4°- (20 דקות משקיעה גיאומטרית, ממוצע שנתי בארץ ישראל):     {SS:%H:%M:%S}')
                halacha_times.append(f'{SS:%H:%M:%S}')
            except IndexError:
                #txt2.insert("end", f'\nצאת הכוכבים 4°- (20 דקות משקיעה גיאומטרית, ממוצע שנתי בארץ ישראל):     {eror}')
                halacha_times.append(f'{eror}')


            try:
                _,SS,_,_,_,_ = calculate_rising_seting(time,location,location_timezone,horizon=-4.37, body="sun")
                # חישוב הפרש הדקות משקיעה מישורית נראית 0.833 עד צאת הכוכבים
                #SHEIYA = (SS - SS_N).total_seconds()
                #txt2.insert("end", f'\nצאת הכוכבים 4.37°- (3/4 מיל 22.5):    {SS:%H:%M:%S}     (דקות משקיעה מישורית: {convert_seconds(SHEIYA)})')
                halacha_times.append(f'{SS:%H:%M:%S}')
            except IndexError:
                #txt2.insert("end", f'\nצאת הכוכבים 4.37°- (3/4 מיל 22.5):     {eror}')
                halacha_times.append(f'{eror}')

            try:
                _,SS,_,_,_,_ = calculate_rising_seting(time,location,location_timezone,horizon=-4.61, body="sun")
                # חישוב הפרש הדקות משקיעה מישורית נראית 0.833 עד צאת הכוכבים
                #SHEIYA = (SS - SS_N).total_seconds()
                #txt2.insert("end", f'\nצאת הכוכבים 4.61°- (3/4 מיל 24):    {SS:%H:%M:%S}     (דקות משקיעה מישורית: {convert_seconds(SHEIYA)})')
                halacha_times.append(f'{SS:%H:%M:%S}')
            except IndexError:
                #txt2.insert("end", f'\nצאת הכוכבים 4.61°- (3/4 מיל 24):     {eror}')
                halacha_times.append(f'{eror}')

            try:
                _,SS,_,_,_,_ = calculate_rising_seting(time,location,location_timezone,horizon=-6, body="sun")
                #txt2.insert("end", f'\nסוף דמדומים אזרחיים (וצאת כוכבים קטנים) 6°-:    {SS:%H:%M:%S}')
                halacha_times.append(f'{SS:%H:%M:%S}')
            except IndexError:
                #txt2.insert("end", f'\nסוף דמדומים אזרחיים (וצאת כוכבים קטנים) 6°-:     {eror}')
                halacha_times.append(f'{eror}')

            try:
                _,SS,_,_,_,_ = calculate_rising_seting(time,location,location_timezone,horizon=-8.5, body="sun")
                # חישוב הפרש הדקות משקיעה מישורית נראית 0.833 עד צאת הכוכבים
                #SHEIYA = (SS - SS_N).total_seconds()
                #txt2.insert("end", f'\nצאת שבת לוחות הגרימ"ט 8.5°-:    {SS:%H:%M:%S}     (דקות משקיעה מישורית: {convert_seconds(SHEIYA)})')
                halacha_times.append(f'{SS:%H:%M:%S}')
            except IndexError:
                #txt2.insert("end", f'\nצאת שבת לוחות הגרימ"ט 8.5°-:     {eror}')
                halacha_times.append(f'{eror}')

            try:
                _,SS,_,_,_,_ = calculate_rising_seting(time,location,location_timezone,horizon=-12, body="sun")
                #txt2.insert("end", f'\nסוף דמדומים ימיים 12°-:    {SS:%H:%M:%S}')
                halacha_times.append(f'{SS:%H:%M:%S}')
            except IndexError:
                #txt2.insert("end", f'\nסוף דמדומים ימיים 12°-:     {eror}')
                halacha_times.append(f'{eror}')

            try:
                _,SS,_,_,_,SS_az = calculate_rising_seting(time,location,location_timezone,horizon=-14, body="sun")
                #txt2.insert("end", f'\nסוף דמדומים נראים (מקביל לרב ניימאן שבבוקר) 14°-:    {SS:%H:%M:%S}    באזימוט:   {SS_az :02.1f}°')
                halacha_times.append(f'{SS:%H:%M:%S}')
            except IndexError:
                #txt2.insert("end", f'\nסוף דמדומים נראים (מקביל לרב ניימאן שבבוקר) 14°-:     {eror}')
                halacha_times.append(f'{eror}')

            try:
                _,SS,_,_,_,_ = calculate_rising_seting(time,location,location_timezone,horizon=-16, body="sun")
                # חישוב הפרש הדקות משקיעה מישורית נראית 0.833 עד צאת הכוכבים
                #SHEIYA = (SS - SS_N).total_seconds()
                #txt2.insert("end", f'\nצאת הכוכבים רבינו תם 16°- (4 מיל 18):    {SS:%H:%M:%S}     (דקות משקיעה מישורית: {convert_seconds(SHEIYA)})')
                halacha_times.append(f'{SS:%H:%M:%S}')
            except IndexError:
                #txt2.insert("end", f'\nצאת הכוכבים רבינו תם 16°- (4 מיל 18):     {eror}')
                halacha_times.append(f'{eror}')

            try:
                _,SS,_,_,_,SS_az = calculate_rising_seting(time,location,location_timezone,horizon=-18, body="sun")
                #txt2.insert("end", f'\nסוף דמדומים אסטרונומיים 18°-:    {SS:%H:%M:%S}    באזימוט:   {SS_az :02.1f}°')
                halacha_times.append(f'{SS:%H:%M:%S}')
            except IndexError:
                #txt2.insert("end", f'\nסוף דמדומים אסטרונומיים 18°-:     {eror}')
                halacha_times.append(f'{eror}')

            try:
                _,SS,_,_,_,_ = calculate_rising_seting(time,location,location_timezone,horizon=-19.75, body="sun")
                # חישוב הפרש הדקות משקיעה מישורית נראית 0.833 עד צאת הכוכבים
                #SHEIYA = (SS - SS_N).total_seconds()
                #txt2.insert("end", f'\nצאת הכוכבים רבינו תם 19.75°- (4 מיל 22.5):    {SS:%H:%M:%S}     (דקות משקיעה מישורית: {convert_seconds(SHEIYA)})')
                halacha_times.append(f'{SS:%H:%M:%S}')
            except IndexError:
                #txt2.insert("end", f'\nצאת הכוכבים רבינו תם 19.75°- (4 מיל 22.5):     {eror}')
                halacha_times.append(f'{eror}')


            try:
                _,SS,_,_,_,_ = calculate_rising_seting(time,location,location_timezone,horizon=-25.9, body="sun")
                # חישוב הפרש הדקות משקיעה מישורית נראית 0.833 עד צאת הכוכבים
                #SHEIYA = (SS - SS_N).total_seconds()
                #txt2.insert("end", f'\nצאת הכוכבים רבינו תם 25.9°- (5 מיל 24):    {SS:%H:%M:%S}     (דקות משקיעה מישורית: {convert_seconds(SHEIYA)})')
                halacha_times.append(f'{SS:%H:%M:%S}')
            except IndexError:
                #txt2.insert("end", f'\nצאת הכוכבים רבינו תם 25.9°- (5 מיל 24):     {eror}')
                halacha_times.append(f'{eror}')


            # זמני הירח

            try:
                MR,MS,_,MR_az,_,_ = calculate_rising_seting(time,location,location_timezone,horizon=0, body="moon",PLUS_MINUS = "PLUS")
                if time.date() == MR.date():
                    #txt2.insert("end", f'\nזריחת הירח:   {MR:%H:%M:%S}    באזימוט:   {MR_az :02.1f}°')
                    halacha_times.append(f'{MR:%H:%M:%S}')
                else:
                    #txt2.insert("end", f'\nאין זריחת ירח במיקום גיאוגרפי זה בתאריך גרגוריאני זה:    {time:%d/%m/%Y}')
                    halacha_times.append(f'אין זריחת ירח במיקום גיאוגרפי זה בתאריך גרגוריאני זה')
            except IndexError:
                halacha_times.append(f'{eror}')


            try:
                MR,MS,_,MR_az,_,_ = calculate_rising_seting(time,location,location_timezone,horizon=0, body="moon",PLUS_MINUS = "PLUS")
                if time.date() == MS.date():
                    #txt2.insert("end", f'\nשקיעת הירח:   {MS:%H:%M:%S}    באזימוט:   {MS_az :02.1f}°')
                    halacha_times.append(f'{MS:%H:%M:%S}')
                else:
                    #txt2.insert("end", f'\nאין שקיעת ירח במיקום גיאוגרפי זה בתאריך גרגוריאני זה:    {time:%d/%m/%Y}')
                    halacha_times.append(f'אין שקיעת ירח במיקום גיאוגרפי זה בתאריך גרגוריאני זה')
            except IndexError:
                halacha_times.append(f'{eror}')



            # הוספת כל הזמנים של כל יום לתוך מערך הטורים
            zmanim.append(halacha_times)


        # סגירת חלון ההמתנה לאחר ביצוע כל החישובים של פונקצייה זו
        Waiting_halacha_times.destroy()

        # הגדרת ברירת מחדש עבור שם קובץ הזמנים
        default_initialfile = f"{city_for_print} קובץ זמני הלכה {chodshi_shnati}"

        # שם הקובץ עבור לוח הזמנים
        filename = asksaveasfilename(defaultextension=".csv", initialfile = default_initialfile)

        # שמירת הקובץ תוך אפשרות ציון הקידוד המתאים
        # אפשרויות קידוד: cu_encod או "utf-8"
        # איף פיילניים נועד למנוע שגיאה במקרה שסגרו את החלון כי החליטו לא לשמור את הקובץ
        if filename:
            with open(filename, 'w', newline='', encoding=default_encoding) as file:
                writer = csv.writer(file)
                writer.writerows(zmanim)

        # לאחר השמירה, ריקון של המשתנה שמכיל את כל הנתונים כדי שלא יהיה עומס בזיכרון
        zmanim = 1


        '''
            hitkabzut,nigud = hitkabzut_nigud_calculations(time,location,location_timezone,body="moon",PLUS_MINUS="PLUS",plus_minus_days=50)
            txt2.insert("end", f'\nמולד ירח אמיתי קרוב:    {hitkabzut:%d/%m/%Y}     בשעה   {hitkabzut:%H:%M:%S}')
            txt2.insert("end", f'\nניגוד ירח אמיתי קרוב (ירח מלא):    {nigud:%d/%m/%Y}     בשעה   {nigud:%H:%M:%S}')

            txt2.insert("end", f'\n\nתקופות אמיתיות\n')

            Vernal_Equinox,Summer_Solstice,Autumnal_Equinox,Winter_Solstice=Real_tkufot(time,location,location_timezone,PLUS_MINUS="PLUS",plus_minus_days=400)
            txt2.insert("end", f'\nשוויון אביב הבא:    {Vernal_Equinox:%d/%m/%Y}     בשעה:   {Vernal_Equinox:%H:%M:%S}')
            txt2.insert("end", f'\nשוויון סתיו הבא:    {Autumnal_Equinox:%d/%m/%Y}     בשעה:   {Autumnal_Equinox:%H:%M:%S}')
            txt2.insert("end", f'\nהיפוך קיץ הבא:    {Summer_Solstice:%d/%m/%Y}     בשעה:   {Summer_Solstice:%H:%M:%S}')
            txt2.insert("end", f'\nהיפוך חורף הבא:    {Winter_Solstice:%d/%m/%Y}     בשעה:   {Winter_Solstice:%H:%M:%S}')

            txt2.insert("end", f'\n\n') 
            '''

    # במקרה שיש שגיאה בחישוב הזריחות והשקיעות
    except IndexError:
        tkMessageBox.showinfo("שגיאה", "עבור המיקום הנוכחי בתאריך הנוכחי, התוכנה אינה יכולה לחשב את זמני זריחות/שקיעות/חצות ")

####################################################################################################################
                              # יצוא מידע על הירח לקובץ סי.אס.וי
####################################################################################################################


# פונקצייה להוספת ירחים ראשונים/אחרונים לכל השנה העברית הנוכחית לקובץ אקסל או סי. אס. וי
# משתנה שקובע האם לחשב ירח ראשון או אחרון מוגדר כברירת מחדל על ירח ראשון
# משתנה איזה אירועים להדפיס: כברירת מחדל הכל גם כשהירח לא נראה בעין
def export_calendar_moons(first_last = "first", events_to_print = "הכל"):
    
    # אם המשתמש לחץ על כפתור חישוב ירח אחרון: שינוי של המשתנה שקובע האם לחשב ירח ראשון או אחרון שלא יהיה מוגדר על חישוב ירח ראשון
    if choice_moon_export.get() == "LAST":
        first_last = "last"
    
    # אפשרויות ההגדרה אילו ימים יש להדפיס לקובץ
    #events_to_print = "נראה_במשקפת_או_בעין_לפי_הופמן"
    #events_to_print = "נראה_בעין_לפי_הופמן"
    #events_to_print = "נראה_לפי_רמבם"
    #events_to_print = "הכל" 
     

    # דבר ראשון, הגדרת פונקצייה משנית של הדפסות עבור כל נתוני הירח
    # משתנה עבור יום בדיקת הראייה, ומשתנה התקבצות כדי לבדוק כמה שעות יש עד המולד
    def print_all_about_moon (moon_search_day, hitkabzut):
        
        # החלק העליון של התוכנה פועל תמיד, אבל החלק שתלוי בחישובי זריחה ושקיעה לא פועל במקום שאין בו זריחה ושקיעה בכל יום כגון באיזור הקוטב הצפוני
        try:
            
            # אם מדובר בחישוב ירח ראשון: חישוב שעת שקיעה גיאומטרית הראשונה של הירח לאחר! שעת המולד: התוצאה תהיה יום ראשון לחישוב אפשרות הראייה
            # אם מדובר בחישוב ירח אחרון: חישוב שעת זריחה גיאומטרית האחרונה של הירח לפני! שעת המולד: התוצאה תהיה יום ראשון לחישוב אפשרות הראייה
            MR,MS,MR_alt,MR_az,MS_alt,MS_az = calculate_rising_seting(moon_search_day,location,location_timezone,horizon= 0, body="moon",PLUS_MINUS = "PLUS" if first_last == "first" else "MINUS")

            # קביעת משתנה עבור נקודת תחילת החישובים 
            # אם מדובר בירח ראשון זה שקיעת הירח הראשונה לאחר המולד ואם מדובר בירח אחרון זה זריחת הירח האחרונה לפני המולד
            # כאשר מריצים את הפונקצייה בפעם השנייה הנקודה הזו מייצגת את שקיעה/זריחה של יום החישוב הבא/הקודם
            # נקודה זו היא מאוד חשובה עבור כל החישובים להלן
            start_point = MS if first_last == "first" else MR
            
            # קביעת משתנה ששומר מהו התאריך הלועזי של יום ראשון לחישוב אפשרות הראייה לצורך ריטרן בסוף עבור חיפוש היום הבא
            sight_day_greg = start_point

            # חישוב שעת זריחה ושקיעה גיאומטריים של השמש בתאריך של נקודת ההתחלה
            # הדגשה: חישוב כללי של זריחה ושקיעה ביום זה, ולא חישוב של שקיעה הבאה
            SR,SS,SR_alt,SR_az,SS_alt,SS_az = calculate_rising_seting(sight_day_greg,location,location_timezone,horizon= 0, body="sun",PLUS_MINUS = "NONE")

            #----------------------
            # כל חישובי קריטריון הראייה של הופמן
            
            if first_last == "first":
                # חישוב שעת הראייה לפי 0.6 של השהייה בין השקיעות הגיאומטריות במקרה של חישוב ירח ראשון
                time_of_vision = SS + timedelta(seconds = (MS - SS).total_seconds() * 0.6)
            else:
                # חישוב שעת הראייה לפי 0.6 של השהייה בין הזריחות הגיאומטריות במקרה של חישוב ירח אחרון
                time_of_vision = SR - timedelta(seconds = (SR - MR).total_seconds() * 0.6)


            # המרת הזמן המקומי של שעת הראייה לפי הופמן לזמן של סקייפילד וחישוב כל נתונים אסטרונומיים של הירח על זמן זה
            time_ov = cu_to_skyfield_time(time_of_vision)
            alt,az,ra,dec,ha,dec_N_S,lat,lon,dist,lat_N_S,percent,apparent_diameter,thickness,slon,elongation,ecliptic_elongation,elongation_E_W,salt,saz = astro_calculations("moon",time_ov,location,location_timezone)

            # שורש ריבועי מייצגים בפייתון כך
            # ** (0.5)))
            # מקדם קלות הראייה לפי הופמן מורכב מהפרש רומים בין השמש לירח בשעת הראייה שזה 0.6 של השהייה יחד עם השורש של עובי סהר הירח
            # הנוסחה היא: הפרשי הגובה בין השמש לירח, פלוס 7.37, כפול שורש עובי הסהר 
            vision_factor = abs(alt-salt) + (7.37 * (thickness ** (0.5))) 
            # אבל הפרשי הגובה הם בין מרכז השמש לבין מרכז הירח ואילו מרכז הסהר נמוך ממרכז הירח לכן ניתן להוסיף להפרשי הגובה עוד רבע מהקוטר הזוויתי הנראה של הירח כדלהלן
            #vision_factor = (abs(alt-salt) + (apparent_diameter / 4 / 60)) + (7.37 * (thickness ** (0.5))) 

            # נרמול של מקדם הראייה הופמן כך שאפס פירושו שאין ראייה בעיין כלל ואחד פירושו שיש ראייה ודאית בעיין ובין אפס לאחד זה טווח אי הוודאות
            normal_vision_factor = (vision_factor - 12.2) / 5.2 
            
            #----------------------
            
            # חישובי תאריך עברי של התאריך הלועזי המחושב כעת 
            sight_day_heb = dates.GregorianDate(1880, 10, 20).from_pydate(sight_day_greg).to_heb()
            sight_day_heb_for_print = f'{heb_string_day(sight_day_heb.weekday())} - {sight_day_heb.hebrew_date_string(True)}'

            # חישוב יום יוליאני של התאריך בלוח השנה הגרגוריאני שהזין המשתמש והמרתו לתאריך בלוח השנה היולאני באמצעות ספרייה ייעודית
            JDa,JDb = jdcal.gcal2jd(sight_day_greg.year,sight_day_greg.month,sight_day_greg.day)
            julian_year_month_day = jdcal.jd2jcal(JDa,JDb) 
            
            
            # חישוב גובה הירח בזמן שקיעה גיאומטרית של השמש ביום ראייה ראשונה או בזמן זריחה גיאומטרית של השמש ביום ראייה אחרונה
            # ידיעת גובה הירח בזמן שקיעת השמש של יום ראייה ראשונה חשובה מאוד כי אז רוב האור יורד ובדרך כלל רק אז אפשר להתחיל לראות את הירח. אפשר לכנות זאת: מציאת גובה ואזימוט הירח בנקודת התגלותו
            # ידיעת גובה הירח בזמן זריחת השמש של יום ראייה אחרונה דומה לזה כי אז רוב האור מתגבר ובדרך כלל מאז אי אפשר יותר לראות את הירח. אפשר לכנות זאת: מציאת גובה ואזימוט הירח בנקודת העלמותו            
            # הערה: לגבי הנתון של חישוב גובה ואזימוט הירח בשעת שקיעת השמש של יום ראייה ראשונה, הייתה לי מחשבה שגויה כיצד להופכו עבור ראייה אחרונה
            ##### החישוב השגוי היה: גובה הירח בזמן שקיעת השמש ביום ראייה ראשונה או גובה !השמש! בזמן זריחת !הירח! ביום ראייה אחרונה #####
            # הרעיון הזה שגוי כי גובה ואזימוט השמש בזמן זריחת הירח של יום ראייה אחרונה לא חשוב כרגע, כי לא רואים אז את השמש 
            
            SR_OR_SS = SS if first_last == "first" else SR
            # המרת זמן השקיעה/הזריחה הגיאומטרית של השמש ביום הראייה לזמן של סקייפילד וחישוב גובה ואזימוט של הירח על זמן זה
            SR_OR_SS_skyfield_time = cu_to_skyfield_time(SR_OR_SS)
            malt, maz, _ = (eph['earth'] + location).at(SR_OR_SS_skyfield_time).observe(eph['moon']).apparent().altaz()
                        
            # חישוב שהייה שזה הפרש זמן בין השקיעות/הזריחות וחישוב קשת ראייה שזה השהייה במעלות משווניות של 4 דקות לכל מעלה
            SHEIYA = (MS - SS).total_seconds() / 60 if first_last == "first" else (SR - MR).total_seconds() / 60
            KESHET_REIYA = SHEIYA / 4

            # גיל הירח בשעות מהמולד האמיתי עד שעת הראייה
            AGE = time_of_vision - hitkabzut if first_last == "first" else hitkabzut - time_of_vision
            AGE = (AGE.days * 24) + ((AGE.total_seconds() / 60) / 60)
            
            # חישובי ראיית הירח לפי שיטת הרמב"ם
            # חישוב שעת הראייה של הרמב"ם: שעה שהשמש בגובה 4 מעלות תחת האופק בתאריך הגרגוריאני של יום הראייה
            # הדגשה: חישוב כללי של זריחה ושקיעה בגובה -4 ביום זה, ולא חישוב של זריחה ושקיעה הבאים
            SR4,SS4,SR4_alt,SR4_az,SS4_alt,SS4_az = calculate_rising_seting(sight_day_greg,location,location_timezone,horizon= -4, body="sun",PLUS_MINUS = "NONE")
            
            # הגדרת שעת הראייה של הרמבם
            time_of_vision4 = SS4 if first_last == "first" else SR4
            
            # המרת הזמן המקומי של שעת הראייה של הרמבם לזמן של סקייפילד וחישוב כל נתונים אסטרונומיים של הירח על זמן זה
            time_ov_4 = cu_to_skyfield_time(time_of_vision4)
            alt4,az4,_,_,_,_,lat4,lon4,_,lat4_N_S,_,_,_,slon4,elongation4,ecliptic_elongation4,elongation4_E_W,_,_ = astro_calculations("moon",time_ov_4,location,location_timezone)
            ORECH_RISHON4 = ecliptic_elongation4
            KITSEI_REIYA = int(ORECH_RISHON4) + KESHET_REIYA
            
            # היתכנות ראייה לפי אורך ראשון - רמבם (הלכות קידוש החודש פרק יז, הלכות ג-ד)
            # וראו מאמרו של לווינגר: חיזוי הראייה
            # קריטריון הרמבם: אורך ראשון מעל 9 או 10 (תלוי בעונה) וקיצי ראייה מעל 22
            # אפשרות נוספת לפי הרמבם: היתכנות ראייה לפי קשת ראייה (הלכות קידוש החודש פרק יז, הלכות טו-טז)
            # if KESHET_REIYA > 9 and KITSEI_REIYA > 22:
            
            # הגדרת אורך ראשון המינמלי הדרוש לראיית הירח לפי שיטת הרמב"ם
            Required_ORECH_RISHON4 = 9 if lon4 >270 or lon4 <90 else 10

            #-----------------------------------
            
            # במקרה שרוצים להדפיס רק ירח שיש סיכוי שייראה בעין/במשקפת/וכו
            # הגדרת משתנה שקובע האם יש לעצור את ההדפסות ולעבור ליום הבא או שיש להדפיס את היום הנוכחי
            # ברירת המחדל היא שיש להדפיס הכל כולל ימים שאי אפשר לראות בהם את הירח
            if normal_vision_factor < -0.7 and events_to_print == "נראה_במשקפת_או_בעין_לפי_הופמן":
                go_to_the_next_day = True
            elif normal_vision_factor < 0 and events_to_print == "נראה_בעין_לפי_הופמן":
                go_to_the_next_day = True
            elif events_to_print == "נראה_לפי_רמבם" and not (ORECH_RISHON4 > Required_ORECH_RISHON4 and KITSEI_REIYA > 22): # אם רוצים רק מקרי ראייה לפי קריטריון הרמבם
                go_to_the_next_day = True
            else:
                go_to_the_next_day = False
                
            # אם המשתנה קובע שיש לעבור ליום הבא, יש לעצור את הפונקצייה, לעבור ליום הבא בירח ראשון / הקודם בירח אחרון, ולהריץ מחדש את הפונקצייה
            if go_to_the_next_day:
                if first_last == "first":
                    moon_search_day = sight_day_greg + timedelta (days = 1, minutes = 1)
                else:
                    moon_search_day = sight_day_greg - timedelta (days = 1, minutes = 1)
                return print_all_about_moon (moon_search_day, hitkabzut)


            #-----------------------------------

            # תחילת ההדפסות

            # הכנת מערך עבור כל ההדפסות
            moon_info = []

            # תאריך החישובים 
            moon_info.append(f'{"מוֹצָאֵי: " if first_last == "first" else ""}{sight_day_heb_for_print}') # תאריך עברי של יום הראייה
            moon_info.append(f'{heb_string_day(sight_day_heb.weekday())} - {sight_day_greg:%d/%m/%Y}') # תאריך גרגוריאני של יום הראייה
            # בגלל הוספת שם היום, שהוא בעברית, נאצלתי להפוך את הסדר של יום/חודש/שנה בתאריך היוליאני
            moon_info.append(f'{heb_string_day(sight_day_heb.weekday())} - {julian_year_month_day[2]:02.0f}/{julian_year_month_day[1]:02.0f}/{julian_year_month_day[0]:02.0f}') # תאריך יוליאני של יום הראייה
            #moon_info.append(f'{JDa+JDb}') # יום יוליאני כללי של יום הראייה שימוש בספריית jdcal
            #moon_info.append(f'{dates.GregorianDate(1880, 10, 20).from_pydate(sight_day_greg).jd}') # יום יוליאני כללי של יום הראייה שימוש בספריית פיי-לוח
            moon_info.append(f'{cu_to_skyfield_time(time_of_vision).tdb :02.6f}') # יום יוליאני מדוייק לשעת הראייה של הופמן
            delta_t = cu_to_skyfield_time(time_of_vision).delta_t # דלטא טי מדוייק לשעת הראייה של הופמן
            moon_info.append(f'{"-" if delta_t < 0 else ""}{convert_seconds(abs(int(delta_t)), to_hours=True)}') # דלטא טי ליום הראייה לפי שעות דקות ושניות כולל סימון כשדלטא טי במינוס
            
            moon_info.append(f'{normal_vision_factor :02.2f}') # מקדם קלות הראייה המנורמל של הופמן
            
            # הדפסה האם הירח ייראה
            
            # במקרה שמדובר בחישוב ירח ראשון והירח עדיין שוקע לפני השמש אפילו שהמולד האמיתי כבר היה
            # מקרה כזה ייתכן כשרוחב הירח גדול ובאיזור גאגרפי מתאים כגון בארץ ישראל ראש חודש כסלו ה'תשפ"ד 
            if first_last == "first" and MS < SS:
                moon_info.append(f'שימו לב! המולד כבר היה אך הירח עדיין שוקע לפני השמש, לפיכך: לא! אפילו במשקפת')
            # במקרה שמדובר בחישוב ירח אחרון והירח כבר זורח אחרי השמש אפילו שהמולד האמיתי עדיין לא היה
            # מקרה כזה ייתכן כשרוחב הירח גדול ובאיזור גאגרפי מתאים כגון בארץ ישראל ירח אחרון של חודש ניסן ה'תשפ"ג 
            elif first_last != "first" and MR > SR:
                moon_info.append(f'שימו לב! המולד עדיין לא היה, אך הירח כבר זורח אחרי השמש, לפיכך: לא! אפילו במשקפת')
            # האם הירח ייראה לפי הופמן
            elif normal_vision_factor <= -0.7:
                moon_info.append(f'{"לא! אפילו במשקפת"}')
            elif normal_vision_factor > -0.7 and normal_vision_factor < 0:
                moon_info.append(f'{"במשקפת-אולי"}')
            elif normal_vision_factor >= 0 and normal_vision_factor < 0.5:
                moon_info.append(f'{"אולי - בקושי רב!"}')
            elif normal_vision_factor >= 0.5 and normal_vision_factor < 1:
                moon_info.append(f'{"כנראה שכן - ייתכן קושי"}')
            elif normal_vision_factor >= 1:
                moon_info.append(f'{"כן! - כשאין עננים"}')


            moon_info.append(f'{KITSEI_REIYA :02.2f}°') # סכום קיצי הראייה רמבם

            # האם הירח ייראה לפי הרמם
            if ORECH_RISHON4 > Required_ORECH_RISHON4 and KITSEI_REIYA > 22:
                moon_info.append(f'כן') # הירח ייראה ביום זה לפי הרמבם
            else: 
                moon_info.append(f'לא!') # הירח לא! ייראה ביום זה לפי הרמבם


            # פירוט נתונים עבור הופמן ואחכ עבור הרמבם
            
            if first_last == "first":
                moon_info.append(f'{SS:%H:%M:%S}') # זמן שקיעת שמש 0
                moon_info.append(f'{SS_az :02.1f}°') # אזימוט שקיעת שמש 0
                moon_info.append(f'{malt.degrees :02.2f}°') # גובה הירח בשקיעת שמש 0
                moon_info.append(f'{maz.degrees :02.1f}°') # אזימוט ירח בשקיעת שמש 0
                moon_info.append(f'{MS:%H:%M:%S}') # זמן שקיעת ירח 0
                moon_info.append(f'{MS_az :02.1f}°') # אזימוט שקיעת ירח 0
                moon_info.append(f'{SHEIYA :02.2f}') # שְׁהִיָיה - הפרש דקות בין השקיעות הגיאומטריות

            else:
                moon_info.append(f'{MR:%H:%M:%S}') # זמן זריחת ירח 0
                moon_info.append(f'{MR_az :02.1f}°') # אזימוט זריחת ירח 0
                moon_info.append(f'{SR:%H:%M:%S}') # זמן זריחת שמש 0
                moon_info.append(f'{SR_az :02.1f}°') # אזימוט זריחת שמש 0
                moon_info.append(f'{malt.degrees :02.2f}°') # גובה הירח בזריחת שמש 0
                moon_info.append(f'{maz.degrees :02.1f}°') # אזימוט הירח בזריחת שמש 0
                moon_info.append(f'{SHEIYA :02.2f}') # שְׁהִיָיה - הפרש דקות בין הזריחות הגיאומטריות
                

            moon_info.append(f'{time_of_vision:%H:%M:%S}') # (שעת הראייה המיטבית ליום זה לפי הופמן (0.6 של השְׁהִיָיה
            moon_info.append(f'{alt :02.2f}°') # גובה הירח בשעת הופמן
            moon_info.append(f'{az :02.1f}°') # אזימוט הירח בשעת הופמן
            moon_info.append(f'{salt :02.2f}°') # גובה השמש בשעת הופמן
            moon_info.append(f'{saz :02.1f}°') # אזימוט השמש בשעת הופמן

            moon_info.append(f'{abs(alt-salt) :02.2f}°') # הפרש גובה שמש ירח בשעת הופמן
            moon_info.append(f'{abs(az-saz) :02.1f}°') # הפרש אזימוט שמש ירח בשעת הופמן
            moon_info.append(f'{thickness :02.2f}') # עובי סהר הירח, בדקות קשת, בשעת הופמן


            moon_info.append(f'{AGE :02.2f}') # שעות שחלפו מהמולד האמיתי עד שעת הופמן/שעות שיחלפו משעת הופמן עד המולד האמיתי 
            moon_info.append(f'{percent :02.2f}') # אחוזי התאורה של הירח בשעת הופמן
            moon_info.append(f'{dist :,.1f}') # מרחק הירח מכדור הארץ בקילומטרים בשעת הופמן


            # שעת הראייה של הרמב"ם: כמו שליש שעה לאחר השקיעה/לפני הזריחה הגיאומטרית. גובה השמש בזמן זה בממוצע שנתי בארץ ישראל: 4 מעלות תחת האופק
            if first_last == "first":
                moon_info.append(f'{SS4:%H:%M:%S}') # שעת הראייה של הרמבם - שמש בגובה מינוס 4
            else:
                moon_info.append(f'{SR4:%H:%M:%S}') # שעת הראייה של הרמבם - שמש בגובה מינוס 4
            
            moon_info.append(f'{alt4 :02.2f}°') # גובה הירח בשעת הרמבם
            moon_info.append(f'{az4 :02.1f}°') # אזימוט הירח בשעת הרמבם

            moon_info.append(f'{slon4 :02.2f}°') # אורך השמש בשעת הרמבם
            moon_info.append(f'{lon4 :02.2f}°') # אורך הירח בשעת הרמבם
            moon_info.append(f'{lat4 :02.2f}° {lat4_N_S}') # רוחב הירח בשעת הרמבם
            moon_info.append(f'{elongation4 :02.2f}° {elongation4_E_W}') # אלונגציה אמיתית שמש-לירח בשעת הרמבם
            moon_info.append(f'{ORECH_RISHON4 :02.2f}°') # אלונגציה על המלקה שמש-לירח בשעת הרמבם = אורך ראשון
            moon_info.append(f'{KESHET_REIYA :02.2f}°') # קשת ראייה בשעת הרמבם  = שהייה במעלות משווניות

             
            # הוספת כל הזמנים של כל יום לתוך מערך הטורים
            moons_zmanim.append(moon_info)
            
            # שורה ריווח
            #moons_zmanim.append([])


        # במקרה שיש שגיאה בחישוב הזריחות והשקיעות
        except IndexError:
            #tkMessageBox.showinfo("שגיאה", "עבור המיקום הנוכחי בתאריך הנוכחי, התוכנה אינה יכולה לחשב את זמני זריחות/שקיעות/חצות ")
            moons_zmanim.append("שגיאה! עבור המיקום הנוכחי בתאריך הנוכחי התוכנה אינה יכולה לחשב זמני שקיעות")
            sight_day_greg = "NONE"
            

        # מקרים שבהם ברור שהירח ייראה או לחילופין יש שגיאה, ולכן יש לעצור את המשך החישובים ולא לעבור להדפסת היום הבא
        if sight_day_greg == "NONE":
            stop_the_calculations = True
        elif events_to_print != "נראה_לפי_רמבם" and normal_vision_factor >= 1:
            stop_the_calculations = True
        elif events_to_print == "נראה_לפי_רמבם" and ORECH_RISHON4 > Required_ORECH_RISHON4 and KITSEI_REIYA > 22:
            stop_the_calculations = True
        else:
            stop_the_calculations = False
            
        # זה רק לצורך בדיקה    
        #print(f"sight_day_greg {sight_day_greg}, events_to_print {events_to_print}, stop_the_calculations{stop_the_calculations} ddd {ORECH_RISHON4 > Required_ORECH_RISHON4 and KITSEI_REIYA > 22}")

        
        return sight_day_greg, stop_the_calculations

#-------------------------------------------------
# מכאן מתחילה הפונקצייה הראשית

    # אם כפתור הפעלת החישובים לא פעיל, יש לצאת מייד מהפונקצייה
    if C1.get() != 1:
        return
       
# ראשית כל עצירת החישובים הרציפים של התוכנה הראשית כדי לא להכביד על המערכת
    if choice_time.get() == "עכשיו מתעדכן":
        choice_time.set("עכשיו (לפי המחשב)")
        
    # קבלת שעה מקום ואיזור הזמן מהמשתמש
    time,location,location_timezone=time_location_timezone()
    time = time.replace(hour=0, minute=0, second=0, microsecond=0)
    greg = time.astimezone(location_timezone)
    # הגדרת תאריך עברי מקביל לתאריך הלועזי, ולמחרתו
    heb = dates.GregorianDate(1880, 10, 20).from_pydate(greg).to_heb()
    heb_for_print = f'{heb_string_day(heb.weekday())} - {heb.hebrew_date_string(True)}'
    greg_for_print = f'{heb_string_day(heb.weekday())} - {greg:%d/%m/%Y}'

    # חישוב האם קו הרוחב הגיאוגרפי של המיקום הוא צפוני או דרומי, והדפסת קו הרוחב
    location_lat_N_S = 'צפון' if location.latitude.degrees > 0 else 'דרום'
    location_lat_for_print = f'{abs(round(location.latitude.degrees,4))} {location_lat_N_S}'

    # חישוב האם קו האורך הגיאוגרפי של המיקום הוא מזרח או מערב, והדפסת קו האורך
    location_lon_E_W = 'מערב' if location.longitude.degrees < 0 else 'מזרח'
    location_lon_for_print = f'{abs(round(location.longitude.degrees,4))} {location_lon_E_W}'


    # שם המיקום
    city_for_print = city.get()
        
    # משתנה לקביעת המילה העברית האם מדובר בירח ראשון או אחרון
    rishon_acharon = "ראשון" if first_last == "first" else "אחרון"
    
    question = f'\nהאם ליצור קובץ ראִיות ירח {rishon_acharon} לשנה עברית: {heb.hebrew_year(True)}?\nשים לב! אין להשתמש בתוכנה עד לסיום החישובים (כחצי דקה)'
    
    # שאילה האם המשתמש בטוח שברצונו ליצור קובץ זמנים חודשי/שנתי
    msg_box = tkinter.messagebox.askquestion(f'יצירת קובץ ראִיות ירח {rishon_acharon} שנתי לשנה עברית: {heb.hebrew_year(True)}',question,icon='warning', default="no")
    
    # אם המשתמש ענה שהוא רוצה לשנות מיקום
    if msg_box == 'yes':
        
        # איסוף תאריכים של טו בכל חודש עברי של השנה המבוקשת כדי שמהם יהיה אפשר לחשב ראיית ירח של החודש הבא אחריהם
        # הכנת מערך ריק עבור כל התאריכים לחישוב
        all_dates = []

        # הגדרת החודשים העבריים לפי סדרם מאלול לאב אם מדובר בירח ראשון או מתשרי לאלול אם מדובר בירח אחרון
        hebrew_months = [6, 7, 8, 9, 10, 11, 12, 13, 1, 2, 3, 4, 5] if first_last == "first" else [7, 8, 9, 10, 11, 12, 13, 1, 2, 3, 4, 5 ,6]
        
        # עבור כל חודש ברשימת חודשים זו: הוספת התאריך הלועזי המקביל לכל אמצע חודש עברי (טו בחודש) בשנה זו בשעה 12 בצהריים לתוך מערך התאריכים 
        for month in hebrew_months:
            # הגדרת השנה עבור החודש. אם מדובר בירח חדש חודש אלול מובא דווקא של השנה שלפניה לצורך חישוב מולד תשרי הבא אחריו
            year = heb.year-1 if first_last == "first" and month == 6 else heb.year
            # הניסיון הוא בגלל שאולי אין חודש 13 שזה חודש אדר-ב כי השנה המבוקשת אינה מעוברת
            try:
                date = dates.HebrewDate(year, month, 15).to_greg().to_pydate()
                all_dates.append(dt.datetime.combine(date, dt.time(12, 0)))
            except ValueError:
                pass
            
        
        #----------------------------------------------------
        
        # בכל מקרה, הקמת מונה ששומר כמה תאריכים יש במערך התאריכים של כל החודש/השנה המבוקשים
        dates_counter = len(all_dates)
            
        # הגדרת משתנה ששומר מידע על המיקום
        information = f'טבלת ראיות ירח {rishon_acharon} לשנת {heb.hebrew_year(True)} עבור: {city_for_print}, קו רוחב: {location_lat_for_print}, קו אורך: {location_lon_for_print}, גובה: {int(location.elevation.m)} מטר'

        # משתנה ששומר את כל זמני הירח ואותו בסוף נשמור לקובץ סי אס וי. בתחילתו מובא המידע ושורה רווח
        moons_zmanim = [[information],[""]]
        
        # הוספת הודעות הסבר
        moons_zmanim.append(["שימו לב! במקביל לתאריך הלועזי: בכל אירוע שמתרחש עד השעה 12 בלילה, התאריך העברי הרשום מתייחס ליום שהסתיים! ולא ליום שהתחיל"])
        moons_zmanim.append([f'שימו לב! סולם הזמן שבשימוש לשנה זו הוא {mean_transit_and_error_timescale_dict["year_timescale"]} ושיעור השגיאה השנתית שלו לשנה הנוכחית הוא {mean_transit_and_error_timescale_dict["seconds_error_timescale"]} שניות. השגיאה משפיעה רק על הזמן הרשום בשעון ולא על חישוב הנתונים'])
        if mean_transit_and_error_timescale_dict["year_timescale"] == "UT1":
            moons_zmanim.append(["סולם הזמן שבשימוש לשנה זו, לוקח בחשבון את ה- דלטא-טי"])
        moons_zmanim.append(["שימו לב! איזור הזמן עבור כל הזמנים הוא: שעון אזורי מתואם (לפי קו האורך הקרוב שמתחלק ל- 15) ומשנת 1918 והלאה הזמנים בקיץ הם לפי שעון קיץ"])
        moons_zmanim.append(['שימו לב: הזמן הנקוב בשדה "יום יוליאני" הוא שעת הראייה של הופמן בשעון גריניץ, אך תחילה חייבים לגרוע ממנו את ה- דלטא-טי'])
        moons_zmanim.append(['רוב נתוני ראיית הירח חושבו לפי שיטות שהובאו במאמר הבא: ר"ע הופמן, "תכנון מחושב של קריטריוני אפשרות ראיית הירח החדש", יודעי בינה ד (תשס"ז), עמודים 54-71'])
        if first_last == "first":
            moons_zmanim.append(["שימו לב! עבור כל חודש החישובים מתחילים מיום שקיעת הירח הראשונה שלאחר המולד האמיתי ומתקדמים קדימה עד ליום שבו מקדם הראייה של הופמן גדול מ- 1 שאז וודאי שהירח נראה בעין (כשאין עננים)"])
        elif first_last != "first":
            moons_zmanim.append(['הערה חשובה: המושג "שעת הראייה המיטבית" נועד בעיקרו !רק! עבור הירח הראשון ובכל זאת הובא כאן כדי שיתאפשר להתאמן בבוקר על ראיית הירח, בתנאי ראייה זהים לערב'])
            moons_zmanim.append(["שימו לב! עבור כל חודש החישובים מתחילים מיום זריחת הירח האחרונה שלפני המולד האמיתי וחוזרים אחורה עד ליום שבו מקדם הראייה של הופמן גדול מ- 1 שאז וודאי שהירח נראה בעין (כשאין עננים)"])        
        
        
        # הוספת שורה רווח
        moons_zmanim.append([])
        
        # מערך שמות הטורים עבור ירח ראשון
        first_moon_zmanim_names = ['תאריך עברי','תאריך גרגוריאני','תאריך יוליאני','יום יוליאני','דֶלטַא-טִי (שעות דקות ושניות)','מקדם קלות הראייה (הופמן)','האם הירח ייראה לפי הופמן',
             'סכום קיצי הראייה (רמבם)','האם הירח ייראה בעין לפי הרמבם','שקיעת שמש (0)','אזימוט שקיעת שמש','גובה הירח בשקיעת השמש',
             'אזימוט הירח בשקיעת השמש','שקיעת ירח (0)','אזימוט שקיעת ירח','שהייה בדקות בין שקיעות שמש-ירח',
             'שעת הראייה המיטבית לפי הופמן (0.6 של השהייה)','גובה הירח בשעת הופמן','אזימוט הירח בשעת הופמן','גובה השמש בשעת הופמן','אזימוט השמש בשעת הופמן','הפרשי גובה שמש-ירח בשעת הופמן',
             'הפרשי אזימוט שמש-ירח בשעת הופמן','עובי סהר הירח בדקות קשת בשעת הופמן','שעות שחלפו מהמולד האמיתי עד שעת הופמן','אחוזי התאורה של הירח בשעת הופמן',
             'מרחק הירח מכדור הארץ בקילומטרים בשעת הופמן','שעת הראייה של הרמבם - שמש בגובה מינוס 4','גובה הירח בשעת הרמבם',
             'אזימוט הירח בשעת הרמבם','אורך השמש בשעת הרמבם','אורך הירח בשעת הרמבם','רוחב הירח בשעת הרמבם','אלונגציה אמיתית שמש-לירח בשעת הרמבם',
             'אלונגציה על המִלקֶה שמש-לירח (אורך ראשון) בשעת הרמבם','קשת ראייה (שהייה במעלות משווניות) בשעת הרמבם'
                                     ]
  
        # מערך שמות הטורים עבור ירח אחרון
        last_moon_zmanim_names = ['תאריך עברי','תאריך גרגוריאני','תאריך יוליאני','יום יוליאני','דֶלטַא-טִי (שעות דקות ושניות)','מקדם קלות הראייה (הופמן)','האם הירח ייראה לפי הופמן',
             'סכום קיצי הראייה (רמבם)','האם הירח ייראה בעין לפי הרמבם','זריחת ירח (0)','אזימוט זריחת ירח','זריחת שמש (0)',
             'אזימוט זריחת שמש','גובה הירח בזריחת השמש','אזימוט הירח בזריחת השמש','שהייה בדקות בין זריחות ירח-שמש',
             'שעת הראייה המיטבית לפי הופמן (0.6 של השהייה)','גובה הירח בשעת הופמן','אזימוט הירח בשעת הופמן','גובה השמש בשעת הופמן','אזימוט השמש בשעת הופמן','הפרשי גובה ירח-שמש בשעת הופמן',
             'הפרשי אזימוט ירח-שמש בשעת הופמן','עובי סהר הירח בדקות קשת בשעת הופמן','שעות שיחלפו משעת הופמן עד המולד האמיתי','אחוזי התאורה של הירח בשעת הופמן',
             'מרחק הירח מכדור הארץ בקילומטרים בשעת הופמן','שעת הראייה של הרמבם - שמש בגובה מינוס 4','גובה הירח בשעת הרמבם',
             'אזימוט הירח בשעת הרמבם','אורך השמש בשעת הרמבם','אורך הירח בשעת הרמבם','רוחב הירח בשעת הרמבם','אלונגציה אמיתית שמש-לירח בשעת הרמבם',
             'אלונגציה על המִלקֶה שמש-לירח (אורך ראשון) בשעת הרמבם','קשת ראייה (שהייה במעלות משווניות) בשעת הרמבם'
                                     ]
  
        # הגדרת הודעה השגיאה שתופיע במקרה שהשמש לא יורדת לגובה המתאים במיקום זה
        eror = "שגיאה! (לתאריך ומיקום נוכחיים)"
        
        # ניסיון חישוב זמני היום והוספתם למערך הזמנים
        # בגלל שיש מקומות שאין זריחה ושקיעה, ויש מקומות שאין עלות השחר לכדומה לכן הכל בניסיון וגם כל זמן שתלוי בגובה השמש נמצא בניסיון
        try:
            
            # הצגת הודעה למשתמש בזמן ההמתנה לאיסוף הזמנים
            Waiting_moon_times = Toplevel(ws)
            Waiting_moon_times.geometry(f"{round(500*magnification_factor)}x{round(250*magnification_factor)}+{round(80*magnification_factor)}+{round(200*magnification_factor)}")
            # הגדרת צבע לכל החלון
            Waiting_moon_times.configure(bg=cu_color)
            # מיקום חלון ההמתנה מעל החלון הראשי
            Waiting_moon_times.wm_transient(ws)
            Waiting_moon_times.title('נא להמתין לחישוב הנתונים' if is_heb_locale else "Please wait for data calculations")
            msg = f"\nנא המתינו בסבלנות לסיום חישוב ראִיות הירח\nבסיום, תתבקשו לבחור היכן לשמור את הקובץ\n\nאין להשתמש בתוכנה במהלך חישוב הראִיות\nניתן לבטל את חישוב הזמנים על ידי סגירת חלון זה"
            Label(Waiting_moon_times, text=msg, font="david 16",justify="center").pack()
            Label(Waiting_moon_times, text="\nהחודש המחושב כעת", font="david 16",justify="center").pack()
            current_calculation = Label(Waiting_moon_times, text="עדיין לא מחושב", font="david 16 bold",justify="center")
            current_calculation.pack()
            # חובה!!! עדכון ידני של חלון ההודעה כדי לוודא שהוא מוצג לפני ביצוע המשך הקוד
            Waiting_moon_times.update()
            
            # עבור כל תאריך טו בחודש במערך התאריכים
            for date in all_dates:
                
                time = location_timezone.localize(date)
                
                # חישוב שמות החודש והשנה העבריים שעבורם יבוצעו החישובים
                # הערה: במקרה של ירח ראשון, החודש העברי שעבורו מחושבת הראייה הוא ראש החודש הבא לאחר טו לחודש ולכן מדלגים 30 יום קדימה כדי להיות בחודש הבא
                heb = dates.GregorianDate(1880, 10, 20).from_pydate(time+timedelta(days=30) if first_last == "first" else time).to_heb()
                heb_month_year_for_print = f'{heb.month_name(True)} {heb.hebrew_year(True)}'
                
                # הקטנת מונה התאריכים באחד בכל יום שעובר כדי שנדע כמה תאריכים נשארו לחישוב
                dates_counter -=1 
                
                # להכניס לחלון ההמתנה את החודש והשנה שעבורם מחשבים כעת את הראייה הראשונה
                current_calculation.config(text=f"{heb_month_year_for_print}   (נותרו {dates_counter} חודשים לחישוב)")
                # חובה!!! עדכון ידני של חלון ההודעה כדי לוודא שהוא מוצג לפני ביצוע המשך הקוד
                Waiting_moon_times.update()
                
                # מידע על מולד ירח הבא לאחר טו בחודש
                hitkabzut,nigud = hitkabzut_nigud_calculations(time,location,location_timezone,body="moon",PLUS_MINUS="PLUS",plus_minus_days=50)
                
                # הגדרת תאריך עברי מקביל לתאריך הלועזי של יום המולד
                hitkabzut_heb = dates.GregorianDate(1880, 10, 20).from_pydate(hitkabzut).to_heb()
                hitkabzut_heb_for_print = f'{heb_string_day(hitkabzut_heb.weekday())} - {hitkabzut_heb.hebrew_date_string(True)}'
                
                # הוספת שורה למערך עבור זמן מולד ירח אמיתי
                if first_last == "first":
                    moons_zmanim.append([f'מידע לקראת חודש: {heb_month_year_for_print}    פרטי מולד ירח אמיתי לחודש זה:    תאריך עברי: {hitkabzut_heb_for_print}    תאריך גרגוריאני: {hitkabzut:%d/%m/%Y}    בשעה: {hitkabzut:%H:%M:%S}    בשעת גריניץ: {hitkabzut.astimezone(timezone("utc")):%H:%M:%S}    יום יוליאני: {cu_to_skyfield_time(hitkabzut).tdb :02.6f}    להלן פרטי ראיית הירח הראשון'])
                else:
                    moons_zmanim.append([f'מידע לסיום חודש: {heb_month_year_for_print}    פרטי מולד ירח אמיתי לחודש הבא:    תאריך עברי: {hitkabzut_heb_for_print}    תאריך גרגוריאני: {hitkabzut:%d/%m/%Y}    בשעה: {hitkabzut:%H:%M:%S}    בשעת גריניץ: {hitkabzut.astimezone(timezone("utc")):%H:%M:%S}    יום יוליאני: {cu_to_skyfield_time(hitkabzut).tdb :02.6f}    להלן פרטי ראיית הירח האחרון'])
                
                # הוספת שורה למערך עבור כותרות הטורים
                moons_zmanim.append(first_moon_zmanim_names if first_last == "first" else last_moon_zmanim_names)
                
                # הוספת כל נתוני הירח ביום השקיעה הראשונה שלאחר המולד לתוך טקסט2 באמצעות פונקציית print_all_about_first_moon
                # יום החיפוש הראשון הוא יום ההתקבצות
                moon_search_day = hitkabzut
                sight_day_greg, stop_the_calculations = print_all_about_moon (moon_search_day, hitkabzut)
                
                # כל עוד שהפונקצייה של ההדפסות לא מחזירה פקודה לעצור את החישובים יש להמשיך אותם עבור היום הבא אם מדובר בירח ראשון / היום הקודם אם מדובר בירח אחרון
                while not stop_the_calculations: 
                    if first_last == "first":
                        moon_search_day = sight_day_greg + timedelta (days = 1, minutes = 1)
                    else:
                        moon_search_day = sight_day_greg - timedelta (days = 1, minutes = 1)
                    sight_day_greg, stop_the_calculations = print_all_about_moon (moon_search_day, hitkabzut)
                
                # שורה ריווח בין חודש לחודש
                moons_zmanim.append([])

            
               
            # סגירת חלון ההמתנה לאחר ביצוע כל החישובים של פונקצייה זו
            Waiting_moon_times.destroy()
            
            default_initialfile = f"{city_for_print} קובץ זמני ראיות ירח {rishon_acharon} לשנת {heb.hebrew_year(True)}"
            
            # שם הקובץ עבור לוח הזמנים
            filename = asksaveasfilename(defaultextension=".csv", initialfile = default_initialfile)

            # שמירת הקובץ תוך אפשרות ציון הקידוד המתאים
            # אפשרויות קידוד: cu_encod או "utf-8"
            # איף פיילניים נועד למנוע שגיאה במקרה שסגרו את החלון כי החליטו לא לשמור את הקובץ
            if filename:
                with open(filename, 'w', newline='', encoding=default_encoding) as file:
                    writer = csv.writer(file)
                    writer.writerows(moons_zmanim)
                    # אם רוצים לשמור במאוזן במקום במאונך
                    #from itertools import zip_longest
                    #writer.writerows(zip(*moons_zmanim))
                    #writer.writerows(zip_longest(*moons_zmanim))

            # לאחר השמירה, ריקון של המשתנה שמכיל את כל הנתונים כדי שלא יהיה עומס בזיכרון
            #zmanim = 1

        # במקרה שיש שגיאה בחישוב הזריחות והשקיעות
        except IndexError:
            tkMessageBox.showinfo("שגיאה", "עבור המיקום הנוכחי בתאריך הנוכחי, התוכנה אינה יכולה לחשב את זמני הירח ")
         
    
###################################################################################################################
###################################################################################################################
###################################################################################################################
####################################################################################################################
                        # תחילת איזור התוכנות הנלוות: א. יום הולדת. ב. מידע על שנה עברית. ג. ממיר תאריכים
####################################################################################################################
####################################################################################################################
####################################################################################################################
                                     # תחילת תוכנת יום הולדת ובר מצווה
####################################################################################################################


def yom_huledet():
    
    #################### הגדרות פונקציות עבור התוכנית הזו בלבד#############################

    '''
    # הגדרת פונקצייה שבודקת את כל המיקומים האינדקסיים של מספר כלשהו ברשימה כלשהיא, ומייצאת את התוצאה ברשימה
    # לפני שמריצים את הפונקציה צריך להגדיר כדלהלן
    # a_list = משתנה המכיל את הרשיבה שרוצים לעשות לה אינדקס
    # a_number = המספר (או משתנה המכיל את המספר) שאת האינדקס שלו רוצים למצוא ברשימה
    # אם המספר לא קיים ברשימה, הפונקצייה תייצר רשימה ריקה
    # פונקצייה זו כבר לא בשימוש
    def full_index(a_list, a_number):
        full_index = [i for i in range(len(a_list)) if a_list[i]==a_number]
        return full_index
    '''



    # מילון סימני השנה ל- 14 שנים עבריות שהן דוגמא לכל 14 סוגי השנים שיש בלוח העברי 
    # השנים מסודרות !!!בדווקא!!! בסדר הזה כי זה סדר יורד של שכיחותן באחוזים

    shanim_mikol_hasugim = {
        5789: [18.0451, 'הכז'],
        5788: [13.7153, 'זשג'],
        5783: [11.7967, 'בשה'],
        5795: [6.6571, 'השג'],
        5786: [6.2484, 'גכה'],
        5790: [5.8015, 'בחה'],
        5784: [5.8015, 'זחג'],
        5777: [5.71, 'בחג'],
        5782: [5.2632, 'גכז'],
        5779: [4.7248, 'בשז'],
        5787: [4.7248, 'זשה'], 
        5781: [4.3298, 'זחא'],
        5768: [3.8692, 'החא'],
        5785: [3.3125, 'השא'],
    }



    # אחת הפונקציות הכי מרכזיות בתוכנית
    # פונקצייה שבודקת באיזה יום בשבוע יחול יום ההולדת בכל אחד מ- 14 סוגי השנים שיש בלוח העברי. לכל סוג שנה יש דוגמה אחת
    # כל מה שנכון על ארבע עשרה השנים הללו נכון על כל השנים בלוח העברי הקבוע
    # הפונקצייה מחזירה מערך שנקרא איי שבו יש את היום בשבוע שבו יחול יום ההולדת בכל אחת מ 14 סוגי השנים שיש בלוח העברי
    def births_weekdays(birth_heb, sheela_adar_1):

        # כללים:
        # מי שנולד באחד משני האדרים שיש בשנה מעוברת: בשנה פשוטה יום ההולדת שלו הוא באדר רגיל, ובשנה מעוברת יום ההולדת הוא באותו אדר שנולד בו
        # מי שנולד באדר רגיל, בשנה מעוברת יום ההולדת שלו כברירת מחדל יהיה באדר שני, אך לפי בקשת המשתמש ניתן לחשב לפי אדר ראשון  

        # הגדרת יום חודש ושנה עבור שנת הלידה
        birth_heb_day = birth_heb.day
        birth_heb_month = birth_heb.month
        birth_heb_year = birth_heb.year
        
    
        # בדיקה האם שנת הלידה היא פשוטה או מעוברת
        _,_, birth_meuberet_year = chishuv_shana_bemachzor_19(birth_heb_year)
        
        # הכנת מערך ריק עבור התוצאות
        A = []
        
        # עבור כל שנה מדוגמאות השנים מכל הסוגים
        for dugma_year in shanim_mikol_hasugim.keys():
            
            # בדיקה האם השנה של הדוגמא היא פשוטה או מעוברת
            _,_, dugma_meuberet_year = chishuv_shana_bemachzor_19(dugma_year)
            
            
            # תיקונים הכרחיים של מספר החודש של יום ההולדת בשנת הדוגמא עבור חודשים מיוחדים
            
            #-------------------------------------------
            # מי שנולד בשנה מעוברת באדר-ב שזה חודש 13 בפיילוח, ושנת הדוגמא לבדיקת יום הולדת היא שנה פשוטה, יום ההולדת שלו יהיה בחודש אדר רגיל בשנה זו
            if birth_meuberet_year and birth_heb_month == 13 and not dugma_meuberet_year:
                dugma_heb_month = 12
            #(אם אדם נולד באדר ראשון לא צריך לשנות כלום כי בפיי-לוח זהו חודש 12 שזה גם מספרו של חודש אדר רגיל בפיי-לוח, ולכן הוא תמיד נשאר בחודש 12)
            #-------------------------------
            
            # אם שאלה אדר 1 מסומן זה שווה לערך המספרי: 12, וזה אומר שהמשתמש רוצה שמי שנולד באדר רגיל יום ההולדת שלו בשנה מעוברת יחושב באדר-א 
            #-----------------------------------------
            # מי שנולד באדר רגיל של שנה פשוטה שזה חודש 12 בפיילוח, ושנת הדוגמא לבדיקת יום הולדת היא שנה מעוברת 
            # כברירת מחדל (אם לא סימנו את שאלה אדר 1) יום ההולדת שלו יהיה בחודש אדר-ב של שנת הדוגמא, שבפיי-לוח זהו חודש 13
            # (אם כן סימנו את שאלה אדר 1 אז לא צריך לשנות כלום כי חודש הלידה שלו הוא 12 ויישאר 12 שזה אדר ראשון בשנה מעוברת)
            elif not birth_meuberet_year and birth_heb_month == 12 and dugma_meuberet_year and sheela_adar_1 != 12:
                dugma_heb_month = 13
                
            # בכל מקרה אחר אין שינוי בחודש, ולכן החודש בשנת הדוגמא שווה לחודש בשנת הלידה 
            else:
                dugma_heb_month = birth_heb_month
            #------------------------------------------------------    
            '''
            # אם רוצים להדפיס את הנתונים כדי לבדוק שאין טעות
            print("birth_heb_month",birth_heb_month,"dugma_heb_month",dugma_heb_month,"dugma_year",dugma_year,"dugma_meuberet_year",dugma_meuberet_year, "birth_meuberet_year",birth_meuberet_year )
            print("")
            '''
            # חישוב על כל סוג שנה באיזה יום בשבוע יחול התאריך של יום ההולדת
            # היום נשאר תמיד כמו יום הלידה. החודש והשנה מתחלפים לחודש ושנת הדוגמא
            # יום 30 בחודשים: מרחשוון, כסלו, אדר א' - אינו קיים בחלק מהשנים. לכן כל חודש נפתח בניסיון בדיקה, ואם הניסיון נכשל הבדיקה שווה ל- אפס
            try:
                heb = dates.HebrewDate(dugma_year, dugma_heb_month, birth_heb_day)
                heb_weekday = heb.weekday()
            except:
                heb_weekday = 0
            
            # הוספת הנתונים למערך איי
            # מיקום 0 במערך איי זה היום בשבוע, מיקום 1 זה הסיכויים באחוזים, מיקום 2 זה סוג השנה, מיקום 3 זה מספר שנת הדוגמא
            A.append([heb_weekday,shanim_mikol_hasugim.get(dugma_year)[0],shanim_mikol_hasugim.get(dugma_year)[1],dugma_year])

        return A

    #------------------------------------------------------------------

    # פונקצייה שנבנתה ע"י רובי הבוט שמסיקה וממיינת את הסיכויים באחוזים שיום ההולדת יחול בימות השבוע
    # מיקום 0 במערך איי זה היום בשבוע, מיקום 1 זה הסיכויים באחוזים, מיקום 2 זה סוג השנה, מיקום 3 זה מספר שנת הדוגמא
    def analyze_event(A): # arr_events
        
        # מציאת הימים בשבוע שלא קיימים במערך איי ולכן לעולם לא יחול בהם יום ההולדת
        days_of_week = set([event[0] for event in A])
        all_days_of_week = set(range(1, 8))
        never_occurred_days = all_days_of_week - days_of_week
        
        # הגדרת שלושה מילונים 1: סכום הסיכויים הכולל ליום מסויים. 2: סוג השנים ליום מסויים. 3: מספר שנות הדוגמא ליום מסויים
        total_odds_per_day = {}
        years_per_day = {}
        year_numbers_per_day = {}

        for event in A:
            day = event[0]
            odds = event[1]
            year_type = event[2]
            year_number = event[3]

            total_odds_per_day[day] = total_odds_per_day.get(day, 0) + odds
            years_per_day.setdefault(day, set()).add(year_type)
            year_numbers_per_day.setdefault(day, []).append(year_number)
        
        # מיון הימים שבהם יחול יום ההולדת מ-0 עד 7 לפי הסדר
        sorted_days = sorted(total_odds_per_day, key=lambda x: total_odds_per_day[x], reverse=True)

        # הגדרת מערך ריק עבור התוצאות
        results = []
        
        # הוספת הסיכויים באחוזים עבור כל יום לתוך מערך מסודר עם מידע בעברית
        for day in sorted_days:
        #for day in range(0, 8):
            # הגדרת משתנה של פרטים לעניין ההדפסה יום אפס זה אומר שאין את התאריך הזה בשנה הזו
            in_day = "ביום " if day != 0 else "יום ל' בחודש זה אינו קיים"
            if day == 7:
                in_day = "ב"
            # הוספת הנתונים למערך
            results.append(f"{in_day}{heb_string_day(day) if day != 0 else ''}: {round(total_odds_per_day.get(day, 0), 1)}%, "
                           f"(בשנים מסוג: {', '.join(years_per_day.get(day, []))})")
        # הוספה למערך התוצאות של הימים שבהם יום ההולדת לא יחול לעולם
        never_occurred_days_str = ', '.join(map(lambda x: heb_string_day(x), never_occurred_days))
        results.append(f"יום ההולדת לא יחול לעולם בימים: {never_occurred_days_str}")

        return results


    #---------------------------------------------------------------


    # הגדרת פונקצייה שמחזירה את התאריך העברי של יום בר/בת המצווה
    def baR_T_mitsva(birth_heb, sheela_adar_1, BMY = 13):    

        # בדיקה האם שנת בר המצווה היא פשוטה או מעוברת באמצעות פונקצייה
        _, _, BMY_meuberet_year  = chishuv_shana_bemachzor_19(birth_heb.year+BMY)
        
        # טיפול בחריגים של חודש אדר בגלל שנה פשוטה או מעוברת

        # מי שנולד בחודש אדר שני שזה חודש 13, אם שנת בר המצווה היא שנה פשוטה, בר המצווה יהיה באדר רגיל שזה חודש 12
        if birth_heb.month == 13 and not BMY_meuberet_year:
                mitsva_heb = dates.HebrewDate(birth_heb.year+BMY, 12, birth_heb.day)


        # טיפול בחריג של מי שנולד בתאריך ל' אדר א. בשנים פשוטות אין בחודש אדר יום ל', ולכן בר המצווה עובר ליום הבא (א' בניסן )
        # שימו לב שפיי-לוח ממספרים את החודשים מניסן, אבל ממספרים את השנים מתשרי
        elif birth_heb.month == 12 and birth_heb.day == 30:
            try:
                mitsva_heb = dates.HebrewDate(birth_heb.year+BMY, 12, birth_heb.day)
            except ValueError as ve:
                mitsva_heb = dates.HebrewDate(birth_heb.year+BMY, 1, 1)


        # מי שנולד בחודש אדר רגיל שזה חודש 12, אם שנת בר המצווה היא שנה מעוברת, כברירת מחדל בר במצווה יהיה באדר שני שזה חודש 13
        elif birth_heb.month == 12 and BMY_meuberet_year:
            if sheela_adar_1 == 0:
                mitsva_heb = dates.HebrewDate(birth_heb.year+BMY, 13, birth_heb.day)
            # אמנם, לפי תשובת המשתמש, ייתכן שבשנה מעוברת צריך לתת את יום ההולדת באדר ראשון שזה חודש 12
            elif sheela_adar_1 == 12:
                mitsva_heb = dates.HebrewDate(birth_heb.year+BMY, 12, birth_heb.day)

        # טיפול בחריג של מי שנולד בתאריך ל' מרחשוון או ל' כסלו. בשנים שאין בהן כזה תאריך, בר המצווה עובר ליום הבא
        elif birth_heb.month in [8,9] and birth_heb.day == 30:
            try:
                mitsva_heb = dates.HebrewDate(birth_heb.year+BMY, birth_heb.month, birth_heb.day)
            except ValueError as ve:
                mitsva_heb = dates.HebrewDate(birth_heb.year+BMY, birth_heb.month + 1, 1)

        # בכל שאר המקרים, היום והחודש נשארים זהים לתאריך הלידה ורק השנה היא פלוס 13
        # כולל במקרה של מי שנולד בחודש אדר ראשון שזה חודש 12, שאז בכל שנה בין פשוטה בין מעוברת בר המצווה תהיה בחודש 12
        else:
            mitsva_heb = dates.HebrewDate(birth_heb.year+BMY, birth_heb.month, birth_heb.day)

        return mitsva_heb


    #####################################################
    # מכאן והלאה פונקציות והגדרות שפועלים רק עם ממשק משתמש גרפי טקינטר
    #####################################################

    '''
    # פונקצייה עבוק לחצן "נקה נתונים" לניקוי תיבות קלט התאריך
    def clear_Entry():
        Entry_heb_year.set("")
        Entry_greg_year.set("")

    # פונקצייה לכפתור העתקת הנתונים של קובץ הטקסט
    # פונקצייה זו מופעלת על ידי כפתור "העתק תוצאות ללוח"
    def copy_txt_to_clipboard():
        C = txt.get(1.0, END)
        clipboard.copy(C)
        '''

    # פונקצייה לשמירה בשם של קובץ התוצאות
    def save_txt_to_path():
        # קריאה לפונקציית קבלת התאריך
        birth_heb, birth_greg = get_date()
        # הגדרת התאריך בלי גירשיים לצורך שם הקובץ
        birth_heb = str(birth_heb.hebrew_date_string(True)).replace("׳","").replace('״',"")
        # קבלת כל הנתונים שיש בתיבת הטקסט
        C = txt.get(1.0, END)
        
        file = asksaveasfilename(defaultextension=".txt", initialfile = f"חישוב יום הולדת ובר או בת מצווה למי שנולד בתאריך - {birth_heb}")
        
        # שמירת הקובץ תוך אפשרות ציון הקידוד המתאים
        # אפשרויות קידוד: cu_encod או "utf-8"
        # איף פייל נועד למנוע שגיאה במקרה שסגרו את החלון כי החליטו לא לשמור את הקובץ
        if file:
            with open(file, 'w', encoding="utf-8") as f:
                f.write(C)
        
       
    
    
    # פונקצייה להוספת הודעת שגיאה לתוך תיבת הטקסט במקרה שהתאריך אינו קיים
    def date_eror():
        # פתיחת תיבת הטקסט למצב כתיבה
        txt.configure(state="normal")
        # מחיקת מה שיש בתיבת הטקסט
        txt.delete(1.0, END)
        # הכנסת השגיאה לתיבת הטקסט
        txt.insert("end", f"\n!!!!!!!!!!  תאריך כזה אינו קיים: נסה שנית  !!!!!!!!!!")
        # הגדרת העיצוב של הטקסט בתיבת הטקסט שיהיה ממורכז
        txt.tag_configure("center", justify='center')
        txt.tag_add("center", 1.0, "end")
        # סגירת תיבת הטקסט לקריאה בלבד
        txt.configure(state="disabled")

    
    
    #---------------------------------------------


    # פונקציית מיין: סיכום סופי והדפסות עם הגדרות מיוחדות עבור ממשק משתמש גרפי של טקינטר
    # פונקצייה זו מופעלת באמצעות הכפתור "חשב נתונים"


    def get_date():

        # קלט תאריך יום ההולדת מהמשתמש

        # הגדרת תשובת המשתמש לשאלות
        before_24 = C1_before_24.get()
        sheela_adar_1 = C4_sheela_adar_1.get()

        #ניסיון לחשב נתונים מתוך שדה קלט עברי
        if C_heb_or_greg.get() == 0:

            try:
                # המרת התאריך שהוזן, למספרים וחלוקה למשתנים נפרדים עבור יום חודש אלפים ושנה
                heb_day = gy.to_number(Entry_heb_day.get())

                heb_month = heb_month_name_to_number(Entry_heb_month.get())

                # הפרדת האלפים באמצעות ספליט על הגרש של האלפים
                heb_year = Entry_heb_year.get().replace(' ','').replace("׳","'")

                if "'" in heb_year:
                    split_heb_year = heb_year.split("'")
                    heb_year = (gy.to_number(split_heb_year[0]) * 1000) + gy.to_number(split_heb_year[1])
                else:
                    if len(heb_year) > 0:
                        heb_year = gy.to_number(heb_year)

                # הגדרת תאריך לידה עברי בפורמט פיי-לוח   
                birth_heb = dates.HebrewDate(heb_year, heb_month, heb_day)

                # הגדרת תאריך לידה לועזי שמקביל לתאריך העברי
                birth_greg = birth_heb.to_greg()

                # תיקון תאריך הלידה הלועזי במקרה שהלידה הייתה לאחר השקיעה ולפני השעה 24:00
                if before_24 == 1:
                    birth_greg = birth_greg - 1

                # טיפול במקרה שאדם מזין אדר-א או אדר-ב אבל השנה אינה מעוברת או שהוא מזין אדר רגיל בשנה מעוברת
                # תחילה חישוב האם השנה היא מעוברת
                _,_, meuberet_year = chishuv_shana_bemachzor_19(heb_year)
                if Entry_heb_month.get() in ["אדר-א", "אדר-ב"] and not meuberet_year or Entry_heb_month.get() == "אדר" and meuberet_year:
                    # הכנסת הודעת שגיאה לתיבת הטקסט באמצעות פונקצייה
                    date_eror()
                    birth_heb = 0 
                    birth_greg = 0

            except ValueError:
                # הכנסת הודעת שגיאה לתיבת הטקסט באמצעות פונקצייה
                date_eror()
                birth_heb = 0 
                birth_greg = 0


        # ניסיון לחשב נתונים מתוך שדה קלט לועזי
        if C_heb_or_greg.get() == 1:
            # הגדרת משתנה ששומר את הטקסט שהמשתמש הזין לתיבת הקלט, והפרדתו למערך באמצעות ספילט
            try:

                # הגדרת תאריך לידה לועזי בפורמט פיי-לוח   
                birth_greg = dates.GregorianDate(int(Entry_greg_year.get()), int(Entry_greg_month.get()), int(Entry_greg_day.get()))

                # הגדרת תאריך לידה עברי שמקביל לתאריך הלועזי
                birth_heb = birth_greg.to_heb()

                # תיקון תאריך הלידה הלועזי במקרה שהלידה הייתה לאחר השקיעה ולפני השעה 24
                if before_24 == 1:
                    birth_heb = birth_heb + 1 

            except ValueError:
                # הכנסת הודעת שגיאה לתיבת הטקסט באמצעות פונקצייה
                date_eror()
                birth_greg = 0
                birth_heb = 0 

        return birth_heb, birth_greg


    def main_result():
        # הגדרת תשובת המשתמש לשאלות
        before_24 = C1_before_24.get()
        sheela_adar_1 = C4_sheela_adar_1.get()
        sheela_baR_T_mitsva = C2_baR_T_mitsva.get()
        

        # קריאה לפונקציית קבלת התאריך
        birth_heb, birth_greg = get_date()

        # כל הפעולות הבאות יתבצעו רק אם יש תאריך עברי ותאריך לועזי נכונים
        if birth_heb != 0 and birth_greg != 0:

            #----------------------------------------------------------------

            # בדיקת יום ההולדת על כל אחד מסוגי השנים באמצעות פונקציה שהוגדרה לעיל

            A = births_weekdays(birth_heb, sheela_adar_1)

            # פונקציית המיון על תוצאות מערך איי, שמחזירה מערך מסודר עם מידע על הסיכויים באחוזים שיום ההולדת יחול בכל יום בשבוע
            result = analyze_event(A)
    
            #--------------------------------------------------------------------------

            
            # קריאה לפונקציית חישוב בר/בת מצווה ושמירת התוצאה במשתנה אך תחילה הגדרה מה מספר השנים לדילוג לפי בר (13) או בת (12) מצווה
            years = 13 if sheela_baR_T_mitsva == "בר" else 12
            
            baR_T_mitsva_heb = baR_T_mitsva(birth_heb, sheela_adar_1, BMY=years)
            baR_T_mitsva_greg = baR_T_mitsva_heb.to_greg().to_pydate()
            
            

            #-----------------------------------------------------------------------
            ############  כל ההדפסות ###############

            # הדפסות על תאריך הלידה

            # פתיחת תיבת הטקסט למצב כתיבה
            txt.configure(state="normal")

            # מחיקת מה שיש בתיבת הטקסט
            txt.delete(1.0, END)

            # ההדפסות עצמן
            birth_greg_pydate = birth_greg.to_pydate()
            
            if before_24 == 1: 
                txt.insert("end", f'\n תאריך הלידה העברי הוא: יום {heb_string_day(birth_heb.weekday())}, {birth_heb.hebrew_date_string(True)}')
                txt.insert("end", f'\n תאריך הלידה הלועזי הוא: יום {heb_string_day(birth_greg.weekday())}, {birth_greg_pydate:%d/%m/%Y} (לאחר השקיעה ולפני השעה 12 בלילה)')
            else:
                txt.insert("end", f'\n תאריך הלידה הוא: יום {heb_string_day(birth_heb.weekday())}, {birth_heb.hebrew_date_string(True)}, {birth_greg_pydate:%d/%m/%Y}')

            txt.insert("end", "\n")
            txt.insert("end", f'\n בשבת *שאחרי* הלידה קוראים בבתי הכנסת בארץ ישראל פרשת: {parshios.getparsha_string(birth_heb, israel=True, hebrew=True)}')
            txt.insert("end", f'\n בשבת *שלפני* הלידה קוראים בבתי הכנסת בארץ ישראל פרשת: {parshios.getparsha_string(birth_heb - 7, israel=True, hebrew=True)}')
            txt.insert("end", "\n")
            
            txt.insert("end", f"\nהסיכויים באחוזים שיום ההולדת יחול")
            
            for res in result:
                txt.insert("end", f"\n{res}")
            
            # הדפסת הפנייה ביבליוגרפית
            txt.insert("end", f"\n\n חישוב הסיכויים באחוזים נעשה לפי טבלת שכיחות סימני השנה בספר\n ע' מרצבך ו-ע' רביב, הלוח העברי הקבוע, הוצאת כרמל, ירושלים תשפא")

            # הדפסות עבור בר/בת מצווה
            txt.insert("end", "\n") 
            txt.insert("end", "\n") 
            txt.insert("end", "——————————————————————————————") 
            txt.insert("end", f'\n\n להלן מידע עבור !{sheela_baR_T_mitsva}! המצווה\n') 
            if baR_T_mitsva_heb.day != birth_heb.day:
                txt.insert("end", f'\n שימו לב: בשנה זו יום הלידה העברי אינו קיים, ולפיכך בר/בת המצווה חל ביום הבא אחריו')
            txt.insert("end", f'\n בר/בת המצווה חל ביום {heb_string_day(baR_T_mitsva_heb.weekday())}, {baR_T_mitsva_heb.hebrew_date_string(True)}, {baR_T_mitsva_greg:%d/%m/%Y}')
            txt.insert("end", f'\n שימו לב! בר/בת המצווה מתחיל בסוף היום העברי *הקודם* לתאריך זה')
            txt.insert("end", "\n")
            txt.insert("end", f'\n בשבת *שאחרי* בר/בת המצווה קוראים בבתי הכנסת בארץ ישראל פרשת: {parshios.getparsha_string(baR_T_mitsva_heb, israel=True, hebrew=True)}')
            txt.insert("end", f'\n בשבת *שלפני* בר/בת המצווה קוראים בבתי הכנסת בארץ ישראל פרשת: {parshios.getparsha_string(baR_T_mitsva_heb - 7, israel=True, hebrew=True)}')

            # הגדרת העיצוב של הטקסט בתיבת הטקסט שיהיה ממורכז
            txt.tag_configure("center", justify='center')
            txt.tag_add("center", 1.0, "end")

            # סגירת תיבת הטקסט לקריאה בלבד
            txt.configure(state="disabled")

    # פונקצייה להגדרת התאריך הנוכחי בכניסה לתוכנה    
    def set_date_time_now():

        now = datetime.now()

        heb_date = dates.GregorianDate(1880, 10, 20).from_pydate(now).to_heb()

        Entry_greg_year.set(f'{now.year :02.0f}')
        Entry_greg_month.set(f'{now.month :02.0f}')
        Entry_greg_day.set(f'{now.day :02.0f}')
        Entry_heb_year.set(heb_date.hebrew_year(True))
        Entry_heb_month.set(heb_date.month_name(True))
        Entry_heb_day.set(heb_date.hebrew_day(False))
        # חישוב הנתונים על התאריך הנוכחי
        main_result()


    # פונקצייה להגדיר האם יוצג קלט של תאריך עברי או קלט של תאריך לועזי
    def set_heb_or_greg_entry():
        if C_heb_or_greg.get() == 0:
            greg_date.grid_forget()
            heb_date.grid(column=1, row=2)
            main_result()
        elif C_heb_or_greg.get() == 1:
            heb_date.grid_forget()
            greg_date.grid(column=1, row=2)
            main_result()
    #-----------------------------------------

    if __name__ == '__main__':

        # מכאן והלאה עיצוב גרפי של ממשק המשתמש

        # התוכנית עצמה בתוך טקינטר וכל מה שקשור לטקינטר
        # הגדרת משתנה ששומר חלון טקינטר, והגדרת כותרת החלון ומינימום גודל החלון
        wnd=Toplevel(ws) # Tk()
        wnd.minsize(660,617)
        wnd.geometry(f"{round(660*magnification_factor)}x{round(685*magnification_factor)}+{round(130*magnification_factor)}+{round(1*magnification_factor)}")
        wnd.title(f'חישובי יום הולדת עברי ובר/בת מצווה - מאת הרב ד"ר שמחה גרשון בורר | גרסה:  {dt.date(2023,7,28):%d/%m/%Y}')
        # הגדרת צבע לכל החלון
        wnd.configure(bg=cu_color)
        
        
        # פונקצייה לסגירת החלון לאחר רישום במשתנה שהחלון נסגר 
        def wnd_close():
            global subprocess_patuach
            subprocess_patuach -= 1
            wnd.destroy()
        
        # בסגירת החלון ייתבצעו הפעולות שבפונקצייה
        wnd.protocol("WM_DELETE_WINDOW", wnd_close)


        state1 = 'readonly'
        input_years_range = range(1550,2650)

        # הגדרת משתנה ששומר הגדרות כלליות לפונט שיהיה בשימוש
        font_buttons = tkinter.font.Font(wnd, family='narkisim', size=12, weight='bold')
        font_ = tkinter.font.Font(wnd, family='david', size=12)


        # כותרות לתוכנה
        Label(wnd, text="מידע באילו ימים בשבוע יכול לחול יום ההולדת העברי וכן פרטים אודות בר/בת המצווה", font= font_, wraplength=1000).pack()
        Label(wnd, text="שימו לב: תוכנן עבור יום הולדת, אך יכול לשמש גם עבור כל תאריך עברי אחר", font="david 12 bold" , wraplength=1000).pack()


        # תווית כותרת שאומרת למשתמש מה לעשות, והצבה שלה לתוך החלון
        Label(wnd, text="\n בחרו תאריך לידה עברי", font = "david 16 bold").pack()

        C_heb_or_greg = IntVar(wnd)

        C0 = Checkbutton(wnd, text="או סמנו אם ברצונכם לחשב את התאריך העברי לפי תאריך הלידה הלועזי",font="david 12 bold", variable=C_heb_or_greg,command=set_heb_or_greg_entry).pack()

        Label(wnd, text="").pack()

        #---------------------------------------------

        date = cu_PanedWindow(wnd)

            # אזור נפרד להזנת תאריך לועזי ושעה
        greg_date = cu_PanedWindow(date)

        # תאריך לועזי-----------------
        # כותרת
        #Label(greg_date, text="תאריך לועזי", font="david 18 bold").grid(column=0, row=0, columnspan=3)

        Entry_greg_year = StringVar(wnd)
        greg_year_cb = ttk.Combobox(greg_date, textvariable=Entry_greg_year, width=5, state=state1,values=[*range(1590,2239)],font="narkisim 16",justify='center',)
        greg_year_cb.grid(column=2, row=1)

        Label(greg_date, text="שנה").grid(column=2, row=2)

        Entry_greg_month = StringVar(wnd)
        Spinbox(
            greg_date,
            textvariable=Entry_greg_month,
            from_=1, 
            to=12,
            wrap=True,
            state = 'readonly',
            width=2,
            format_="%02.0f",
            command=main_result,
            readonlybackground = "white",
            font="narkisim 17",
            justify='center'
        ).grid(column=1, row=1)
        Label(greg_date, text="חודש").grid(column=1, row=2)

        Entry_greg_day = StringVar(wnd)
        Spinbox(
            greg_date,
            textvariable=Entry_greg_day,
            state = 'readonly',
            from_=1, 
            to=31,
            wrap=True,
            width=2,
            format_="%02.0f",
            readonlybackground = "white",
            command=main_result,
            font="narkisim 17",
            justify='center'
        ).grid(column=0, row=1)
        Label(greg_date, text="יום").grid(column=0, row=2)

        greg_date.grid(column=1, row=2)


    #else:
        # תאריך עברי----------------------------------------------

        # תאריך עברי----------------------------------------------

        # אזור נפרד להזנת תאריך עברי ושעה
        heb_date = cu_PanedWindow(date)


        # כותרת
        #Label(heb_date, text="תאריך עברי", font="david 18 bold").grid(column=8, row=0, columnspan=3)


        # יצירת רצף של שנים עבריות במערך עבור בחירת שנים עבריות

        a = range(5350,6000)
        heb_years = []
        for i in range(len(a)):
            heb_years.append(gematria._num_to_str(a[i], thousands=True, withgershayim=True))

        # בחירה בין רשימת שנים עבריות
        Entry_heb_year = StringVar(wnd)
        greg_year_cb = ttk.Combobox(heb_date, textvariable=Entry_heb_year, width=9, state=state1,values=[*heb_years],font="narkisim 16",justify='center',)
        greg_year_cb.grid(column=8, row=1)
        Label(heb_date, text="שנה").grid(column=8, row=2)

        '''
        Entry_heb_thousands = StringVar(wnd)
        Spinbox(
            heb_date,
            textvariable=Entry_heb_thousands,
            value=["0", "א", "ב", "ג", "ד", "ה", "ו", "ז", "ח", "ט", "י"],
            wrap=True,
            state = 'readonly',
            width=2,
            readonlybackground = "white",
            command=main_result,
            font="narkisim 17",
            justify='center'
        ).grid(column=9, row=1)
        Label(heb_date, text="אלפים").grid(column=9, row=2)
        Entry_heb_thousands.set("ה")
        '''


        Entry_heb_month = StringVar(wnd)
        Spinbox(
            heb_date,
            textvariable=Entry_heb_month,
            value=CUֹ_HEB_MONTH_NAMES,
            wrap=True,
            state = 'readonly',
            width=8,
            readonlybackground = "white",
            command=main_result,
            font="narkisim 17",
            justify='center'
        ).grid(column=10, row=1)
        Label(heb_date, text="חודש").grid(column=10, row=2)


        # הכנת מערך עם שלושים ימים עבריים עבור ימי החודש
        b = range(1,31)
        month_days = []
        for i in range(len(b)):
            month_days.append(gematria._num_to_str(b[i], thousands=False, withgershayim=False))

        Entry_heb_day = StringVar(wnd)
        Spinbox(
            heb_date,
            textvariable=Entry_heb_day,
            #value=['א','ב','ג','ד','ה','ו','ז','ח','ט','י','יא','יב','יג','יד','טו','טז','יז','יח','יט','כ','כא','כב','כג','כד','כה','כו','כז','כח','כט','ל'],
            value= [*month_days],
            wrap=True,
            state = 'readonly',
            width=3,
            readonlybackground = "white",
            command=main_result,
            font="narkisim 17", 
            justify='center'
        ).grid(column=11, row=1)
        Label(heb_date, text="יום").grid(column=11, row=2)

        heb_date.grid(column=1, row=2)

        date.pack()



        #----------------------------------------

        # כפתור לסימון לאחר השקיעה
        C1_before_24 = IntVar(wnd)
        Checkbutton(wnd, text = "לחישוב נכון, חובה לסמן במקרה שהלידה הייתה בין תחילת הלילה לשעה 24:00", variable = C1_before_24, onvalue = 1, offvalue = 0, font = "david 15 bold", command=main_result).pack()

        # כפתור לסימון חישוב לפי אדר ראשון
        C4_sheela_adar_1 = IntVar(wnd)
        Checkbutton(wnd, text = "ברצוני שיום ההולדת ובר/בת המצווה של מי שנולד באדר רגיל/שני יחושבו בשנה מעוברת באדר ראשון", variable = C4_sheela_adar_1, onvalue = 12, offvalue = 0, font = "david 12 bold", command=main_result).pack()

        #-----------------------------

       

        # אזור נפרד לכפתורי בר/בת מצווה
        baR_baT = cu_PanedWindow(wnd)
        C2_baR_T_mitsva = StringVar(wnd)
        R1 = Radiobutton(baR_baT, text="בר מצווה (שנה 13)", font="david 12 bold", variable=C2_baR_T_mitsva, value="בר", command=main_result).grid(column=2, row=1)
        Label(baR_baT, text="                                                                  ").grid(column=1, row=1)
        R2 = Radiobutton(baR_baT, text="בת מצווה (שנה 12)", font="david 12 bold", variable=C2_baR_T_mitsva, value="בת", command=main_result).grid(column=0, row=1) 
        C2_baR_T_mitsva.set("בר")
        # אריזת האיזור הנפרד לתוך החלון הראשי
        baR_baT.pack()

        #------------------------------

        # כפתור שמירת הנתונים
        Button(wnd, text="לחצו לשמירת הנתונים לקובץ",command=save_txt_to_path).pack()

        
        #------------------------------------------------------

        # אזור נפרד לטקסט התוצאות
        output_text = cu_PanedWindow(wnd)


        # ברי גלילה לאיזור התוצאות
        # גלילה למעלה ולמטה
        Y_scrollbar = Scrollbar(output_text, orient = 'vertical')
        Y_scrollbar.pack( side = RIGHT, fill = Y )

        # גלילה לימין ושמאל כרגע לא צריכה להיות בשימוש כי תיבת הטקסט עצמה לא מאפשרת חריגה של הטקסט לימין ושמאל
        X_scrollbar = Scrollbar(output_text, orient = 'horizontal')
        X_scrollbar.pack( side = BOTTOM, fill = X )

        # חלון טקסט להצגת התוצאות
        txt = Text(output_text, height=50, width=80, yscrollcommand = Y_scrollbar.set, xscrollcommand = X_scrollbar.set, font = "david 13")
        #txt.insert("end", f"\n\n חישוב הסיכויים באחוזים נעשה לפי טבלת שכיחות סימני השנה בספר \nע' מרצבך ו-ע' רביב, הלוח העברי הקבוע, הוצאת כרמל, ירושלים תשפא")

        # הגדרת העיצוב של הטקסט בתיבת הטקסט: שיהיה ממורכז
        txt.tag_configure("center", justify='center')
        txt.tag_add("center", 1.0, "end")   

        # סגירה של תיבת הטקסט לקריאה בלבד ואריזה לתוך החלון
        txt.configure(state="disabled")

        # חסימת כל תגובה לעכבר וכו של תיבת הטקסט
        #txt.bindtags(("txt", "wnd", "all"))

        # לחילופין, חסימת שתי תגובות ספציפיות לעכבר עבור תיבת הטקסט
        txt.bind("<Button>", lambda event: "break")
        txt.bind("<Motion>", lambda event: "break")

        # אריזת תיבת הטקסט
        txt.pack( side = LEFT, fill = BOTH )

        # הגדרת ברי הגלילה שפעולתם תתבצע על תיבת הטקסט
        Y_scrollbar.config( command = txt.yview )
        X_scrollbar.config( command = txt.xview )

        # אריזת האיזור הנפרד של טקסט התוצאות
        output_text.pack()

        #------------------------------------------------------
        # כל שינוי של קומבובוקס יקרא לפונקציית חישוב הנתונים
        wnd.bind('<<ComboboxSelected>>', lambda event: main_result())
        
        # הגדרת השנה הנוכחית מייד בפתיחת התוכנה
        wnd.after(1,set_date_time_now)

        # הגדרת לולאה אינסופית שמפעילה את חלון טקטינר שיצרנו
        #wnd.mainloop()

###################################################################################################################
                                # תחילת תוכנת מידע על שנה עברית
###################################################################################################################


def heb_year_information():

    # הגדרות של פונקציות משתמש

    ##############################

    # הגדרת משתנים כלליים לצורך הפונקציות והחישובים
    itaron_chodesh_bechalakim = 39673
    molad_baharad_bechalakim = 57444
    shavua_bechalakim = 181440


    ######################

    #---------------------------------------------------

    
    # הגדרת פונקציית נוסחת לוינגר שמראה כמה חודשים עברו ממולד בהר"ד עד מולד תשרי של שנה מסויימת
    def nuschat_levinger(heb_year):
        sum_heb_months_be_over_from_molad_baharad = int((235 * (heb_year-1) +1) / 19)
        return sum_heb_months_be_over_from_molad_baharad

    # מציאת מולד תשרי בחלקים על פי נוסחת לוינגר
    # התרגיל הוא הכפלת תוצאת נוסחת לוינגר (מספר החודשים שעברו מבהר"ד) בייתרון חודש בחלקים, הוספת התוצאה לבהר"ד בחלקים, והחלת מודולו שבוע בחלקים על התוצאה הכללית
    def chishuv_molad_tishrei_bechalakim(sum_heb_months_be_over_from_molad_baharad):
        molad_tishrei_bechalakim = (sum_heb_months_be_over_from_molad_baharad * itaron_chodesh_bechalakim + molad_baharad_bechalakim) % shavua_bechalakim
        return molad_tishrei_bechalakim


    # הקדמה והסבר לפונקצייה הבאה העוסקת בדחיות ראש השנה

    # מולד תשרי ביום 1 יכול להיות רק דחיית אד"ו שדוחה ביום אחד.
    # מולד תשרי ביום 2 : בכל שנה יכול להיות דחיית זקן שדוחה ביום אחד; ובשנה פשוטה שהיא מוצאי מעוברת יכול להיות דחיית בט"ו תקפ"ט שדוחה ביום אחד.
    # מולד תשרי ביום 3: בכל שנה יכול להיות דחיית זקן שדוחה ביומיים (בגלל אד"ו); ובכל שנה פשוטה יכול להיות גם דחיית גטר"ד שדוחה ביומיים (בגלל אד"ו).
    # מולד תשרי ביום 4: יכול להיות רק דחיית אד"ו שדוחה ביום אחד.
    # מולד תשרי ביום 5: בכל שנה יכול להיות דחיית זקן שדוחה ביומיים (בגלל אד"ו).
    # מולד תשרי ביום 6: יכול להיות רק דחיית אד"ו שדוחה ביום אחד.
    # מולד תשרי ביום 7: בכל שנה יכול להיות דחיית זקן שדוחה ביומיים (בגלל אד"ו).
    # לסיכום: לפי דחיות של ימים, יש שני סוגים: דחייה של יום אחד, או דחייה של יומיים.


    # הגדרת פונקציית דחיות ראש השנה. הפונקציה פועלת על שני משתנים: 
    # הראשון הוא רשימה המכילה את מולד תשרי בשלושה איברים. בדרך כלל רשימת מולד תשרי מתקבלת מהפונקציה המרה מ-חלקים
    # השני הוא: משתנה שמכיל את מספר השנה במחזור 19 שנים נתון זה בדרך כלל מתקבל מתוך הפונקצייה סיכום
    def dechiot(arr_molad_tishrei,shana_bemachzor_19):
        yom = arr_molad_tishrei[0]
        shaa = arr_molad_tishrei[1]
        chelek = arr_molad_tishrei[2]
        # מקרים שבהם ראש השנה של השנה המבוקשת נדחה ביום אחד: 1. אד"ו (תמיד), 2. זקן בשני, 3. ב-טו-תקפט בפשוטה שהיא מוצאי מעוברת 
        if (yom in (1,4,6)) or (yom == 2 and shaa >= 18) or (shana_bemachzor_19 in (4,7,9,12,15,18,1) and yom == 2 and shaa >= 15 and chelek >= 589):
            rosh_hashana_weekday = (yom + 1) % 7 
            dechia = 1
        # מקרים שבהם ראש השנה של השנה המבוקשת נדחה ביומיים: 1. זקן בשלישי חמישי או שבת, 2. ג-ט-רד בכל שנה פשוטה 
        elif (yom in (3,5,7) and shaa >= 18) or (shana_bemachzor_19 not in (3,6,8,11,14,17,19) and yom == 3 and shaa >= 9 and chelek >= 204):
            rosh_hashana_weekday = (yom + 2) % 7
            dechia = 2
        # בכל המקרים האחרים ראש השנה של השנה המבוקשת לא נדחה, אלא הוא ביום מולד תשרי של השנה המבוקשת
        else:
            rosh_hashana_weekday = yom
            dechia = 0
        # תיקון יום 0 שווה ל 7 {לא יודע למה אבל התיקון לא פועל על שנת 5303. עדכון: כנראה כבר תוקן ופועל גם על 5303} 
        if rosh_hashana_weekday == 0:
            rosh_hashana_weekday = rosh_hashana_weekday + 7
        return rosh_hashana_weekday, dechia



    # פונקציה המפעילה מספר פונקציות ונותנת רשימה המכילה סיכום של 7 נתונים על שנה מסויימת
    # הנתונים שרשימת הסיכום כוללת הם: מספר המחזור ממחזור 19 שנים ומספר השנה במחזור, מספר החודשים שחלפו מבהר"ד, מולד תשרי בחלקים, מולד תשרי לפי יום שעה וחלק, יום בשבוע עבור ראש השנה, האם ראש השנה נדחה ובכמה ימים
    def sikum(heb_year):
        machzor_19, shana_bemachzor_19, meuberet_year = chishuv_shana_bemachzor_19(heb_year)
        sum_heb_months_be_over_from_molad_baharad = nuschat_levinger(heb_year)
        molad_tishrei_bechalakim = chishuv_molad_tishrei_bechalakim(sum_heb_months_be_over_from_molad_baharad)
        molad_tishrei = convert_from_chalakim(molad_tishrei_bechalakim)
        rosh_hashana_weekday, dechia = dechiot(molad_tishrei,shana_bemachzor_19)
        return [machzor_19,shana_bemachzor_19, sum_heb_months_be_over_from_molad_baharad, molad_tishrei_bechalakim, molad_tishrei, rosh_hashana_weekday, dechia]   


    # הגדרת פונקצייה שמחשבת את 13 המולדות הממוצעים בחלקים, שבאים לאחר מולד תשרי של השנה המבוקשת, מתוך מולד תשרי של השנה המבוקשת
    # הפונקציה מחזירה רשימה של 13 או 14 מולדות ממוצעים בחלקים, הכוללת את מולד תשרי בחלקים של השנה המבוקשת וכן את המולדות בחלקים של 13 או 14 החודשים הבאים
    # אם השנה המבוקשת היא פשוטה, הפונקציה מחזירה רשימה של 13 איברים כי זה כולל מולד תשרי הזה וגם מולד תשרי הבא
    # אם השנה המבוקשת היא מעוברת הפונקציה מחזירה רשימה של 14 איברים כנ"ל.
    def moladot_chodashim_bechalakim(molad_tishrei_bechalakim, shana_bemachzor_19):
        a = molad_tishrei_bechalakim
        b = (a + itaron_chodesh_bechalakim) % shavua_bechalakim
        c = (b + itaron_chodesh_bechalakim) % shavua_bechalakim
        d = (c + itaron_chodesh_bechalakim) % shavua_bechalakim
        e = (d + itaron_chodesh_bechalakim) % shavua_bechalakim
        f = (e + itaron_chodesh_bechalakim) % shavua_bechalakim
        g = (f + itaron_chodesh_bechalakim) % shavua_bechalakim
        h = (g + itaron_chodesh_bechalakim) % shavua_bechalakim
        i = (h + itaron_chodesh_bechalakim) % shavua_bechalakim
        j = (i + itaron_chodesh_bechalakim) % shavua_bechalakim
        k = (j + itaron_chodesh_bechalakim) % shavua_bechalakim
        l = (k + itaron_chodesh_bechalakim) % shavua_bechalakim
        m = (l + itaron_chodesh_bechalakim) % shavua_bechalakim
        n = (m + itaron_chodesh_bechalakim) % shavua_bechalakim
        if shana_bemachzor_19 in (3,6,8,11,14,17,19):
            return [a,b,c,d,e,f,g,h,i,j,k,l,m,n]
        else:
            return [a,b,c,d,e,f,g,h,i,j,k,l,m]


    # הגדרת פונקצייה שלוקחת עותק של הרשימה המתקבלת מפונקציית חישוב מולדות חודשים בחלקים 
    # וממירה בו כל מולד ל-יום שעה וחלק כך שמתקבלת רשימת של המולדות לפי יום שעה וחלק
    def moladot_chodashim(arr_moladot_chodashim_bechalakim):
        a = arr_moladot_chodashim_bechalakim.copy()
        for i in range(len(a)):
            a[i] = convert_from_chalakim(a[i])
        arr_moladot_chodashim = a
        return arr_moladot_chodashim


    # פונקצייה לחישוב סימן השנה של שנה עברית, והפרש הימים בין שני ראשי השנה
    def siman_hashana(rosh_hashana_1_weekday, rosh_hashana_2_weekday, shana_1_bemachzor_19):

        siman_hashana_A = heb_letter_day(rosh_hashana_1_weekday)


        # חישוב האות האמצעית של סימן השנה כלומר האם השנה המבוקשת היא חסרה כסדרה או שלמה, (ולפי זה ניתן לדעת כמה ימים יש בשנה המבוקשת)
        # חסרה (מרחשוון וכסליו חסרים), כסדרה (מרחשוון חסר וכסליו מלא), או שלמה (מרחשוון וכסליו מלאים)

        # שלב ראשון, חישוב פער הימים בין בין ראש השנה של השנה שלאחריה לבין ראש השנה של השנה המבוקשת כהקדמה לחישוב גד"ה הו"ז
        efresh = (rosh_hashana_2_weekday - rosh_hashana_1_weekday) % 7
        if efresh == 0:
            efresh = efresh + 7

        # שלב שני, חישוב גד"ה הו"ז והסקה ממנו של האות האמצעית של סימן השנה. ח=8, כ=20, ש=300 
        if efresh == 3:
            siman_hashana_B = "ח"
        elif efresh == 4:
            siman_hashana_B = "כ"
        #--------------------------------------------    
        elif efresh == 5 and shana_1_bemachzor_19 not in (3,6,8,11,14,17,19):
            siman_hashana_B = "ש"
        elif efresh == 5 and shana_1_bemachzor_19 in (3,6,8,11,14,17,19):
            siman_hashana_B = "ח"
        #--------------------------------------------
        elif efresh == 6:
            siman_hashana_B = "כ"
        elif efresh == 7:
            siman_hashana_B = "ש"


        # חישוב האות האחרונה של סימן השנה, כלומר: חישוב באיזה יום בשבוע יחול פסח של השנה המבוקשת
        pesach_1_weekday = (rosh_hashana_2_weekday - 2) % 7
        if pesach_1_weekday == 0:
            pesach_1_weekday = pesach_1_weekday + 7

        siman_hashana_C = heb_letter_day(pesach_1_weekday)

        return [siman_hashana_A, siman_hashana_B, siman_hashana_C], efresh


    #------------------------------------------------

    #####################################################
    # מכאן והלאה פונקציות והגדרות שפועלים רק עם ממשק משתמש גרפי טקינטר
    #####################################################
    
    # פונקצייה עבוק לחצן "נקה נתונים" לניקוי תיבות קלט התאריך
    def clear_Entry():
        Entry_heb_year.delete(0, END)

    #------------------------------------------------------------

    # פונקצייה לכפתור העתקת הנתונים של קובץ הטקסט
    # פונקצייה זו מופעלת על ידי כפתור "העתק תוצאות ללוח"
    def copy_txt_to_clipboard():
        C = txt.get(1.0, END)
        clipboard.copy(C)

    def save_txt_to_path():
        C = txt.get(1.0, END)
        # הגדרת התאריך בלי גירשיים לצורך שם הקובץ
        heb_year = Entry_heb_year.get().replace("׳","").replace('״',"")
        
        file = asksaveasfilename(defaultextension=".txt", initialfile = f"מידע על שנה עברית - {heb_year}")
        
        # שמירת הקובץ תוך אפשרות ציון הקידוד המתאים
        # אפשרויות קידוד: cu_encod או "utf-8"
        # איף פייל נועד למנוע שגיאה במקרה שסגרו את החלון כי החליטו לא לשמור את הקובץ
        if file:
            with open(file, 'w', encoding="utf-8") as f:
                f.write(reverse(C))
        
       
    #-----------------------------------------------------------------------------------------------------------


    # פונקציית מיין: סיכום סופי והדפסות עם הגדרות מיוחדות עבור ממשק משתמש גרפי של טקינטר
    # פונקצייה זו מופעלת באמצעות הכפתור "חשב נתונים"
    def main_result():

        # קלט תאריך מהמשתמש
        kelet = Entry_heb_year.get().replace(' ','').replace("׳","'")
        
        #ניסיון לחשב נתונים מתוך שדה קלט עברי
        try:
            # המרת התאריך שהוזן, למספרים וחלוקה למשתנים נפרדים עבור יום חודש ושנה
            shana1 = int(kelet)
        except:
            
            if "-" in kelet:
                split_kelet = kelet.split("-")
                shana1 = int(split_kelet[1])
                
            elif "'" in kelet:
                split_kelet = kelet.split("'")
                shana1 = (gy.to_number(split_kelet[0]) * 1000) + gy.to_number(split_kelet[1])
                #print(gy.to_number(split_kelet[1]))
            
            else:
                if len(kelet) > 0:
                    shana1 = gy.to_number(kelet)
                    tkMessageBox.showinfo( "alert", "שים לב! ייתכן ששכחת להוסיף את מספר האלפים, או ששכחת להוסיף גרש לאחר מספר האלפים. במקרה כזה, יש טעות בתוצאות ועליך לחשב את הנתונים מחדש")

        #--------------------

        # חישוב 7 נתונים על השנה המבוקשת באמצעות פונקציית סיכום
        arr_sikum_shana_1 = sikum(shana1)

        # שמירה במשתנים נפרדים של 7 הנתונים המתקבלים מפונקציית סיכום 
        machzor_19_shana_1 = arr_sikum_shana_1[0]
        shana_1_bemachzor_19 = arr_sikum_shana_1[1]
        sum_heb_months_be_over_from_molad_baharad_to_shana_1 = arr_sikum_shana_1[2]
        molad_tishrei_1_bechalakim = arr_sikum_shana_1[3]
        molad_tishrei_1 = arr_sikum_shana_1[4]
        rosh_hashana_1_weekday = arr_sikum_shana_1[5]
        dechia1 = arr_sikum_shana_1[6]

        # מכאן והלאה: חישוב כל הנ"ל עבור השנה שלאחריה שהיא השנה הבאה לאחר השנה שהזין המשתמש

        # הגדרה מהי השנה שלאחריה
        shana2 = shana1 + 1
        
        # חישוב 7 נתונים על השנה שלאחריה באמצעות פונקציית סיכום
        arr_sikum_shana_2 = sikum(shana2)

        # שמירה במשתנים נפרדים של 7 הנתונים המתקבלים מפונקציית סיכום 
        machzor_19_shana_2 = arr_sikum_shana_2[0]
        shana_2_bemachzor_19 = arr_sikum_shana_2[1]
        sum_heb_months_be_over_from_molad_baharad_to_shana_2 = arr_sikum_shana_2[2]
        molad_tishrei_2_bechalakim = arr_sikum_shana_2[3]
        molad_tishrei_2 = arr_sikum_shana_2[4]
        rosh_hashana_2_weekday = arr_sikum_shana_2[5]
        dechia2 = arr_sikum_shana_2[6]

        # מכאן והלאה סיכומים כלליים על השנה המבוקשת

        '''# בדיקת תאריך לועזי של ראש השנה בשנה המבוקשת באמצעות חבילת פיי-לוח
        rosh_hashana_heb_pyluach = dates.HebrewDate(shana1, 7, 1)
        rosh_hashana_greg_pyluach = rosh_hashana_heb_pyluach.to_greg()

        # בדיקת תאריך לועזי של פסח בשנה המבוקשת באמצעות חבילת פיי-לוח
        pesach_heb_pyluach = dates.HebrewDate(shana1, 1, 15)
        pesach_greg_pyluach = pesach_heb_pyluach.to_greg()'''


        # סיכום סימן השנה של השנה המבוקשת, והפרש הימים בשבוע בין שני ראשי השנה
        siman_hashana_1, efresh = siman_hashana(rosh_hashana_1_weekday, rosh_hashana_2_weekday, shana_1_bemachzor_19)

        #------------------------------
        # הגדרת היום בשבוע שבו יחולו מספר מועדים בשנה המבוקשת            
        pesach_weekday = gy.to_number(siman_hashana_1[2])

        yom_kipur_weekday = (rosh_hashana_1_weekday + 2) % 7
        if yom_kipur_weekday == 0:
            yom_kipur_weekday = yom_kipur_weekday + 7

        sukot_weekday = rosh_hashana_1_weekday

        shavuot_weekday = (pesach_weekday + 1) % 7

        if siman_hashana_1[1] == "ש":
            chanuka_weekday = rosh_hashana_1_weekday
        else:
            chanuka_weekday = (rosh_hashana_1_weekday - 1) % 7

        purim_weekday = (pesach_weekday - 2) % 7

        tisha_beav_weekday = pesach_weekday

        #-----------------------------------------

        # מכאן והלאה חישוב מולדות ממוצעים של כל חודשי השנה המבוקשת

        # קריאה לפונקציית חישוב מולדות חודשים בחלקים, ושמירה של התוצאה 
        moladot_chodashim_bechalakim_1 = moladot_chodashim_bechalakim(molad_tishrei_1_bechalakim, shana_1_bemachzor_19)

        # קריאה לפונקציית מולדות חודשים על עותק של מולדות חודשים בחלקים, ושמירת התוצאות
        moladot_chodashim_1 = moladot_chodashim(moladot_chodashim_bechalakim_1)

        # הגדרת רשימות המשמשות את ההדפסה של פונקציית חישוב מולדות חודשים        
        chodashim_pshuta = ["תשרי", "מְרַחשְׁוָון", "כִּסְלֵיו", "טבת", "שבט", "אדר", "ניסן", "אייר", "סיוון", "תמוז", "אב", "אלול", "תשרי שלאחריה"]
        chodashim_meuberet = ["תשרי", "מְרַחשְׁוָון", "כסלו", "טבת", "שבט", "אדר ראשון", "אדר שני", "ניסן", "אייר", "סיוון", "תמוז", "אב", "אלול", "תשרי שלאחריה"]
        # עד כאן חישוב מולדות ממוצעים של כל חודשי השנה המבוקשת

        # חישוב מרחק תקופת ניסן לשמואל ממולד ניסן באמצעות פונקצייה
        tshuva = kama_tkufat_nissan_shmuel_lifnei_mold_nisan(shana1)
        
        # פונקצייה שמחזירה את מספר השנה העברית באותיות ומשתמשת בסיפריית גימטרייה של פיילוח
        def heb_year_string(heb_year, thousands=True, withgershayim=True):
            return gematria._num_to_str(heb_year, thousands=thousands, withgershayim=withgershayim)
        
        # קבלת מידע על השנה לשמיטה למעשרות ולחורבן ולמחזור 28 שנות חמה באמצעות פונקציות שהגדרתי למעלה
        shana_lashmita, shnat_maasrot = get_shana_lashmita_and_maasrot(shana1)
        shana_lechurban_bait_sheni = get_shana_lechurban_bait_sheni(shana1)
        shana_1_bemachzor_28, machzor_28_shana_1 = chishuv_shana_bemachzor_28(shana1)
        
        #-----------------------------------------------------------------------
        ############  כל ההדפסות ###############

        # הדפסות על תאריך הלידה

        # פתיחת תיבת הטקסט למצב כתיבה
        txt.configure(state="normal")

        # מחיקת מה שיש בתיבת הטקסט
        txt.delete(1.0, END)

        # ההדפסות עצמן
        txt.insert("end", "\n#####   תקציר   #####")
        txt.insert("end", f'\n\nהשנה המבוקשת היא: {shana1} - {heb_year_string(shana1)}')
        txt.insert("end", f'\n\n{string_heb_year_to_loazit_year_plus_zero(shana1)}')
        txt.insert("end", "\n")
        # הדפסות של מספר ימי השנה של השנה המבוקשת
        if efresh == 3:
            txt.insert("end","\nהשנה המבוקשת היא שנה פשוטה חסרה (כלומר: בת 353 ימים, מְרַחשְׁוָון וכסליו חסרים)")
        elif efresh == 4:
            txt.insert("end","\nהשנה המבוקשת היא שנה פשוטה כסדרה (כלומר: בת 354 ימים, מְרַחשְׁוָון חסר וכסליו מלא)")
        #--------------------------------------------
        elif efresh == 5 and shana_1_bemachzor_19 not in (3,6,8,11,14,17,19):
            txt.insert("end","\nהשנה המבוקשת היא שנה פשוטה שלמה (כלומר: בת 355 ימים, מְרַחשְׁוָון וכסליו מלאים)")
        elif efresh == 5 and shana_1_bemachzor_19 in (3,6,8,11,14,17,19):
            txt.insert("end","\nהשנה המבוקשת היא שנה מעוברת חסרה (כלומר: בת 383 ימים, מְרַחשְׁוָון וכסליו חסרים)")
        #--------------------------------------------
        elif efresh == 6:
            txt.insert("end","\nהשנה המבוקשת היא שנה מעוברת כסדרה (כלומר: בת 384 ימים, מְרַחשְׁוָון חסר וכסליו מלא)")
        elif efresh == 7:
            txt.insert("end","\nהשנה המבוקשת היא שנה מעוברת שלמה (כלומר: בת 385 ימים, מְרַחשְׁוָון וכסליו מלאים)")

        txt.insert("end", f'\n\nסימן השנה של השנה המבוקשת הוא:    {siman_hashana_1[0]} {siman_hashana_1[1]} {siman_hashana_1[2]}')
        txt.insert("end", "\n")
        txt.insert("end","\n[אות ימנית: יום בשבוע שיחול בו ראש השנה]")
        txt.insert("end","\n[אות אמצעית: האם השנה ח = חסרה, כ = כסדרה, או: ש = שלמה]")
        txt.insert("end","\n[אות שמאלית: יום בשבוע שיחול בו חג ראשון של פסח]")
        
        # הדפסות מידע על נתונים נוספים על השנה שנה לשמיטה למעשרות ולחורבן
        txt.insert("end", "\n\n—————————————————————")
        txt.insert("end", "\n\nמידע נוסף על השנה המבוקשת")
        txt.insert("end", "\n")
        txt.insert("end", f'\nמספר השנה במניין שמות השמיטה הוא:   {shana_lashmita}')
        txt.insert("end", f'\nלפיכך, המעשר שמפרישים השנה הוא:   {shnat_maasrot}')
        txt.insert("end", f'\nשימו לב שלגבי פירות האילן, שנת המעשרות הנוכחית נכונה רק החל מיום ט"ו בשבט')
        txt.insert("end", f'\nמספר השנה המבוקשת במחזור קטן (19 שנים פשוטות ומעוברות) הוא: {shana_1_bemachzor_19}   (במחזור {machzor_19_shana_1})') 
        txt.insert("end", f'\nמספר השנה המבוקשת במחזור גדול (28 שנות חמה) הוא: {shana_1_bemachzor_28}   (במחזור {machzor_28_shana_1})')
        txt.insert("end", f'\n(מספר השנה במחזור הגדול, נכון רק החל מיום תקופת ניסן לשיטת שמואל והלאה - ראו להלן)')
        txt.insert("end", f"\nזוהי {shana_lechurban_bait_sheni}")

        # הדפסות מידע על נתונים נוספים שאפשר להסיק מתוך סימן השנה
        txt.insert("end", "\n\n—————————————————————")
        txt.insert("end", "\n\nמידע על היום בשבוע שבו יחולו מועדים שונים בשנה המבוקשת")
        txt.insert("end", "\n")
        #txt.insert("end", "\nחגים מהתורה")
        #txt.insert("end", "\n")
        txt.insert("end", f'\nיום הכיפורים יחול ביום: {heb_string_day(yom_kipur_weekday)}')
        txt.insert("end", f'\nיום ראשון של סוכות יחול ביום: {heb_string_day(sukot_weekday)}')
        txt.insert("end", f'\nיום ראשון של פסח יחול ביום: {heb_string_day(pesach_weekday)}')
        txt.insert("end", f'\nחג השבועות יחול ביום: {heb_string_day(shavuot_weekday)}')
        txt.insert("end", "\n")
        #txt.insert("end", "\nמועדים מדרבנן")
        #txt.insert("end", "\n")
        txt.insert("end", f'\nנר ראשון של חנוכה יחול ביום: {heb_string_day(chanuka_weekday)}')
        txt.insert("end", f'\nפורים (דפרזים - יד) יחול ביום: {heb_string_day(purim_weekday)}')
        if tisha_beav_weekday == 7:
            txt.insert("end", "\nתשעה באב יחול ביום שבת קודש, והתענית נדחית ליום ראשון")
        else:
            txt.insert("end", f'\nתשעה באב יחול ביום: {heb_string_day(tisha_beav_weekday)}')

        txt.insert("end", "\n\n—————————————————————")
        txt.insert("end", "\n\n#####   פירוט החישובים   #####")
        txt.insert("end", "\n")
        txt.insert("end", f'\nהשנה המבוקשת היא: {shana1} - {heb_year_string(shana1)}')
        txt.insert("end", f'\n{string_heb_year_to_loazit_year_plus_zero(shana1)}')
        txt.insert("end", f'\nמספר השנה המבוקשת במחזור 19 שנים פשוטות ומעוברות הוא: {shana_1_bemachzor_19}   (במחזור {machzor_19_shana_1})') 
        # הדפסת בדיקה האם השנה המבוקשת היא פשוטה או מעוברת לפי בדיקה בתוך רשימת השנים המעוברות שבמחזור 19 השנים
        if shana_1_bemachzor_19 in (3,6,8,11,14,17,19):
            txt.insert("end", f'\nלפיכך, ולפי כלל גו"ח אדז"ט: השנה המבוקשת היא שנה מעוברת (כלומר: בת 13 חודשים - שני אדרים)')
        else:
            txt.insert("end", f'\nלפיכך, ולפי כלל גו"ח אדז"ט: השנה המבוקשת היא שנה פשוטה (כלומר: בת 12 חודשים - אדר אחד)')

        # הדפסת חישוב מספר החודשים שעברו ממולד בהר"ד עד מולד תשרי של השנה המבוקשת
        txt.insert("end", f'\nסך החודשים שחלפו ממולד בהר"ד למולד תשרי של השנה המבוקשת הוא: {sum_heb_months_be_over_from_molad_baharad_to_shana_1}')
        txt.insert("end", f'\nמולד תשרי בחלקים של השנה המבוקשת הוא: {molad_tishrei_1_bechalakim}')
        txt.insert("end", f'\nמולד תשרי של השנה המבוקשת יהיה: ביום - {heb_string_day(molad_tishrei_1[0])}, {molad_tishrei_1[1]} - שעות , ו- {molad_tishrei_1[2]} חלקים')
        # הדפסה האם ראש השנה נדחה ואם כן בכמה ימים
        txt.insert("end", f'\nראש השנה של השנה המבוקשת אינו נדחה אלא יחול ביום מולד תשרי' if dechia1 == 0 else f'\nמספר הימים שבהם נדחה ראש השנה של השנה המבוקשת מיום מולד תשרי:  {dechia1}')
        # הדפסת היום שבו יחול ראש השנה של השנה המבוקשת
        txt.insert("end", f'\nראש השנה של השנה המבוקשת יהיה ביום: {heb_string_day(rosh_hashana_1_weekday)}')
        
        # הדפסת התאריך העברי שבו יחול מולד תשרי של השנה המבוקשת. מתבסס על הכלל שחודש אלול הוא תמיד חסר כלומר: בן 29 יום
        if dechia1 == 0:
            txt.insert("end", f"\nמולד תשרי של השנה המבוקשת יהיה בתאריך: א' בתשרי {heb_year_string(shana1)}")
        elif dechia1 == 1:
            txt.insert("end", f"\nמולד תשרי של השנה המבוקשת יהיה בתאריך: כ'ט באלול {heb_year_string(shana1-1)}")
        elif dechia1 == 2:
            txt.insert("end", f"\nמולד תשרי של השנה המבוקשת יהיה בתאריך: כ'ח באלול {heb_year_string(shana1-1)}")

        # מכאן והלאה הדפסות עבור השנה שלאחריה
        # שורה רווח
        txt.insert("end", "\n")
        txt.insert("end", f'\nהשנה שלאחר השנה המבוקשת (=שנה שלאחריה) היא: {shana2} - {heb_year_string(shana2)}')
        txt.insert("end", f'\n{string_heb_year_to_loazit_year_plus_zero(shana2)}')
        txt.insert("end", f'\nמספר השנה שלאחריה במחזור 19 שנים פשוטות ומעוברות הוא: {shana_2_bemachzor_19}   (במחזור {machzor_19_shana_2})')
        # הדפסת בדיקה האם השנה המבוקשת היא פשוטה או מעוברת לפי בדיקה בתוך רשימת השנים המעוברות שבמחזור 19 השנים
        if shana_2_bemachzor_19 in (3,6,8,11,14,17,19):
            txt.insert("end", f'\nלפיכך, ולפי כלל גו"ח אדז"ט: השנה שלאחריה היא שנה מעוברת (כלומר: בת 13 חודשים - שני אדרים)')
        else:
            txt.insert("end", f'\nלפיכך, ולפי כלל גו"ח אדז"ט: השנה שלאחריה היא שנה פשוטה (כלומר: בת 12 חודשים - אדר אחד)')

        # הדפסת חישוב מספר החודשים שעברו ממולד בהר"ד עד מולד תשרי של השנה שלאחריה
        txt.insert("end", f'\nסך החודשים שחלפו ממולד בהר"ד למולד תשרי של השנה שלאחריה הוא: {sum_heb_months_be_over_from_molad_baharad_to_shana_2}')
        txt.insert("end", f'\nמולד תשרי בחלקים של השנה שלאחריה הוא: {molad_tishrei_2_bechalakim}')
        txt.insert("end", f'\nמולד תשרי של השנה שלאחריה יהיה: ביום - {heb_string_day(molad_tishrei_2[0])}, {molad_tishrei_2[1]} - שעות, ו- {molad_tishrei_2[2]} חלקים')
        # הדפסה האם ראש השנה של השנה שלאחריה נדחה ואם כן בכמה ימים
        txt.insert("end", f'\nראש השנה של השנה שלאחריה אינו נדחה אלא יחול ביום מולד תשרי' if dechia2 == 0 else f'\nמספר הימים שבהם נדחה ראש השנה של השנה שלאחריה מיום מולד תשרי:  {dechia2}')
        # הדפסת היום שבו יחול ראש השנה של השנה שלאחריה
        txt.insert("end", f'\nראש השנה של השנה שלאחריה יהיה ביום: {heb_string_day(rosh_hashana_2_weekday)}')
        
        # הדפסת התאריך העברי שבו יחול מולד תשרי של השנה שלאחריה. מתבסס על הכלל שחודש אלול הוא תמיד חסר כלומר: בן 29 יום
        if dechia2 == 0:
            txt.insert("end", f"\nמולד תשרי של השנה שלאחריה יהיה בתאריך: א' בתשרי {heb_year_string(shana2)}")
        elif dechia2 == 1:
            txt.insert("end", f"\nמולד תשרי של השנה שלאחריה יהיה בתאריך: כ'ט באלול {heb_year_string(shana2-1)}")
        elif dechia2 == 2:
            txt.insert("end", f"\nמולד תשרי של השנה שלאחריה יהיה בתאריך: כ'ח באלול {heb_year_string(shana2-1)}")

        txt.insert("end", "\n")
        # הדפסת הפרש הימים בין שני ראשי השנים
        txt.insert("end", f'\nההפרש בימי השבוע בין ראש השנה של השנה המבוקשת לבין ראש השנה של השנה שלאחריה הוא: {efresh}')
        txt.insert("end", f'\n :לפיכך, ולפי כלל: גד"ה - בפשוטה, הו"ז - במעוברת')
        # הדפסות של מספר ימי השנה של השנה המבוקשת
        if efresh == 3:
            txt.insert("end","\nהשנה המבוקשת היא שנה פשוטה חסרה (כלומר: בת 353 ימים, מְרַחשְׁוָון וכסליו חסרים)")
        elif efresh == 4:
            txt.insert("end","\nהשנה המבוקשת היא שנה פשוטה כסדרה (כלומר: בת 354 ימים, מְרַחשְׁוָון חסר וכסליו מלא)")
        #--------------------------------------------
        elif efresh == 5 and shana_1_bemachzor_19 not in (3,6,8,11,14,17,19):
            txt.insert("end","\nהשנה המבוקשת היא שנה פשוטה שלמה (כלומר: בת 355 ימים, מְרַחשְׁוָון וכסליו מלאים)")
        elif efresh == 5 and shana_1_bemachzor_19 in (3,6,8,11,14,17,19):
            txt.insert("end","\nהשנה המבוקשת היא שנה מעוברת חסרה (כלומר: בת 383 ימים, מְרַחשְׁוָון וכסליו חסרים)")
        #--------------------------------------------
        elif efresh == 6:
            txt.insert("end","\nהשנה המבוקשת היא שנה מעוברת כסדרה (כלומר: בת 384 ימים, מְרַחשְׁוָון חסר וכסליו מלא)")
        elif efresh == 7:
            txt.insert("end","\nהשנה המבוקשת היא שנה מעוברת שלמה (כלומר: בת 385 ימים, מְרַחשְׁוָון וכסליו מלאים)")


        txt.insert("end", "\n\n—————————————————————")
        txt.insert("end", "\n\nרשימת מולדות ממוצעים עבור כל חודשי השנה המבוקשת, כולל מולד תשרי של השנה שלאחריה")
        txt.insert("end", "\n")

        # הדפסת רשימת מולדות כל חודשי השנה תוך בדיקה האם מדובר בשנה פשוטה או מעוברת
        for i in range(len(moladot_chodashim_1)):
            txt.insert("end", f'\nמולד חודש {chodashim_meuberet[i] if shana_1_bemachzor_19 in (3,6,8,11,14,17,19) else chodashim_pshuta[i]} יהיה: ביום - {heb_string_day(moladot_chodashim_1[i][0])}, {moladot_chodashim_1[i][1]} - שעות, ו- {moladot_chodashim_1[i][2]} חלקים')
        
        txt.insert("end", "\n\n")
        txt.insert("end", "—————————————————————")
        txt.insert("end", "\n\n## תכונה ניסיונית! מידע על התקופות שבלוח ##")
        txt.insert("end", "\n")
        txt.insert("end", f'\n\nתקופת ניסן לפי שמואל מקדימה את מולד ניסן ב: ימים - {tshuva[1]}; שעות - {tshuva[0]}; חלקים - {tshuva[2]}\n')
        txt.insert("end", "\n\n")
        txt.insert("end", "—————————————————————")
        txt.insert("end", "\n\n## מידע כללי על סוגי השנים בלוח העברי ##")
        txt.insert("end", "\n")
        txt.insert("end", "\nבלוח העברי הקבוע קיימים בסך הכל 14 סוגי שנים") 
        txt.insert("end", "\n")
        txt.insert("end", "\nשבע סוגי שנים פשוטות")
        txt.insert("end", "\n")
        txt.insert("end", "\nפשוטה חסרה בת 353 ימים: בחג, זחא")
        txt.insert("end", "\nפשוטה כסדרה בת 354 ימים: גכה, הכז")
        txt.insert("end", "\nפשוטה שלמה בת 355 ימים: בשה, השא, זשג")

        txt.insert("end", "\n")
        txt.insert("end", "\nשבע סוגי שנים מעוברות")
        txt.insert("end", "\n")
        txt.insert("end", "\nמעוברת חסרה בת 383 ימים: בחה, החא, זחג")
        txt.insert("end", "\nמעוברת כסדרה בת 384 ימים: גכז")
        txt.insert("end", "\nמעוברת שלמה בת 385 ימים: בשז, השג, זשה")

        # ===== רוורס חכם לכל תיבת הטקסט (לינוקס) =====
        full_text = txt.get("1.0", "end-1c")
        txt.delete("1.0", "end")
        txt.insert("1.0", reverse(full_text))

        # הגדרת העיצוב של הטקסט בתיבת הטקסט שיהיה ממורכז
        txt.tag_configure("center", justify='center')
        txt.tag_add("center", 1.0, "end")

        # סגירת תיבת הטקסט לקריאה בלבד
        txt.configure(state="disabled")

    #-----------------------------------------

    if __name__ == '__main__':

        # מכאן והלאה עיצוב גרפי של ממשק המשתמש

        # התוכנית עצמה בתוך טקינטר וכל מה שקשור לטקינטר

        # הגדרת משתנה ששומר חלון טקינטר, והגדרת כותרת החלון ומינימום גודל החלון
        hyi=Toplevel(ws) # Tk()
        hyi.minsize(675,600)
        hyi.geometry(f"{round(675*magnification_factor)}x{round(685*magnification_factor)}+{round(110*magnification_factor)}+{round(1*magnification_factor)}")
        hyi.title(reverse(f'מידע על שנה עברית - מאת הרב ד"ר שמחה גרשון בורר | גרסה: {dt.date(2024,8,26):%d/%m/%Y}', for_title = True))
        #הגדרת צבע לכל החלון
        hyi.configure(bg=cu_color)
        
        # פונקצייה לסגירת החלון לאחר רישום במשתנה שהחלון נסגר 
        def hyi_close():
            global subprocess_patuach
            subprocess_patuach -= 1
            hyi.destroy()
        
        # בסגירת החלון ייתבצעו הפעולות שבפונקצייה
        hyi.protocol("WM_DELETE_WINDOW", hyi_close)



        # הגדרת משתנה ששומר הגדרות כלליות לפונט שיהיה בשימוש
        font_buttons = tkinter.font.Font(hyi, family='narkisim', size=12, weight='bold')
        font_ = tkinter.font.Font(hyi, family='david', size=12)

        #---------------------------------------------

        # אזור נפרד להזנת תאריך
        input_heb = cu_PanedWindow(hyi)
        '''
        # הגדרת משתנה ששומר תיבת קלט טקסט שבה המשתמש מזין את תאריך הלידה הלועזי
        Label(input_heb, justify = 'right', text="ה'תשפב או 5782", font = font_buttons).grid(column=1, row=1)
        Entry_heb_year = Entry(input_heb, justify = 'center', width=8, font = font_buttons)
        Entry_heb_year.grid(column=1, row=2)
        '''
        # יצירת רצף של שנים עבריות במערך עבור בחירת שנים עבריות
        a = range(1,7000)
        heb_years = []
        for i in range(len(a)):
            heb_years.append(f"{gematria._num_to_str(a[i], thousands=True, withgershayim=True)} - {a[i]}")

        Label(input_heb, text="                      ").grid(column=3, row=2)
        
        # בחירה בין רשימת שנים עבריות
        Entry_heb_year = StringVar(hyi)
        heb_year_cb = ttk.Combobox(input_heb, textvariable=Entry_heb_year, width=16, state=state1,values=[*heb_years],font="narkisim 18",justify='center',)
        heb_year_cb.grid(column=2, row=2)
        Label(input_heb, text=reverse("בחרו שנה עברית")).grid(column=2, row=3)
        
        Label(input_heb, text="   ").grid(column=1, row=2)
        
        # הגדרת משתנה ששומר כפתור לשמירת הנתונים לקובץ
        Button(input_heb, text=reverse("שמירת\nהנתונים לקובץ"),command=save_txt_to_path).grid(column=0, row=2)
        
        
        input_heb.pack()
        
        
        # רק בשביל העיצוב
        Label(hyi, text="").pack()

 
        #-------------------------------------------------------

        # אזור נפרד לטקסט התוצאות
        output_text = cu_PanedWindow(hyi)


        # ברי גלילה לאיזור התוצאות
        # גלילה למעלה ולמטה
        Y_scrollbar = Scrollbar(output_text, orient = 'vertical')
        Y_scrollbar.pack( side = RIGHT, fill = Y )

        # גלילה לימין ושמאל כרגע לא צריכה להיות בשימוש כי תיבת הטקסט עצמה לא מאפשרת חריגה של הטקסט לימין ושמאל
        X_scrollbar = Scrollbar(output_text, orient = 'horizontal')
        X_scrollbar.pack( side = BOTTOM, fill = X )

        # חלון טקסט להצגת התוצאות
        txt = Text(output_text, height=50, width=80, borderwidth=0, yscrollcommand = Y_scrollbar.set, xscrollcommand = X_scrollbar.set, font = "david 13")
        
        # הגדרת העיצוב של הטקסט בתיבת הטקסט: שיהיה ממורכז
        txt.tag_configure("center", justify='center')
        txt.tag_add("center", 1.0, "end")   

        # סגירה של תיבת הטקסט לקריאה בלבד ואריזה לתוך החלון
        txt.configure(state="disabled")

        # חסימת כל תגובה לעכבר וכו של תיבת הטקסט
        #txt.bindtags(("txt", "wnd", "all"))

        # לחילופין, חסימת שתי תגובות ספציפיות לעכבר עבור תיבת הטקסט
        txt.bind("<Button>", lambda event: "break")
        txt.bind("<Motion>", lambda event: "break")


        # אריזת תיבת הטקסט
        txt.pack( side = LEFT, fill = BOTH )

        # הגדרת ברי הגלילה שפעולתם תתבצע על תיבת הטקסט
        Y_scrollbar.config( command = txt.yview )
        X_scrollbar.config( command = txt.xview )

        # אריזת האיזור הנפרד של טקסט התוצאות
        output_text.pack()

        #------------------------------------------------------
        
        # הגדרת השנה העברית הנוכחית במספרים
        heb_year_numbers = dates.GregorianDate(1880, 10, 20).from_pydate(dt.date.today()).to_heb().year
        # הגדרת השנה העברית הנוכחית באותיות
        heb_year_leters = gematria._num_to_str(heb_year_numbers, thousands=True, withgershayim=True)
        # מייד בפתיחת התוכנה הקומבובוקס יוגדר לשנה העברית הנוכחית ויחושבו הנתונים
        heb_year_cb.set(f"{heb_year_leters} - {heb_year_numbers}")
        main_result()

        # כל שינוי של נתון בקומבובוקס, גורר קריאה לפונקציית כל החישובים כדי לעדכן את החישובים
        heb_year_cb.bind('<<ComboboxSelected>>', lambda event: main_result())

        # הגדרת לולאה אינסופית שמפעילה את חלון טקטינר שיצרנו
        #hyi.mainloop()




    # In[ ]:


# פונקצייה שמחזירה את התאריך הגרגוריאני שבו יחול פסח בשנה נתונה או את התאריך הגרגוריאני שבו יחול ראש השנה שאחרי פסח של השנה הנתונה
# כברירת מחדל מקבל קלט של שנה לועזית אך יכול לקבל קלט של שנה עברית במספרים אם מגדירים זאת בקריאה לפונקצייה
# פונקצייה זו נמצאת כאן לשמירה בלבד ואיננה מתפקדת כעת כחלק מתוכנת כוכבים וזמנים
def get_geus_rosh_hashana_greg(year, from_heb_year = False):

    if from_heb_year:
        A = year
        # הגדרת שנה לועזית המקבילה לשנה העברית שהוזנה
        B = A - 3760

    else:
        B = year
        A = B + 3760

    # אינני יודע מה מייצגות שתי ההגדרות הבאות 

    # איי קטנה נותן מספר בין 0 ל- 18 שממנו יודעים האם השנה העברית פשוטה או מעוברת. אם איי קטנה קטן מ-11 השנה היא פשוטה, ואם גדול מ-12 השנה היא מעוברת
    # בנוסף, ככל שאיי קטנה קרובה יותר למספר 18, זה אומר שפסח רחוק יותר מתקופת ניסן
    a = (12 * A + 17) % 19
    
    # נוסחה לקבל את מספר השנה במחזור השנים הפשוטות והמעוברות לפי איי קטנה
    # לדוגמא אם איי קטנה שווה 10 אז מספר השנה במחזור 19 השנים הוא 1
    shana_bemachzor19 = {10:1,3:2,15:3,8:4,1:5,13:6,6:7,18:8,11:9,4:10,16:11,9:12,2:13,14:14,7:15,0:16,12:17,5:18,17:19}.get(a)

    # בי קטנה מציינת האם השנה היוליאנית המקבילה היא פשוטה (365 יום) או כבושה (366 יום). אם אין שארית, השנה היא כבושה
    b = A % 4

    # נוסחת גאוס בשברים עשרוניים
    nuscha = 32.0440931611436 + (1.5542417966211826) * a + 0.25 * b - (0.0031777940220922675) * A 

    # נוסחת גאוס בשברים פשוטים
    #nuscha = 32 + 4343/98496 + (1 + 272953/492480) * a + 1/4 * b - (313/98496) * A

    # אם גדולה זה השלם של הנוסחה
    # ט"ו בניסן של השנה המבוקשת יחול ביום אם גדולה בחודש מרס
    M = int(nuscha)

    # אם קטנה היא השארית של הנוסחה, והיא חשובה לצורך הדחיות
    m = nuscha - int(nuscha)

    # סי הוא היום בשבוע שבו יחול פסח של השנה המבוקשת. אם סי שווה לאפס הכוונה ליום שבת 7
    c = (M + 3 * A + 5 * b + 5) % 7

    # מידע: דחיית מולד זקן מוכנסת כבר במספר 32 שבנוסחה הראשית

    # חישוב דחיית לא בד"ו פסח שהיא שיקוף של דחיית לא אד"ו ראש
    if c in (2,4,6):
        c = c + 1
        M = M + 1
    # חישוב השפעת דחיית גטר"ד בשנה פשוטה
    elif c == 1 and a > 6 and m >= 0.6329:
        c = c + 2
        M = M + 2
    # חישוב השפעת דחיית בטו תקפט בשנה פשוטה שהיא מוצאי מעוברת
    elif c == 0 and a > 11 and m >= 0.8977:
        c = c + 1
        M = M + 1
    else:
        c = c
        M = M

    # טיפול באם היום בשבוע של פסח יוצא אפס זה אומר יום 7 שזה שבת
    if c == 0:
        c = c + 7

    # אם אם גדולה קטן או שווה לשלושים ואחד פסח יהיה בחודש מרס
    if M <= 31:
        M = M
        chodesh_julyani_pesach = 3 
    # במצב הבא התאריך יהיה בחודש אפריל במקום בחודש מרס
    elif M > 31:
        M = M - 31
        chodesh_julyani_pesach = 4
        
        
    # מעבר ללוח הגרגוריאני
    # חודש מרס הוא תמיד 31 ימים

    if B >= 1582 and B < 1700:
        M = (M + 10) 
    elif B >= 1700 and B < 1800:
        M = (M + 11) 
    elif B >= 1800 and B < 1900:
        M = (M + 12) 
    elif B >= 1900 and B < 2100:
        M = (M + 13) 
    elif B >= 2100 and B < 2200:
        M = (M + 14) 
    elif B >= 2200 and B < 2300:
        M = (M + 15) 
    else:
        M = M

    # אם אם גדולה קטן או שווה לשלושים ואחד פסח יהיה בחודש מרס
    if M <= 31:
        M = M
        chodesh_gregoriani_pesach = chodesh_julyani_pesach

    # במצב הבא התאריך יהיה בחודש אפריל במקום בחודש מרס
    elif M > 31:
        M = M - 31
        chodesh_gregoriani_pesach = chodesh_julyani_pesach + 1

    pesach_greg_day = M
    pesach_greg_month = chodesh_gregoriani_pesach
    pesach_greg_year = B
    pesach_weekday = c
    
    # האם זו שנה עברית מעוברת
    heb_leap_year = shana_bemachzor19 in (3,6,8,11,14,17,19)
    #print(f'היום הראשון של פסח בשנה עברית {A} יחול בתאריך הלועזי הגרגוריאני הבא: יום: {M} חודש: {chodesh_gregoriani_pesach} שנה: {B} ויחול ביום {c} בשבוע')   

    
    #############################################################################################################
    # מציאת התאריך הלועזי של ראש השנה של השנה הבא לאחר הפסח ראו ספר שערים ללוח העברי עמוד 204
    next_rosh_hashana_greg_day = pesach_greg_day + 10
    if pesach_greg_month == 3:
        next_rosh_hashana_greg_month = 8
    elif pesach_greg_month == 4:
        next_rosh_hashana_greg_month = 9
        
    next_rosh_hashana_greg_year = pesach_greg_year
    
    if next_rosh_hashana_greg_day > 31 and pesach_greg_month == 3:
        next_rosh_hashana_greg_day = next_rosh_hashana_greg_day - 31
        next_rosh_hashana_greg_month = 9
    elif next_rosh_hashana_greg_day > 30 and pesach_greg_month == 4:
        next_rosh_hashana_greg_day = next_rosh_hashana_greg_day - 30
        next_rosh_hashana_greg_month = 10
        
    #print(next_rosh_hashana_greg_year, next_rosh_hashana_greg_month, next_rosh_hashana_greg_day)
    ############################################################################################################
    
    return (next_rosh_hashana_greg_year,next_rosh_hashana_greg_month,next_rosh_hashana_greg_day)



###################################################################################################################
                                 # תחילת תוכנת ממיר תאריכים
###################################################################################################################

def date_converter():

     # פונקצייה חדשה שכתבתי במיוחד, אשר מחזירה את הבדל הימים בין הלוח היוליאני ללוח הגרגוריאני
    # הפונקצייה צריכה לקבל מספר שנה לועזית ומספר חודש לועזי
    # ראו: https://en.wikipedia.org/wiki/Proleptic_Gregorian_calendar#cite_note-8
    def calculate_gregorian_julian_difference_days(greg_year,greg_month):

        # מאה השנים שבהן יש אפס הבדל ימים בין הלוח היוליאני לגרגוריאני זה החל מתאריך 1.3.200 עד 1.3.300
        zero_difference_year_max = 300
        zero_difference_year_min = 200


        # תיקון למקרה שהשנה היא מאה עגול והחודש הוא מרץ ואילך שאז צריך לחשב דילוג ימים כמו של השנה הבאה
        # לדוגמא: בשנת 1300 החל מחודש מרץ ואילך יש לחשב הפרש ימים כמו של שנת 1301
        # כל זה נכון רק במקרה שהשנה גדולה משנת 300 אבל אם היא קטנה משנת 200 והחודש קטן ממרץ צריך לחשב דילוג ימים כמו של השנה הקודמת
        # לדוגמא: בשנת 100 בחודשים ינואר ופברואר יש לחשב הפרש ימים כמו של שנת 99
        for i in range(-10000,10000,100):
            if i == greg_year and greg_year >= zero_difference_year_max and greg_month >= 3:
                greg_year += 1 
            elif i == greg_year and greg_year <= zero_difference_year_min and greg_month < 3:
                greg_year -= 1

        # הגדרת הבדל הימים שבתחילה שווה לאפס
        difference_days = 0

        # אם השנה העכשווית גדולה מהשנה שיש בה אפס הבדל, לעשות קפיצות של מאה שנה בין שנת אפס הבדל לשנה העכשוית
        # עבור כל קפיצה של מאה לבדוק: אם המאה הזו !לא! מתחלקת לארבע מאות !בלי! שארית אז צריך להגדיל את הבדל הימים ביום אחד
        # שאם לא כן, שנת מאה זו מעוברת גם בלוח הגרגוריאני ולכן לא יוצרת הבדל של יום      
        if greg_year >= zero_difference_year_max:
            for i in range(zero_difference_year_max,greg_year,100):
                  if i % 400 != 0:
                    difference_days += 1
            return f"-{difference_days}" if difference_days != 0 else 0

        elif greg_year <= zero_difference_year_min:
            for i in range(zero_difference_year_min,greg_year,-100):
                  if i % 400 != 0:
                    difference_days += 1
            return f"+{difference_days}" if difference_days != 0 else 0
        
        # זה אם השנה היא בין שנת 200 לשנת 300 שיש אפס הבדל 
        else:
            return 0

    #------------------------


    # פונקצייה להמרה מתאריך עברי ללועזי
    def heb_to_greg():

        # הניסיון הוא בגלל שייתכן שהמשתמש הזין תאריך עברי שלא קיים
        try:
            # המרת התאריך שהוזן, למספרים וחלוקה למשתנים נפרדים עבור יום חודש אלפים ושנה
            heb_day = gy.to_number(Entry_heb_day.get())

            heb_month = heb_month_name_to_number(Entry_heb_month.get())

            # דרך ישנה אך חשובה, לעשות זאת באמצעות ספליט על הגרש של האלפים
            heb_year = Entry_heb_year.get().replace(' ','').replace("׳","'")

            if "'" in heb_year:
                split_heb_year = heb_year.split("'")
                heb_year = (gy.to_number(split_heb_year[0]) * 1000) + gy.to_number(split_heb_year[1])
            else:
                if len(heb_year) > 0:
                    heb_year = gy.to_number(heb_year)

            # הגדרת תאריך לידה עברי בפורמט פיי-לוח   
            birth_heb = dates.HebrewDate(heb_year, heb_month, heb_day)

            # הגדרת תאריך לידה לועזי שמקביל לתאריך העברי
            birth_greg = birth_heb.to_greg()

            # הגדרת הפרש הימים בין הלוח היוליאני ללוח הגרגוריאני
            Julian_Gregorian_day_difference.set(calculate_gregorian_julian_difference_days(birth_greg.year,birth_greg.month))

            # הגדרה איזה סוג תאריך לועזי
            Entry_julian_or_gregorian.set(reverse("גרגוריאני"))

            # הזנת התאריך !הגרגוריאני! המקביל והיום בשבוע
            Entry_greg_year.set(f'{birth_greg.year :02.0f}')
            Entry_greg_month.set(f'{birth_greg.month :02.0f}')
            Entry_greg_day.set(f'{birth_greg.day :02.0f}')
            Entry_weekday.set(heb_string_day(birth_heb.weekday()))
            
            # הדפסת יום יוליאני של תאריך גרגוריאני. זה נכון גם עבור התאריך היוליאני כי זה אותו יום
            Entry_JD.set(birth_greg.jd)
            
            ########################################
            # כרגע אין צורך בזה כי כרגע פיי-לוח מחשב נכון את היום היוליאני
            # חישוב יום יוליאני של התאריך בלוח השנה הגרגוריאני שהזין המשתמש באמצעות ספרייה ייעודית
            # חייבים לתקן את מספר השנה הלועזית עבור שנים מאפס ומטה כי ספריית החישובים ליום יוליאני הולכת לפי השיטה של האסטרונומים שסופרים את שנת אפס ואילו ספריית פיילוח וגם אני משתמשים בשיטה של ההיסטוריונים שאין בה שנה אפס
            #year_for_jdcal=birth_greg.year if birth_greg.year >0 else birth_greg.year + 1
            #JDa,JDb = jdcal.gcal2jd(year_for_jdcal,birth_greg.month,birth_greg.day)
            #  הדפסת יום יוליאני של תאריך גרגוריאני
            #Entry_JD.set(JDa+JDb)
            ########################################

            # אם המשתמש מבקש תאריך יוליאני או שהוא מבקש תאריך מתחלף יוליאני-גרגוריאני והתאריך הוא לפני יום המעבר ללוח הגרגוריאני
            if (int(Radiobutton_julian_or_gregorian.get()) == 2) or (int(Radiobutton_julian_or_gregorian.get()) == 3 and birth_greg < dates.GregorianDate(1582,10,15)):

                # חישוב יום יוליאני של התאריך בלוח השנה הגרגוריאני שהזין המשתמש והמרתו לתאריך בלוח השנה היולאני באמצעות ספרייה ייעודית
                # חייבים לתקן את מספר השנה הלועזית עבור שנים מאפס ומטה כי ספריית החישובים ליום יוליאני הולכת לפי השיטה של האסטרונומים שסופרים את שנת אפס ואילו ספריית פיילוח וגם אני משתמשים בשיטה של ההיסטוריונים שאין בה שנה אפס
                get_Entry_greg_year = int(Entry_greg_year.get())
                year_for_jdcal = get_Entry_greg_year if get_Entry_greg_year >0 else get_Entry_greg_year + 1
                JDa,JDb = jdcal.gcal2jd(year_for_jdcal,int(Entry_greg_month.get()),int(Entry_greg_day.get()))
                julian_year_month_day = jdcal.jd2jcal(JDa,JDb)

                Entry_julian_or_gregorian.set(reverse("יוליאני"))
                
                # חייבים לתקן את מספר השנה הלועזית עבור שנים מאפס ומטה כי ספריית החישובים ליום יוליאני הולכת לפי השיטה של האסטרונומים שסופרים את שנת אפס ואילו ספריית פיילוח וגם אני משתמשים בשיטה של ההיסטוריונים שאין בה שנה אפס
                get_jdcal_julian_year = julian_year_month_day[0]
                year_for_cu = get_jdcal_julian_year if get_jdcal_julian_year >0 else get_jdcal_julian_year - 1

                # הזנת התאריך ה!יוליאני! המקביל והיום בשבוע
                Entry_greg_year.set(f'{year_for_cu :02.0f}')
                Entry_greg_month.set(f'{julian_year_month_day[1] :02.0f}')
                Entry_greg_day.set(f'{julian_year_month_day[2] :02.0f}')
                Entry_weekday.set(heb_string_day(birth_heb.weekday()))
                
                #  הדפסת יום יוליאני של תאריך יוליאני
                #Entry_JD.set(JDa+JDb)

            # החזרת שורת הרווח להיות רווח במקום הודעת שגיאה שייתכן שמוצגת שם
            heb_eror.config(text="", font= "david 18 bold") # פונט ברירת מחדל "Segoe 9"
            greg_eror.config(text="", font= "david 18 bold") # פונט ברירת מחדל "Segoe 9"

            # בדיקה האם השנה שהמשתמש הזין היא פשוטה או מעוברת
            _,_, meuberet_year = chishuv_shana_bemachzor_19(heb_year)
            
            # טיפול במקרה שאדם מזין אדר-א או אדר-ב אבל השנה אינה מעוברת או שהוא מזין אדר רגיל אבל השנה מעוברת
            if Entry_heb_month.get() in ["אדר-א", "אדר-ב"] and not meuberet_year or Entry_heb_month.get() == "אדר" and meuberet_year:
                Entry_greg_day.set("")
                Entry_greg_month.set("")
                Entry_greg_year.set("")
                Entry_julian_or_gregorian.set("")
                Entry_weekday.set("")
                Entry_JD.set("")
                Julian_Gregorian_day_difference.set("")
                heb_eror.config(text=reverse("!!!תאריך עברי שאינו קיים: נסה שנית!!!"),font="david 18 bold")

        # במקרה שהמשתמש הזין תאריך עברי שאינו קיים מוחקים את מה שיש בתאריך הלועזי ומודיעים שגיאה
        except: # ValueError ++
            Entry_greg_day.set("")
            Entry_greg_month.set("")
            Entry_greg_year.set("")
            Entry_julian_or_gregorian.set("")
            Entry_weekday.set("")
            Entry_JD.set("")
            Julian_Gregorian_day_difference.set("")
            heb_eror.config(text=reverse("!!!תאריך עברי שאינו קיים: נסה שנית!!!"),font="david 18 bold")

    # פונקצייה להמרה מתאריך לועזי לעברי              
    def greg_to_heb():
        # הניסיון הוא בגלל שייתכן שהמשתמש הזין תאריך לועזי שלא קיים
        try:         
            # הגדרת תאריך לועזי ראשוני !גרגוריאני! בפורמט פיי-לוח   
            birth_greg = dates.GregorianDate(int(Entry_greg_year.get()), int(Entry_greg_month.get()), int(Entry_greg_day.get()))
            
            # הגדרת הפרש הימים בין הלוח היוליאני ללוח הגרגוריאני
            Julian_Gregorian_day_difference.set(calculate_gregorian_julian_difference_days(birth_greg.year,birth_greg.month))

            # הגדרה האם מדובר בתאריך יוליאני או גרגוריאני
            Entry_julian_or_gregorian.set(reverse("גרגוריאני"))
            
            # הדפסת יום יוליאני של תאריך גרגוריאני. זה נכון גם עבור התאריך היוליאני כי זה אותו יום
            Entry_JD.set(birth_greg.jd)
            
            ########################################
            # כרגע אין צורך בזה כי כרגע פיי-לוח מחשב נכון את היום היוליאני
            # חישוב יום יוליאני של התאריך בלוח השנה הגרגוריאני שהזין המשתמש באמצעות ספרייה ייעודית
            # חייבים לתקן את מספר השנה הלועזית עבור שנים מאפס ומטה כי ספריית החישובים ליום יוליאני הולכת לפי השיטה של האסטרונומים שסופרים את שנת אפס ואילו ספריית פיילוח וגם אני משתמשים בשיטה של ההיסטוריונים שאין בה שנה אפס
            #year_for_jdcal = birth_greg.year if birth_greg.year >0 else birth_greg.year + 1
            #JDa,JDb = jdcal.gcal2jd(year_for_jdcal,birth_greg.month,birth_greg.day)
            #  הדפסת יום יוליאני של תאריך גרגוריאני
            #Entry_JD.set(JDa+JDb)
            ########################################

            # אם המשתמש מבקש להזין תאריך יוליאני או שהוא מבקש להזין תאריך מתחלף יוליאני-גרגוריאני והתאריך הוא לפני יום המעבר ללוח הגרגוריאני
            if (int(Radiobutton_julian_or_gregorian.get()) == 2) or (int(Radiobutton_julian_or_gregorian.get()) == 3 and birth_greg < dates.GregorianDate(1582,10,15)):

                # חישוב יום יוליאני של התאריך בלוח השנה היוליאני שהזין המשתמש והמרתו לתאריך גרגוריאני באמצעות ספרייה ייעודית
                # חייבים לתקן את מספר השנה הלועזית עבור שנים מאפס ומטה כי ספריית החישובים ליום יוליאני הולכת לפי השיטה של האסטרונומים שסופרים את שנת אפס ואילו ספריית פיילוח וגם אני משתמשים בשיטה של ההיסטוריונים שאין בה שנה אפס
                get_Entry_greg_year = int(Entry_greg_year.get())
                year_for_jdcal = get_Entry_greg_year if get_Entry_greg_year >0 else get_Entry_greg_year + 1
                JDa,JDb = jdcal.jcal2jd(year_for_jdcal,int(Entry_greg_month.get()),int(Entry_greg_day.get()))
                greg_year_month_day = jdcal.jd2gcal(JDa,JDb)

                # המרה של התאריך הגרגוריאני לתאריך גרגוריאני של פיי-לוח
                # חייבים לתקן את מספר השנה הלועזית עבור שנים מאפס ומטה כי ספריית החישובים ליום יוליאני הולכת לפי השיטה של האסטרונומים שסופרים את שנת אפס ואילו ספריית פיילוח וגם אני משתמשים בשיטה של ההיסטוריונים שאין בה שנה אפס
                get_jdcal_greg_year = greg_year_month_day[0]
                year_for_pyluach = get_jdcal_greg_year if get_jdcal_greg_year >0 else get_jdcal_greg_year - 1
                birth_greg = dates.GregorianDate(year_for_pyluach,greg_year_month_day[1],greg_year_month_day[2])

                # הגדרה האם מדובר בתאריך יוליאני או גרגוריאני
                Entry_julian_or_gregorian.set(reverse("יוליאני"))
                
                #  הדפסת יום יוליאני של תאריך יוליאני
                #Entry_JD.set(JDa+JDb)

            # בכל מקרה, כעת יש בידינו תאריך גרגוריאני בפורמט פיי-לוח. כעת נגדיר תאריך עברי שמקביל לתאריך הגרגוריאני
            birth_heb = birth_greg.to_heb()

            # אולי זה באג של פיי-לוח!!! אבל צריך תיקון עבור שנה שנמצאת במינוסים: לא יודע למה צריך להוריד יום אחד אבל ככה זה עובד במינוסים!!! 
            if birth_greg.year <= 0:
                birth_heb -= 1 

            # הזנת התאריך העברי המקביל והיום בשבוע
            Entry_heb_day.set(gematria._num_to_str(birth_heb.day, thousands=False, withgershayim=False))
            Entry_heb_month.set(birth_heb.month_name(True))
            Entry_heb_year.set(gematria._num_to_str(birth_heb.year, thousands=True, withgershayim=True))
            Entry_weekday.set(heb_string_day(birth_heb.weekday()))

            # החזרת שורת הרווח להיות רווח רגיל במקום הודעת שגיאה שייתכן שמוצגת שם
            greg_eror.config(text="", font= "david 18 bold") # פונט ברירת מחדל "Segoe 9"
            heb_eror.config(text="", font= "david 18 bold") # פונט ברירת מחדל "Segoe 9"

            # טיפול במקרה שהמשתמש מבקש תאריך מתחלף יוליאני גרגוריאני אבל הוא מזין תאריך מתוך תאריכי הדילוג בין הלוח היוליאני ללוח הגרגוריאני
            if int(Radiobutton_julian_or_gregorian.get()) == 3 and birth_greg > dates.GregorianDate(1582,10,4) and birth_greg < dates.GregorianDate(1582,10,15):
                Entry_heb_day.set("")
                Entry_heb_month.set("")
                Entry_heb_year.set("")
                Entry_weekday.set("")
                Entry_julian_or_gregorian.set("")
                Entry_JD.set("")
                Julian_Gregorian_day_difference.set("")
                greg_eror.config(text=reverse("!תאריך לא קיים עקב דילוג ללוח הגרגוריאני!"),font="david 18 bold")

        # במקרה שהמשתמש הזין תאריך לועזי שאינו קיים מוחקים את מה שיש בתאריך העברי ומודיעים שגיאה      
        except ValueError:
            Entry_heb_day.set("")
            Entry_heb_month.set("")
            Entry_heb_year.set("")
            Entry_weekday.set("")
            Entry_JD.set("")
            Julian_Gregorian_day_difference.set("")
            # הכנסת הודעת השגיאה בשורת הרווח שיש מתחת התאריך הלועזי
            greg_eror.config(text=reverse("!!!תאריך לועזי שאינו קיים: נסה שנית!!!"), font="david 18 bold")


    # פונקצייה להגדרת התאריך הנוכחי בכניסה לתוכנה    
    def set_date_time_now():

        # תאריך לועזי של היום לפי המחשב
        now = datetime.now()

        # המרה לתאריך עברי
        heb_date = dates.GregorianDate(1880, 10, 20).from_pydate(now).to_heb()

        #Entry_greg_year.set(f'{now.year :02.0f}')
        #Entry_greg_month.set(f'{now.month :02.0f}')
        #Entry_greg_day.set(f'{now.day :02.0f}')

        # הזנת התאריך העברי לתוך התיבות
        Entry_heb_year.set(heb_date.hebrew_year(True))
        Entry_heb_month.set(heb_date.month_name(True))
        Entry_heb_day.set(heb_date.hebrew_day(False))
        Entry_weekday.set(heb_string_day(heb_date.weekday()))
        #Entry_julian_or_gregorian.set("גרגוריאני")

        # המרת התאריך העברי לתאריך לועזי מתאים באמצעות פונקצייה
        heb_to_greg()

    
    # מכאן והלאה עיצוב גרפי של ממשק המשתמש
    
    if __name__ == '__main__':
        
        # אזור נפרד להזנת תאריך
        converter = Toplevel(ws) # Tk()
        converter.minsize(450,630)
        converter.geometry(f"{round(450*magnification_factor)}x{round(630*magnification_factor)}+{round(320*magnification_factor)}+{round(1*magnification_factor)}")
        converter.title(reverse(f'ממיר תאריכים עברי-לועזי-עברי | גרסה:  {dt.date(2024,11,4):%d/%m/%Y}', for_title = True))
        # אם רוצים לעשות שהחלון הזה יהיה מעל כל החלונות שבמחשב. זה חשוב בעיקר כאשר רזולוציית המסך מוגדלת
        #converter.attributes('-topmost',True)
        # הגדרת צבע לכל החלון
        converter.configure(bg=cu_color)
        
        # פונקצייה לסגירת החלון לאחר רישום במשתנה שהחלון נסגר 
        def converter_close():
            global subprocess_patuach
            subprocess_patuach -= 1
            converter.destroy()
        
        # בסגירת החלון ייתבצעו הפעולות שבפונקצייה
        converter.protocol("WM_DELETE_WINDOW", converter_close)

        

        # הגדרת משתנה ששומר הגדרות כלליות לפונט שיהיה בשימוש
        font_buttons = tkinter.font.Font(converter, family='narkisim', size=12, weight='bold')
        font_ = tkinter.font.Font(converter, family='david', size=12)

        Label(converter, text="", font="david 6").pack()


        #else:
        # תאריך עברי----------------------------------------------

        # אזור נפרד להזנת תאריך עברי ושעה
        heb_date = cu_PanedWindow(converter)


        # כותרת
        Label(heb_date, text=reverse("תאריך עברי (לוח-קבוע)"), font="david 18 bold").grid(column=0, row=0, columnspan=3)


        # יצירת רצף של שנים עבריות במערך עבור בחירת שנים עבריות
        a = range(1,7000)
        heb_years = []
        for i in range(len(a)):
            heb_years.append(gematria._num_to_str(a[i], thousands=True, withgershayim=True))

        # בחירה בין רשימת שנים עבריות
        Entry_heb_year = StringVar(converter)
        heb_year_cb = ttk.Combobox(heb_date, textvariable=Entry_heb_year, width=9, state=state1,values=[*heb_years],font="narkisim 16",justify='center',)
        heb_year_cb.grid(column=0, row=1)
        Label(heb_date, text=reverse("שנה")).grid(column=0, row=2)

        Entry_heb_month = StringVar(converter)
        '''
        heb_month_range = CUֹ_HEB_MONTH_NAMES
        heb_month = ttk.Combobox(heb_date, textvariable=Entry_heb_month, width=8, state=state1,values=[*heb_month_range],font="narkisim 16",justify='center')
        heb_month.grid(column=1, row=1)
        # כאשר קומבובוקס של שנה עברית משתנה, יש לקרוא לפונקציית עדכון השנה הלועזית המתאימה    
        heb_month.bind('<<ComboboxSelected>>', lambda event: heb_to_greg())
        '''
        Spinbox(
            heb_date,
            textvariable=Entry_heb_month,
            value=CUֹ_HEB_MONTH_NAMES,
            wrap=True,
            state = 'readonly',
            width=8,
            command=heb_to_greg,
            font="narkisim 17",
            readonlybackground = "white",
            justify='center'
        ).grid(column=1, row=1)
        
        Label(heb_date, text=reverse("חודש")).grid(column=1, row=2)

        # הכנת מערך עם שלושים ימים עבריים עבור ימי החודש
        b = range(1,31)
        heb_month_days = []
        for i in range(len(b)):
            heb_month_days.append(gematria._num_to_str(b[i], thousands=False, withgershayim=False))


        Entry_heb_day = StringVar(converter)
        Spinbox(
            heb_date,
            textvariable=Entry_heb_day,
            #value=['א','ב','ג','ד','ה','ו','ז','ח','ט','י','יא','יב','יג','יד','טו','טז','יז','יח','יט','כ','כא','כב','כג','כד','כה','כו','כז','כח','כט','ל'],
            value= [*heb_month_days],
            wrap=True,
            state = 'readonly',
            readonlybackground = "white",
            width=3,
            command=heb_to_greg,
            font="narkisim 17", 
            justify='center'
        ).grid(column=2, row=1)
        Label(heb_date, text=reverse("יום")).grid(column=2, row=2)

        heb_date.pack()

        # הגדרת שורה רווח לאחר התאריך העברי, ובשורה זו ייכתב במידה שיש שגיאה בתאריך שהזין המשתמש
        # יש להקפיד שנקודה פיק יהיה בשורה נפרדת שאם לא כן אי אפשר להגדיר את השורה ממקום אחר
        heb_eror = Label(converter, text="")
        heb_eror.pack()


        Label(converter, text=reverse("תאריך לועזי"), font="david 18 bold").pack()

        Rd_PW = cu_PanedWindow(converter)

        # פונקציית פקודה לביצוע בלחיצה על כפתורי הרדיו
        def command_for_Radiobutton():
            try:
                heb_to_greg()
            except UnboundLocalError:
                greg_to_heb()

        Radiobutton_julian_or_gregorian = IntVar(converter)
        R1 = Radiobutton(Rd_PW, text=reverse("גרגוריאני"), variable=Radiobutton_julian_or_gregorian, value=1, command = command_for_Radiobutton).grid(column=1, row=1)
        R2 = Radiobutton(Rd_PW, text=reverse("יוליאני"), variable=Radiobutton_julian_or_gregorian, value=2, command = command_for_Radiobutton).grid(column=2, row=1)
        R3 = Radiobutton(Rd_PW, text=reverse("מתחלף באוקטובר 1582"), variable=Radiobutton_julian_or_gregorian, value=3, command = command_for_Radiobutton).grid(column=3, row=1)

        Rd_PW.pack()

        # אזור נפרד להזנת תאריך לועזי ושעה
        greg_date = cu_PanedWindow(converter)

        # תאריך לועזי-----------------

        # כותרת
        #Label(greg_date, text="תאריך לועזי", font="david 18 bold").grid(column=0, row=0, columnspan=5)

        # יצירת רצף של שנים לועזיות במערך עבור בחירת שנים עבריות
        greg_years = [i for i in range(-3761,3238)]
        # הסרת הספרה אפס כי אין שנה אפס
        greg_years.remove(0)

        Entry_greg_year = StringVar(converter)
        greg_year_cb = ttk.Combobox(greg_date, textvariable=Entry_greg_year, width=5, state=state1,values=[*greg_years],font="narkisim 16",justify='center',)
        greg_year_cb.grid(column=4, row=1)

        Label(greg_date, text=reverse("שנה")).grid(column=4, row=2)

        Entry_greg_month = StringVar(converter)
        Spinbox(
            greg_date,
            textvariable=Entry_greg_month,
            from_=1, 
            to=12,
            wrap=True,
            state = 'readonly',
            readonlybackground = "white",
            width=2,
            format_="%02.0f",
            command=greg_to_heb,
            font="narkisim 17",
            justify='center'
        ).grid(column=3, row=1)
        Label(greg_date, text=reverse("חודש")).grid(column=3, row=2)

        Entry_greg_day = StringVar(converter)
        Spinbox(
            greg_date,
            textvariable=Entry_greg_day,
            state = 'readonly',
            readonlybackground = "white",
            from_=1, 
            to=31,
            wrap=True,
            width=2,
            format_="%02.0f",
            command=greg_to_heb,
            font="narkisim 17",
            justify='center'
        ).grid(column=2, row=1)
        Label(greg_date, text=reverse("יום")).grid(column=2, row=2)

        Label(greg_date, text="").grid(column=1, row=1)

        # האם מדובר בתאריך יוליאני או גרגוריאני
        Entry_julian_or_gregorian = StringVar(converter)
        Entry(greg_date, width=9, textvariable=Entry_julian_or_gregorian,justify='center',state = 'readonly', font="narkisim 17").grid(column=0, row=1)
        Label(greg_date, text=reverse("סוג לוח")).grid(column=0, row=2)
        greg_date.pack()


        #-----------------------------------------
        # הגדרת שורה רווח לאחר התאריך הלועזי, ובשורה זו ייכתב במידה שיש שגיאה בתאריך שהזין המשתמש
        # יש להקפיד שנקודה פיק יהיה בשורה נפרדת שאם לא כן אי אפשר להגדיר את השורה ממקום אחר
        greg_eror = Label(converter, text="")
        greg_eror.pack()

        # אזור נפרד ליום בשבוע ולהפרש ימים יוליאני-גרגוריאני
        bonus = cu_PanedWindow(converter)

        Entry_weekday = StringVar(converter)
        Label(bonus, text=reverse("יום בשבוע"), font="david 12 bold").grid(column=2, row=1)
        Entry(bonus, width=10, state='readonly', textvariable=Entry_weekday,justify='center', font="narkisim 17").grid(column=2, row=2)
        
        Julian_Gregorian_day_difference = StringVar(converter)
        Label(bonus, text=reverse("      הפרש הימים בלוח     \n      גרגוריאני➞יוליאני      "), font="david 12 bold", justify='center').grid(column=1, row=1)
        Entry(bonus, width=5, state='readonly', textvariable=Julian_Gregorian_day_difference,justify='center', font="narkisim 17").grid(column=1, row=2)

        Entry_JD = StringVar(converter)
        Label(bonus, text=reverse("JD יום יוליאני"), font="david 12 bold").grid(column=0, row=1)
        Entry(bonus, width=10, state='readonly', textvariable=Entry_JD, justify='center', font="narkisim 17").grid(column=0, row=2)

        bonus.pack()

        Label(converter, text="", font="david 18 bold").pack()

        # אזור נפרד לכפתורים
        input_heb = cu_PanedWindow(converter)

        # כפתור להיום
        Button(input_heb, text=reverse("היום\nלפי המחשב"), font = font_buttons, command=set_date_time_now).grid(column=5, row=1)
        
        Label(input_heb, text="   ", font="david 18 bold").grid(column=2, row=1)
        
        # פונקצייה עבור כפתור העתקת התאריך
        def copy_dates():
            C = f'{Entry_heb_day.get()} {Entry_heb_month.get()} {Entry_heb_year.get()} == {Entry_greg_day.get()}/{Entry_greg_month.get()}/{Entry_greg_year.get()} ({Entry_julian_or_gregorian.get()}) == יום {Entry_weekday.get()}'
            clipboard.copy(C)
        
        # כפתור להעתקת תאריכים
        Button(input_heb,  text=reverse("העתק\nתאריכים"), font = font_buttons, command=copy_dates).grid(column=1, row=1)

        Label(input_heb, text="   ", font="david 18 bold").grid(column=4, row=1)
        
        # פונקצייה להעברת התאריך הלועזי המקביל לתאריך העברי שבממיר תאריכים לתוך החלון הראשי של התוכנה
        def set_hebdate_to_cu_clock():
            
            # ראשית כל עצירת החישובים הרציפים של התוכנה הראשית במידה שהם קיימים כי אחרת אין מה לכוון את השעון העליון
            if choice_time.get() == "עכשיו מתעדכן":
                choice_time.set("עכשיו (לפי המחשב)")
            
            # צריך ניסיון כי אולי המשתמש הזין תאריך עברי שאינו קיים
            try:
                Radiobutton_julian_or_gregorian.set(1) # שיהיה גרגוריאני
                heb_to_greg() # חישוב תאריך לועזי מתוך תאריך עברי
                day = int(Entry_greg_day.get())
                month = int(Entry_greg_month.get())
                year = int(Entry_greg_year.get())
                ssd = datetime(year,month,day,9,0,0,10)
                # הכנסת התאריך לתוך החלון הראשי של התוכנה
                set_date_time(ssd)
            except ValueError:
                    tkMessageBox.showinfo( reverse("שגיאה"), reverse("תאריך לפני שנת 1 לסה''נ או תאריך עברי שאינו קיים, אינם נתמכים"))

        
        # כפתור להעברת התאריך הלועזי המקביל לתאריך העברי לתוך החלון הראשי של התוכנה
        Button(input_heb, text=reverse("המר תאריך עברי ללועזי\nלתוך התוכנה הראשית"), font = font_buttons, command=set_hebdate_to_cu_clock).grid(column=3, row=1)

        input_heb.pack()


        # כפתור לסימון לאחר השקיעה - בוטל
        #C1_before_24 = IntVar(converter)
        #Checkbutton(converter, text = "לצורך המרת תאריכים מדוייקת \nסמנו אם המאורע התרחש בין תחילת הלילה לשעה 24:00", variable = C1_before_24, onvalue = 1, offvalue = 0, height=1, font = "david 12 bold",command = greg_to_heb).pack()
        Label(converter, text="", font="david 12 bold").pack()
        Label(converter, text=reverse("שימו לב! בכל יום, מתחילת הלילה ועד לשעה 24:00"), font="david 12 bold").pack()
        Label(converter, text=reverse("התאריך העברי מאוחר ביום אחד מהתאריך הלועזי"), font="david 12 bold").pack()
        Label(converter, text=reverse("\nשימו לב! תחילת שימוש בלוחות קבועים (שנים לספירה הנוצרית)"), font="david 12 bold").pack()
        Label(converter, text=reverse("יוליאני: 45-, עברי: בערך 360, גרגוריאני: 1582"), font="david 12 bold").pack()
        Label(converter, text=reverse("\nשימו לב! בתוכנה זו אין שנה לועזית אפס, כשיטה המקובלת בהיסטוריה"), font="david 12 bold").pack()
        Label(converter, text=reverse("אך יום יוליאני הוא כשיטה המקובלת באסטרונומיה, שקיימת שנה אפס"), font="david 12 bold").pack()
        Label(converter, text=reverse("לכן בשנות מינוס יש פער של שנה בין היום היוליאני לבין התאריך הלועזי"), font="david 12 bold").pack()
        #Label(converter, text="\nשימו לב! תאריכים לועזיים בשנות מינוס עלולים ללקות בחוסר דיוק", font="david 12 bold").pack()


        # כותרת
        Label(converter, text="", font="david 18 bold").pack()


        # כאשר קומבובוקס של שנה לועזית משתנה, יש לקרוא לפונקציית עדכון השנה העברית המתאימה    
        greg_year_cb.bind('<<ComboboxSelected>>', lambda event: greg_to_heb())

        # כאשר קומבובוקס של שנה עברית משתנה, יש לקרוא לפונקציית עדכון השנה הלועזית המתאימה    
        heb_year_cb.bind('<<ComboboxSelected>>', lambda event: heb_to_greg())

        # דברים לעשות מייד בכניסה לתוכנה
        # לוח לועזי מתחלף בשנת 1582
        Radiobutton_julian_or_gregorian.set(3)
        # הפעלת התאריך של היום בכניסה לתוכנה
        converter.after(1, set_date_time_now)

        # הגדרת לולאה אינסופית שמפעילה את חלון טקטינר שיצרנו
        #converter.mainloop()

####################################################################################################################
####################################################################################################################
####################################################################################################################
####################################################################################################################
                                      # עד כאן עבור התוכנות הנלוות
####################################################################################################################
####################################################################################################################
####################################################################################################################
####################################################################################################################

# חיפוש אינדקס של "ירושלים" או החזרת 0 אם לא נמצא
jerusalem_index = 0#([i for i, loc in enumerate(locations) if loc["heb_name"] == "ירושלים"] or [0])[0]

# -----------------------------
# הגדרות ברירת מחדל
# -----------------------------
settings_dict = {
    "rise_set_deg": -0.833,
    "mga_deg": -16,
    "hacochavim_deg": -4.61,
    "misheiacir_deg": -10.5,
    "hesberim_mode": "hesberim",
    "zmanim_mode": "zmanim_with_clocks",
    "default_location_index": jerusalem_index,
    "is_language_hebrew": None,
    "is_zoomed_screen": False,
    "start_halacha_clock": False,
    "halacha_clock_labels": True
}

default_settings_dict = dict(settings_dict)


# -----------------------------
# טעינת הגדרות מקובץ
# -----------------------------
def load_settings_dict_from_file():
    global settings_dict, settings_path
    try:
        with open(settings_path, "r", encoding="utf-8") as f:
            loaded_settings = json.load(f)

        # עדכון ההגדרות עם הערכים מהקובץ, בלי המרה מיותרת
        for key, val in loaded_settings.items():
            settings_dict[key] = val
        print(settings_dict)
        print("הגדרות נטענו בהצלחה מתוך הקובץ")
    except FileNotFoundError:
        print("קובץ ההגדרות לא נמצא, נשמרות ההגדרות ברירת המחדל")
        settings_dict.update(default_settings_dict)
    except Exception as e:
        print(f"שגיאה בטעינת הקובץ: {e}")
        settings_dict.update(default_settings_dict)

# -----------------------------
# שמירת הגדרה בודדת
# -----------------------------
def save_setting(key, value):
    global settings_dict, settings_path
    settings_dict[key] = value
    with open(settings_path, "w", encoding="utf-8") as f:
        json.dump(settings_dict, f, ensure_ascii=False, indent=2)

# -----------------------------
# שחזור ברירת מחדל
# -----------------------------
def to_default_settings():
    global settings_dict
    settings_dict.update(default_settings_dict)
    with open(settings_path, "w", encoding="utf-8") as f:
        json.dump(settings_dict, f, ensure_ascii=False, indent=2)
    tkMessageBox.showinfo(reverse("שיחזור הגדרות"), reverse("הגדרות ברירת מחדל שוחזרו בהצלחה!"))
    #ws.destroy()
    restart_app()

# -----------------------------
# עריכת הגדרות
# -----------------------------
# -----------------------------
# עריכת הגדרות
# -----------------------------
def edit_settings():
    global is_heb_locale, settings_dict, settings_path

    # -----------------------------
    # מילון ערכים להצגה בלבד
    # -----------------------------
    value_labels = {
        True: "כן" if is_heb_locale else "yes",
        False: "לא" if is_heb_locale else "no",
        None: "ברירת מחדל" if is_heb_locale else "default"
    }

    # -----------------------------
    # שמות בעברית (עם reverse להצגה בלבד)
    # -----------------------------
    names_hebrew = {
        "rise_set_deg": reverse("° שיטת זריחה ושקיעה"),
        "mga_deg": reverse("° שיטת מגא ועלות"),
        "hacochavim_deg": reverse("° שיטת צאת הכוכבים"),
        "misheiacir_deg": reverse("° שיטת משיכיר"),
        "hesberim_mode": reverse("מצב תצוגה"),
        "zmanim_mode": reverse("מצב זמנים"),
        "is_language_hebrew": reverse("התוכנה תוצג בעברית"),
        "is_zoomed_screen": reverse("מסך מוגדל"),
        "start_halacha_clock": reverse("הפעלת שעון ההלכה בכניסה לתוכנה"),
        "halacha_clock_labels": reverse("תוויות הסבר בשעון ההלכה"),
    }

    # -----------------------------
    # מצבי הצגה בעברית
    # -----------------------------
    modes_hebrew = {
        "hesberim": reverse("הסברים"),
        "zmanim": reverse("זמנים"),
        "clocks": reverse("שעונים"),
        "zmanim_with_clocks": reverse("זמנים עם שעונים"),
    }

    # מיפוי הפוך: ערך עברי -> ערך פנימי
    reverse_modes = {v: k for k, v in modes_hebrew.items()}

    # -----------------------------
    edit_win = Toplevel(ws)
    edit_win.title("עריכת הגדרות" if is_heb_locale else "Edit Settings")
    Label(edit_win,text=reverse("עריכת הגדרות ושיטות זמנים") if is_heb_locale else "Edit Settings and Time Methods",font=("Arial", 12, "bold")).pack()
    Label(edit_win,text=reverse("הערכים המוצגים הם הערכים הנוכחיים") if is_heb_locale else "The displayed values are the current settings",font=("Arial", 10)).pack()

    options_to_edit = {
        "rise_set_deg": [0, -0.833],
        "mga_deg": [-16, -19.75, 222],
        "hacochavim_deg": [-4.61, -3.61, -6, -8.5],
        "misheiacir_deg": [-10.5, -10],
        "hesberim_mode": ["hesberim"],
        "zmanim_mode": ["zmanim", "clocks", "zmanim_with_clocks"],
        "default_location_index": [0],
        "is_language_hebrew": [None, True, False],
        "is_zoomed_screen": [True, False],
        "start_halacha_clock": [True, False],
        "halacha_clock_labels": [True, False],
    }

    entries = {}

    # -----------------------------
    def save_changes():
        new_settings = {}
        for key, combo in entries.items():
            # קבל את האינדקס שנבחר ב-ComboBox
            selected_index = combo.current()

            if key in ["hesberim_mode", "zmanim_mode"]:
                # שמירה של הערך הפנימי לפי האינדקס
                val = options_to_edit[key][selected_index]
            elif key in ["is_language_hebrew", "is_zoomed_screen", "start_halacha_clock", "halacha_clock_labels"]:
                val = options_to_edit[key][selected_index]
            elif key in ["rise_set_deg", "mga_deg", "hacochavim_deg", "misheiacir_deg", "default_location_index"]:
                val_str = combo.get()
                try:
                    val = float(val_str)
                except (ValueError, TypeError):
                    val = val_str
            else:
                val = combo.get()

            new_settings[key] = val

        settings_dict.update(new_settings)
        with open(settings_path, "w", encoding="utf-8") as f:
            json.dump(settings_dict, f, ensure_ascii=False, indent=2)

        tkMessageBox.showinfo(
            reverse("נשמר") if is_heb_locale else "Saved",
            reverse("ההגדרות נשמרו בהצלחה!") if is_heb_locale else "Settings were saved successfully!"
        )
        edit_win.destroy()
        restart_app()

    # -----------------------------
    for key, val in settings_dict.items():
        if key not in options_to_edit:
            continue

        frame = ttk.Frame(edit_win)
        frame.pack(fill="x", padx=10, pady=5)
        display_name = names_hebrew.get(key, key) if is_heb_locale else key
        ttk.Label(frame, text=display_name, width=25).pack(side="right")

        # בניית רשימת הערכים להצגה
        if key in ["is_language_hebrew", "is_zoomed_screen", "start_halacha_clock", "halacha_clock_labels"]:
            display_values = [reverse(value_labels[v]) for v in options_to_edit[key]]
            display_val = reverse(value_labels.get(val, val))
        elif key in ["hesberim_mode", "zmanim_mode"]:
            if is_heb_locale:
                display_values = [modes_hebrew[v] for v in options_to_edit[key]]
                display_val = modes_hebrew.get(val, display_values[0])
            else:
                display_values = options_to_edit[key]
                display_val = val if val in display_values else display_values[0]
        else:
            display_values = options_to_edit[key]
            display_val = val if val in display_values else display_values[0] if display_values else ""

        combo = ttk.Combobox(frame, values=display_values, state="readonly")
        combo.set(display_val)
        combo.pack(side="right", padx=5)
        entries[key] = combo

    Button(edit_win, text=reverse("שמור הגדרות") if is_heb_locale else "Save settings", command=save_changes).pack(pady=20)

#####################################################################################################
# עד כאן איזור הגדרות התוכנה
#####################################################################################################


# תחילת הממשק הגרפי של התוכנה הראשית כוכבים וזמנים
if __name__ == '__main__':
            
    # קבלת הגדרות ברירות מחדל עבור התוכנה באמצעות פונקצייה
    eph, eph_440, eph_441s, state1, input_years_range, locations_path, locations_edited_path, stars_path, settings_path, cu_dir_path,is_installed = get_defaults()
    
    load_settings_dict_from_file() # טעינת ההגדרות פעם אחת בתחילת הקוד
    
    # ניסיון קבלת כל המיקומים ושמותיהם באמצעות פונקצייה מתוך קובץ המיקומים הערוך ואם יש שגיאה בקובץ הערוך אז לקבל מיקומים מתוך קובץ המיקומים המקורי
    # הערה: במקרה שיש שגיאה בקובץ המיקומים הערוך המשתמש יצטרך לאפס אותו כדי להתחיל להשתמש בו או אפילו כדי לבחור מיקום ברירת מחדל
    # השגיאות שיכולות להיות בקובץ המיקומים הערוך: 1. הוא ריק. 2. יש בו ערכים שגויים 3. הוא כתוב בקידוד אחר מאשר 1255
    try:
        # קבלת כל המיקומים ושמותיהם באמצעות פונקצייה
        locations = get_locations(locations_path,locations_edited_path,cu_dir_path)
        
        # אם אין מיקומים ברשימת המיקומים זה בגלל שיש בעיה בקובץ המיקומים הערוך ואז יש להעלות שגיאה מותאמת אישית
        if len(locations) == 0:
            raise IndexError("Error getting the locations from the edited file")
    
    # במקרה שיש שגיאה כלשהיא בקבלת המיקומים מקובץ המיקומים הערוך יש לקחת את המיקומים מהקובץ המקורי
    # בכוונה לא פירטתי איזו שגיאה, כי כל שגיאה בקבלת המיקומים מהקובץ הערוך צריכה לגרום לקבלת המיקומים מהקובץ המקורי
    except:
        locations_path = resource_path('cu_locations.csv')
        locations = get_locations(locations_path,locations_edited_path,cu_dir_path)
        # שמירת המידע שנעשה שימוש בקובץ המיקומים המקורי ולא בקובץ הערוך
        which_locations_file = "מקורי"
        
        
    # קבלת נתוני כוכבי שבת מקובץ סי אס וי באמצעות פונקצייה שהגדרתי למעלה
    stars = get_stars(stars_path,cu_dir_path)
    
    
    #-------------------
    
    # הגדרת החלון הראשי של התוכנה
    ws = Tk()
    # רזולוציית המסך שבשימוש כרגע
    screenwidth = screeninfo.get_monitors()[0].width
    screenheight = screeninfo.get_monitors()[0].height
    #print(f"Screen Resolution: {screenwidth}x{screenheight}")
    # קביעת מקדם ההגדלה או ההקטנה שהוא היחס באחוזים בין רזולוציית המסך הנוכחית לבין רזולוציית המסך שבו נבנתה התוכנה. כרגע מוגדר לפי גובה המסך
    # כי הגובה של התוכנה תופס כמעט את כל גובה המסך ולכן הוא הכי משמעותי בתוכנה זו
    #magnification_factor = screenheight / cu_screenheight
    magnification_factor = min(screenwidth / cu_screenwidth, screenheight / cu_screenheight) ############################### ניסיון חדש
    # אולי אפשר לעשות ממוצע של הרזולוציה באמצעות אורך ורוחב אבל ספק אם זה יותר טוב
    # average_ratio = (ws.winfo_screenwidth() + ws.winfo_screenheight()) / 2
    if is_windows:
        # הגדרה שה- די פי איי יתאים גם כשרזולוציית המסך מוגדלת (במקום טרו, אפשר גם להגדיר 1 או 2) זה גורם שהמחשב יתעלם משינוי קנה מידה של אפליקציות
        ctypes.windll.shcore.SetProcessDpiAwareness(2)
        ######################################################################################
        # בוטל כרגע ומופעל באמצעות לחיצה מדומה על המקלדת עבור מסך שעון ההלכה בלבד כדי שלא ייכבה
        # מונע מצב שינה וכיבוי מסך
        #ES_CONTINUOUS = 0x80000000
        #ES_DISPLAY_REQUIRED = 0x00000002
        #ctypes.windll.kernel32.SetThreadExecutionState(ES_CONTINUOUS | ES_DISPLAY_REQUIRED)
        ######################################################################################
    
    
    # שינוי קנה המידה של התצוגה במקרה שהרזולוציה של המסך גדולה יותר
    ws.tk.call('tk', 'scaling', cu_scaling*magnification_factor) # סקאלינג לא עובד בלינוקס
    
    
    # הגדרת גודל החלון ומיקומו על המסך
    ws.geometry(f"{round(685*magnification_factor)}x{round(685*magnification_factor)}+{round(0*magnification_factor)}+{round(1*magnification_factor)}")
    #print(magnification_factor)
    # הגדרת גודל מינימלי
    ws.minsize(200,200)
    # אם רוצים למלאות את המסך כל מסך לפי הרזולוצייה שלו יש לפעול לפי השורה הבאה
    #ws.geometry(f'{ws.winfo_screenwidth()}x{ws.winfo_screenheight()}+1+1')
    
    if settings_dict["is_zoomed_screen"]:
        if is_windows:
            ws.state('zoomed')
        else:
            ws.update_idletasks()
            ws.attributes('-zoomed', True) # מתאים ללינוקס

    
    # הגדרת האייקון לתוכנה וזה משפיע גם על כל החלונות האחרים בתוכנה
    cu_icon_path = resource_path('cu_icon.png')
    if os.path.isfile(cu_icon_path):
        cu_icon = PhotoImage(file=cu_icon_path)
        ws.iconphoto(True, cu_icon)

      
    # אם רוצים לעשות שהחלון הזה יהיה מעל כל החלונות שבמחשב. זה חשוב בעיקר כאשר רזולוציית המסך מוגדלת
    #ws.attributes('-topmost',True)
    #  מוגדר להלן לאחר הגדרת השפה הגדרת הכותרת לתוכנה
    #ws.title(f'תוכנת כוכבים וזמנים + תאריכים:  מאת הרב ד"ר שמחה גרשון בורר | גרסה: {cu_version_date:%d/%m/%Y} {"מותקנת" if is_installed else "ניידת"}')
    
    
    # הגדרת צבע רקע לכל החלון הראשי
    ws.configure(bg=cu_color)
    
    
    '''
    # הגדרת הפונט שתרצה שישמש כברירת מחדל בכל היישום
    import tkinter.font as tkfont
    # יצירת אובייקט פונט
    default_font = tkfont.Font(family="Segoe UI", size=9)
    # הגדרת הפונט כברירת מחדל לכל הוווידג'טים
    ws.option_add("*Font", default_font)
    '''
    

    # הגדרות ברירת מחדל להרבה ווידג'טים של טקינטר בכל חלונות התוכנה - חשוב מאוד
    # כל תיבות אנטרי יהיו מושבתות כלומר: לא זמינות למשתמש להעתקה או עריכה
    ws.option_add("*Entry.state", "disabled")
    # הגדרת צבע רקע של כל תיבות אנטרי שמושבתות
    #ws.option_add("*Entry.disabledBackground", e_color)
    # הטקס שבכל תיבות אנטרי שמושבתות יהיה בצבע שחור
    ws.option_add("*Entry.disabledForeground", "black")
    # הגדרת הסגנון והעובי של כל תיבות האנטרי
    ws.option_add("*Entry.relief", "ridge")
    ws.option_add("*Entry.borderWidth", 2)
    # הגדרת צבע הרקע של כל התוויות
    ws.option_add("*Label.Background", cu_color)
    # הגדרת צבע הרקע של כל התפריטים
    ws.option_add("*Menu.Background", cu_color)
    
    # הגדרת צבע הרקע של כל פאנדווינדוו מוגדר בתחילת הקוד כשמוגדר cu_PandeWindow
    #####ws.option_add("*PanedWindow.Background", "red") # זה לא עובד
    
    # דוגמא לעיצוב בולט שקוע מסגרת וכדומה
    #l1 = Label(root, text="This", borderwidth=2, relief="groove")
    #"flat", "raised", "sunken", "ridge", "solid", and "groove"
    ######################################################################
    
    # באיזו שפה התוכנה תיטען
    
    # הגדרת הכתובת עבור ברירת מחדל של השפה הראשית לתוכנה
    
    # אם יש קובץ להגדרת שפת ברירת המחדל של התוכנה
    if settings_dict["is_language_hebrew"] != None:
        is_heb_locale = settings_dict["is_language_hebrew"] 
    
    # אם אין קובץ להגדרת שפת ברירת מחדל כי זו פתיחה ראשונה של התוכנה אבל שפת מערכת ההפעלה היא עברית הכל מוגדר בעברית והגדרת קובץ שפת ברירת מחדל עברית
    else:
        if is_system_hebrew:
            is_heb_locale = True
            save_setting(key="is_language_hebrew", value=is_heb_locale)
        else:
            # יש לשאול את המשתמש האם הוא רוצה להמשיך באנגלית. אם הוא רוצה התוכנה תיפתח באנגלית וגם יגרום שאנגלית תהיה ברירת המחדל מכאן והלאה
            # אם הוא לא רוצה להמשיך באנגלית התוכנה תיפתח בעברית וגם יגרום שעברית תהיה ברירת המחדל מכאן והלאה
            # השפה של הכיתובים בתוכנה תלוייה במשתנה is_heb_locale       
            ask = 'We noticed that your operating system is in English. The cochavim uzmanim software was built in Hebrew. Part of the software has been translated into English, but it is recommended to display everything in Hebrew. You can always change the default language in the "More options" menu.\nDo you want to continue in English?'
            msg_box = tkinter.messagebox.askquestion(f'cochavim uzmanim Language choosing',ask ,icon='warning', default="no")
            is_heb_locale = False if msg_box == 'yes' else True
            save_setting(key="is_language_hebrew", value=is_heb_locale)
        
        
    
    # הגדרת כותרת התוכנה לפי השפה שבשימוש כרגע
    if not is_heb_locale:
        ws.title(f'cochavim uzmanim +dates: by Rabbi Dr. Simcha Gershon Bohrer | Version: {cu_version_date:%d/%m/%Y} {"installed" if is_installed else "non-installed"}')
    else:
        ws.title(f'תוכנת כוכבים וזמנים + תאריכים:  מאת הרב ד"ר שמחה גרשון בורר | גרסה: {cu_version_date:%d/%m/%Y} {"מותקנת" if is_installed else "ניידת"}')

    
    ######################################################################
    
    # פונקצייה מאוד חשובה עבור כל שינוי של קומבובוקס בתוכנה
    # חשוב מאוד! אסור לקרוא לפונקציית אול כלכוליישנס אם היא כבר פועלת בחישוב רציף שחוזר על עצמו
    def update_calculations():
        if choice_time.get() != "עכשיו מתעדכן":
            all_calculations()
    # כל שינוי של נתון באחד הקומבובוקסים של חלון התוכנה הראשי, גורר קריאה לפונקציית כל החישובים כדי לעדכן את החישובים
    ws.bind('<<ComboboxSelected>>', lambda event: update_calculations())
    
 
    # אזור כפתורים
    #------------------------------------------------------

    # אזור נפרד להזנת תאריך לועזי שעה ןמיקום גאוגרפי וכפתורים לבחירת זמנים שונים וזמני הלכה וכל הכפתורים כולל כפתור כיבוי החישובים
    date_time = cu_PanedWindow(ws)
     
    # כפתור ראשי להפעלת או כיבוי החישובים
    C1 = IntVar(ws)
    On_off = Checkbutton(date_time, text=reverse("התוכנה פעילה") if is_heb_locale else "Software is Active", variable=C1, onvalue = 1, offvalue = 0, command=all_calculations, font = "david 16 bold")
    On_off.grid(column=4, row=0,columnspan=9)
    # הגדרת כפתור הפעלת החישובים על מצב פעיל
    C1.set(1)
       
    # הגדרת משתנה שמחזיק את התהליך/התוכנה הנלווית שמבקשים לפתוח תחת התוכנה הראשית
    choice_subprocess = StringVar(ws)
    
    # תפריט לחצנים לתוכנות הנלוות    
    mb_subprocess =  Menubutton ( date_time, text=reverse("מֵמִיר תאריכים ועוד") if is_heb_locale else "converter & more", relief=RAISED ,bg="gray87")
    mb_subprocess.grid(column=0, row=0, columnspan=3)
    mb_subprocess.menu =  Menu (mb_subprocess, tearoff = 0)
    mb_subprocess["menu"] =  mb_subprocess.menu
    mb_subprocess.menu.add_radiobutton ( label=reverse("ממיר תאריכים לועזי-עברי") if is_heb_locale else "Hebrew-greg-julian date converter",variable=choice_subprocess, value="date_converter", command=open_subprocess)
    mb_subprocess.menu.add_radiobutton ( label=reverse("יום הולדת עברי ובר מצווה") if is_heb_locale else "Hebrew birthday and Bar-Mitzvah",variable=choice_subprocess, value="yom_huledet", command=open_subprocess)
    mb_subprocess.menu.add_radiobutton ( label=reverse("מידע על שנה עברית") if is_heb_locale else "Information about Hebrew year",variable=choice_subprocess, value="heb_year_information", command=open_subprocess)
    
    # תפריט לחצנים נוספים לאפשרויות נוספות
    mb=  Menubutton ( date_time, text=reverse("אפשרויות נוספות") if is_heb_locale else "More options", relief=RAISED ,bg="gray87")
    mb.grid(column=14, row=0, columnspan=1)
    mb.menu =  Menu ( mb, tearoff = 0 )
    mb["menu"] =  mb.menu
    
    
     # הגדרת משתנה שמחזיק את הבחירה של הוספת מיקום חדש או מחיקת מיקום ועוד
    choice_option = StringVar(ws)
    
    # משתנה עבור בחירת ייצוא לוח זמני הלכה חודשי/שנתי
    choice_zmanim_export = StringVar(ws)
    
    # משתנה עבור בחירת ייצוא לוח ראייות ירח ראשון/אחרון
    choice_moon_export = StringVar(ws)
    
    # הגדרת משתנה שמחזיק את הבחירה של תפריט הבחירה
    choice_print = StringVar(ws)
    
    mb.menu.add_command ( label=reverse("שעון ההלכה") if is_heb_locale else "halacha_clock", command=halacha_clock)
    mb.menu.add_command ( label=reverse("הגדרות") if is_heb_locale else "settings", command=edit_settings)
    mb.menu.add_command ( label=reverse("איפוס הגדרות") if is_heb_locale else "reset settings", command=to_default_settings)
    mb.menu.add_radiobutton ( label=reverse("רשימת כוכבי שֶׁבֶת ראשונים הנראים אחרי השקיעה") if is_heb_locale else "List of first stars after sunset",variable=choice_print, value="STARS_EVENING", command=print_halachic_times )
    mb.menu.add_radiobutton ( label=reverse("רשימת כוכבי שֶׁבֶת אחרונים הנראים לפני הזריחה") if is_heb_locale else "List of last stars before sunset",variable=choice_print, value="STARS_MORNING", command=print_halachic_times )
    mb.menu.add_radiobutton ( label=reverse("רשימת זמני היום") if is_heb_locale else "List of day halachic times",variable=choice_print, value="ZMANIM", command=print_halachic_times )
    mb.menu.add_radiobutton ( label=reverse("מידע ירח ראשון הבא") if is_heb_locale else "Next first moon information",variable=choice_print, value="NEXT_NEW_MOON", command=print_halachic_times )
    mb.menu.add_radiobutton ( label=reverse("מידע ירח אחרון הבא") if is_heb_locale else "Next last! moon information",variable=choice_print, value="NEXT_LAST_MOON", command=print_halachic_times )
    mb.menu.add_radiobutton ( label=reverse("מידע ירח ראשון הקודם") if is_heb_locale else "Previous first moon information",variable=choice_print, value="PREVIOUS_NEW_MOON", command=print_halachic_times )
    mb.menu.add_radiobutton ( label=reverse("מידע ירח אחרון הקודם") if is_heb_locale else "Previous last! moon information",variable=choice_print, value="PREVIOUS_LAST_MOON", command=print_halachic_times )
    mb.menu.add_radiobutton ( label=reverse("רשימת ראיות קרובות של תחנת החלל הבינלאומית") if is_heb_locale else "ISS near sight list",variable=choice_print, value="ISS", command=print_halachic_times )
    #mb.menu.add_radiobutton ( label="בטא: מידע תקופת שמואל לשנה עברית המוצגת",variable=choice_print, value="TKUFA", command=print_halachic_times )
    mb.menu.add_radiobutton ( label=reverse("צור קובץ זמנֵי-הלכה לחודש עברי המוצג") if is_heb_locale else "Create halachic times file for Hebrew month shown",variable=choice_zmanim_export, value="HEB_MONTH", command=export_calendar_halacha_times )
    mb.menu.add_radiobutton ( label=reverse("צור קובץ זמנֵי-הלכה לשנה עברית המוצגת") if is_heb_locale else "Create halachic times file for Hebrew year shown",variable=choice_zmanim_export, value="HEB_YEAR", command=export_calendar_halacha_times )
    mb.menu.add_radiobutton ( label=reverse("צור קובץ זמנֵי-הלכה לחודש גרגוריאני המוצג") if is_heb_locale else "Create halachic times file for Gregorian month shown",variable=choice_zmanim_export, value="GREG_MONTH", command=export_calendar_halacha_times )
    mb.menu.add_radiobutton ( label=reverse("צור קובץ זמנֵי-הלכה לשנה גרגוריאנית המוצגת") if is_heb_locale else "Create halachic times file for Gregorian year shown",variable=choice_zmanim_export, value="GREG_YEAR", command=export_calendar_halacha_times )
    mb.menu.add_radiobutton ( label=reverse("צור קובץ ראִיות ירח ראשון לשנה עברית המוצגת") if is_heb_locale else "Create first moon file for Hebrew year shown",variable=choice_moon_export, value="FIRST", command=export_calendar_moons)
    mb.menu.add_radiobutton ( label=reverse("צור קובץ ראִיות ירח אחרון! לשנה עברית המוצגת") if is_heb_locale else "Create last! moon file for Hebrew year shown",variable=choice_moon_export, value="LAST", command=export_calendar_moons)
    mb.menu.add_radiobutton ( label=reverse("הגדרת מיקום נוכחי כברירת מחדל") if is_heb_locale else "Set current location as default",variable=choice_option,value="DEFAULT",command=edit_locations_file)
    mb.menu.add_radiobutton ( label=reverse("הוספת מיקום חדש לקובץ המיקומים") if is_heb_locale else "Add new location to locations file",variable=choice_option,value="ADD",command=add_new_location)
    mb.menu.add_radiobutton ( label=reverse("מחיקת מיקום נוכחי מקובץ המיקומים") if is_heb_locale else "Deleting current location from locations file",variable=choice_option,value="DELETE",command=edit_locations_file)
    mb.menu.add_radiobutton ( label=reverse("מיון קובץ המיקומים לפי א-ב") if is_heb_locale else "Sorting location file to A-B-C",variable=choice_option,value="SORT",command=edit_locations_file)
    #mb.menu.add_command ( label="פתיחת קובץ המיקומים לצורך עריכתו", command=start_the_edited_locations_file)
    mb.menu.add_command ( label=reverse("איפוס קובץ המיקומים למצבו ההתחלתי") if is_heb_locale else "Reset the locations file", command=delete_edited_locations_file)
    mb.menu.add_command ( label=reverse("פתיחת תיקיית כוכבים וזמנים") if is_heb_locale else "Opening the cochavim uzmanim folder", command=start_cu_dir_path)
    mb.menu.add_command ( label=reverse("בדיקה האם גרסת התוכנה עדכנית") if is_heb_locale else "Checking software version update", command=is_cu_software_update)
    mb.menu.add_command ( label=reverse("פתיחת אתר האינטרנט של תוכנת כוכבים וזמנים") if is_heb_locale else "Opening cochavim uzmanim website", command=open_cu_website)
    # הגדרות עבור קובץ אפאמאריס מורחב שאותו רוצים להוריד
    de441s_url = "https://github.com/sgbmzm/cochavim-uzmanim/releases/download/cochavim_uzmanim_plus/de441s.bsp"
    de441s_file_name = "de441s.bsp"
    mb.menu.add_command ( label=reverse("הורדת de441s.bsp") if is_heb_locale else "Downloading de441s.bsp", command= lambda: downloading_files(de441s_url,de441s_file_name))
    # אם זו גרסת תוכנה שאינה מותקנת הוספת כפתור התקנה
    if not is_installed:
        mb.menu.add_command ( label=reverse("התקנה קבועה של תוכנת כוכבים וזמנים") if is_heb_locale else "Installation of cochavim uzmanim", command=install_cu)
    mb.menu.add_command ( label=reverse("מידע: סולם הזמן הנוכחי והסטייה השנתית שלו") if is_heb_locale else "information: current timescale and its annual deviation", command=time_scale_showinfo)
    
    #----------------------------------

    
    # הגדרת שני תפריטי בחירה לאופציות שונות של בחירת זמן: זמני הלכה וזמנים מיוחדים
    choice_time = StringVar(ws)

    menubutton_1 = Menubutton(date_time, text=reverse('זמני\nהלכה ') if is_heb_locale else "Daily\ntimes", relief='raised',bg="gray87")
    menubutton_1.grid(column=0, row=1,rowspan=2)
    # הגדרת פריטי בחירה עבור התפריט
    times1 = [
           'עלות השחר -19.75','תחילת דמדומים -18','עלות השחר -16','עלות השחר -14','תחילת דמדומים -12','משיכיר -10.5','תחילת דמדומים -6','הנץ בגובה - כשאין הסתרות','הנץ -0.833','הנץ 0','סוף זמן שמע מג"א -16','סוף זמן שמע גר"א','סוף זמן תפילה מג"א -16','סוף זמן תפילה גר"א','חצות היום','מנחה גדולה',
    'מנחה קטנה','פלג המנחה','שקיעה 0','שקיעה -0.833','שקיעה בגובה - כשאין הסתרות','צאת הכוכבים -3.65','צאת הכוכבים -4','צאת הכוכבים -4.61','סוף דמדומים -6','צאת שבת לוחות -8.5','סוף דמדומים -12','צאת הכוכבים דר"ת -16','סוף דמדומים -18','צאת הכוכבים דר"ת -19.75'
        ]
    times1_en = ['Dawn -19.75','Astronomical Twilight Begins -18','Dawn -16','Dawn -14','Nautical Twilight Begins -12','Misheyakir -10.5','Civil Twilight Begins -6','Sunrise at height (no hiding)','Sunrise -0.833','Sunrise 0','Latest Shema MGA -16','Latest Shema GRA','Latest Tefillah MGA -16','Latest Tefillah GRA', 'Midday', 'Minchah Gedolah','Minchah Ketanah','Plag Haminchah','Sunset 0','Sunset -0.833','Sunset at height (no hiding)','Stars Rising -3.65','Stars Rising -4','Stars Rising -4.61', 'End of Civil Twilight -6', 'End of Shabbat -8.5', 'End of Nautical Twilight -12', 'End of Twilight -16', 'End of Astronomical Twilight -18', 'End of Twilight -19.75']
    # הגדרת התפריט על הפריטים
    file_menu = Menu(menubutton_1,tearoff=0)
    for i in range(len(times1)):
        S = file_menu.add_radiobutton(label=reverse(times1[i]) if is_heb_locale else times1_en[i], variable=choice_time, value=times1[i],command=set_menubuttons_times)# justify='center'
    menubutton_1.config(menu=file_menu)
    #------
    Label(date_time, text="  ").grid(column=1, row=2)

    menubutton_2 = Menubutton(date_time, text=reverse('זמנים \nואירועים ') if is_heb_locale else "Times \n& events", relief='raised',bg="gray87")
    menubutton_2.grid(column=2, row=1, rowspan=2)
    # הגדרת פריטי בחירה עבור התפריט
    times2 = ['עכשיו (לפי המחשב)','עכשיו מתעדכן','דילוג זמן לפי בחירת המשתמש','מולד ירח אמיתי הבא','ניגוד ירח אמיתי הבא','מולד ירח אמיתי קודם','ניגוד ירח אמיתי קודם','זריחת הירח הבאה','שקיעת הירח הבאה','זריחת הירח הקודמת','שקיעת הירח הקודמת','שיוויון האביב הבא','שיוויון הסתיו הבא','היפוך הקיץ הבא','היפוך החורף הבא','נוגה בהתארכות הבאה','נוגה בהתקבצות הבאה','ליקוי חמה הבא הנראה במיקום זה','ליקוי ירח הבא הנראה במיקום זה']
    times2_en = ['now (according to computer)','now updating','time skip by users choice','next true moon birth','next true moon opposition','previous true moon birth','previous true moon opposition ','next moonrise','next moonset','previous moonrise','previous moonset','next vernal equinox','next autumnal equinox','next summer solstice','next winter solstice', 'Venus at the next elongation', 'Venus at the next conjunction', 'Next solar eclipse visible at this location', 'Next lunar eclipse visible at this location']
    # הגדרת התפריט על הפריטים
    file_menu = Menu(menubutton_2,tearoff=0)
    for i in range(len(times2)):
        S = file_menu.add_radiobutton(label=reverse(times2[i]) if is_heb_locale else times2_en[i], variable=choice_time, value=times2[i],command=set_menubuttons_times)# justify='center'
    menubutton_2.config(menu=file_menu)

    

    # תאריך לועזי-----------------

    greg_day = StringVar(ws)
    input_day_range = [f"{i:02.0f}" for i in range(1,32)]
    greg_day_cb = ttk.Combobox(date_time, textvariable=greg_day, width=2, state=state1,values=[*input_day_range],font="narkisim 16",justify='center',)
    greg_day_cb.grid(column=4, row=1)
    Label(date_time, text=reverse("יום") if is_heb_locale else "day").grid(column=4, row=2)

    greg_month = StringVar(ws)
    input_month_range = [f"{i:02.0f}" for i in range(1,13)]
    greg_month_cb = ttk.Combobox(date_time, textvariable=greg_month, width=2, state=state1,values=[*input_month_range],font="narkisim 16",justify='center',)
    greg_month_cb.grid(column=5, row=1)
    Label(date_time, text=reverse("חודש") if is_heb_locale else "month").grid(column=5, row=2)
    
    greg_year = StringVar(ws)
    greg_year_cb = ttk.Combobox(date_time, textvariable=greg_year, width=5, state=state1,values=[*input_years_range],font="narkisim 16",justify='center',)
    greg_year_cb.grid(column=6, row=1)
    Label(date_time, text=reverse("שנה") if is_heb_locale else "year").grid(column=6, row=2)
    
    '''
    # השארתי רק בשביל הדוגמא איך זה היה פעם בספינבוקס
    Spinbox(
        date_time,
        textvariable=greg_month,
        from_=1, 
        to=12,
        format_="%02.0f",
        wrap=True,
        state = 'readonly',
        readonlybackground = "white",
        width=2,
        #command=display_selected,
        font="narkisim 17", 
    ).grid(column=5, row=1)
    '''
    
    
    # הפרדה-------------------------------
    Label(date_time, text="      ").grid(column=3, row=2)


    # שעה-----------------------

    # הפרדה
    Label(date_time, text="      ").grid(column=7, row=1)

    
    hours = StringVar(ws)
    input_hours_range = [f"{i:02.0f}" for i in range(0,24)]
    hours_cb = ttk.Combobox(date_time, textvariable=hours, width=2, state=state1,values=[*input_hours_range],font="narkisim 16",justify='center')
    hours_cb.grid(column=8, row=1)
    Label(date_time, text=reverse("שעה") if is_heb_locale else "hour",justify='center').grid(column=8, row=2)

    minutes = StringVar(ws)
    input_minutes_range = [f"{i:02.0f}" for i in range(0,60)]
    minutes_cb = ttk.Combobox(date_time, textvariable=minutes, width=2, state=state1,values=[*input_minutes_range],font="narkisim 16",justify='center')
    minutes_cb.grid(column=9, row=1)
    Label(date_time, text=reverse("דקות") if is_heb_locale else "minute",justify='center').grid(column=9, row=2)

    seconds = StringVar(ws)
    input_seconds_range = [f"{i:02.0f}" for i in range(0,60)]
    seconds_cb = ttk.Combobox(date_time, textvariable=seconds, width=2, state=state1,values=[*input_seconds_range],font="narkisim 16",justify='center')
    seconds_cb.grid(column=10, row=1)
    Label(date_time, text=reverse("שניות") if is_heb_locale else "second",justify='center').grid(column=10, row=2)

    # מיקרו שניות לצורך הדיוק
    # מיקרו־שניה (µs) – מיליונית השניה (10-6 שניות), משמשת למדידת זמנים של מצבי מעבר בתגובות כימיות.
    # microseconds Between 0 and 999999 inclusive
    # אבל בגלל שאני מציג למשתמש רק את הספרה הראשונה הרי שזה רק דצישנייה כלומר עשירית השנייה
    microseconds = StringVar(ws)
    input_microseconds_range = range(0,10)
    microseconds_cb = ttk.Combobox(date_time, textvariable=microseconds, width=1, state=state1,values=[*input_microseconds_range],font="narkisim 16",justify='center')
    microseconds_cb.grid(column=11, row=1)
    Label(date_time, text=reverse("דצישניה") if is_heb_locale else "decisec",justify='center').grid(column=11, row=2)

    # מיקום גיאוגרפי-עיר----------------------------------------------

    # הגדרת תפריט גלילה קומבודקס עבור בחירת מיקום
    city = StringVar(ws)
    locations_names = [reverse(i["location_name_heb"]) if is_heb_locale else i["location_name_en"] for i in locations]
    locations_cb = ttk.Combobox(date_time, textvariable=city, width=15, state='readonly',values=["בחירה-ידנית" if is_heb_locale else "Choose manually", *locations_names],font="narkisim 16",justify='center')
    locations_cb.grid(column=14, row=1)
    Label(date_time, text=reverse("בחר מיקום גיאוגרפי") if is_heb_locale else "Select location", font= "david 13 bold").grid(column=14, row=2)
    # הגדרת ברירת מחדל בפתיחת התוכנה: שהמיקום יהיה המיקום הראשון ברשימת המיקומים שזהו המיקום הראשון בקובץ האקסל של המיקומים
    city.set(locations_names[0])

    
    # הפרדה-------------------------------
    Label(date_time, text="      ").grid(column=12, row=2)

    # אריזת איזור הזמנים והכפתורים לתוך החלון הראשי
    date_time.pack()

    #ריווח
    #Label(ws, text= "———————————————————————————————————————————————————————").pack()
    ttk.Separator(ws,orient="horizontal").pack(fill="x", padx=20, pady=5)


    # אזור תוצאות
    #------------------------------------------------------

    results = cu_PanedWindow(ws)
    
    tkinter.Button(results, text=reverse("מידע כללי והסברים") if is_heb_locale else "General information", command=esber).grid(column=6, row=0)
    Label(results, text=reverse("גובה (במעלות מהאופק)") if is_heb_locale else "Altitude", font="david 15 bold",justify="center").grid(column=6, row=1)
    Label(results, text=reverse("אַזִימוּט (במעלות מהצפון)") if is_heb_locale else "Azimuth", font="david 15 bold",justify="center").grid(column=6, row=2)
    Label(results, text=reverse("עלייה ישרה") if is_heb_locale else "Right Ascension", font="david 15 bold",justify="center").grid(column=6, row=3)
    Label(results, text=reverse("נטייה (דֶקְלִינַצְיָה)") if is_heb_locale else "Declination", font="david 15 bold",justify="center").grid(column=6, row=4)
    Label(results, text=reverse("זוִוית השעה") if is_heb_locale else "Hour Angle", font="david 15 bold",justify="center").grid(column=6, row=5)
    Label(results, text=reverse("קו אורך אֶקְלִיפְּטִי") if is_heb_locale else "Ecliptic longitude", font="david 15 bold",justify="center").grid(column=6, row=6)
    Label(results, text=reverse("קו רוחב אֶקְלִיפְּטִי") if is_heb_locale else "Ecliptic latitude", font="david 15 bold",justify="center").grid(column=6, row=7)
    Label(results, text=reverse("מרחק מכדור הארץ") if is_heb_locale else "Distance (from earth)", font="david 15 bold",justify="center").grid(column=6, row=9)


    # הגדרת תפריט בחירה בין פרמטרים שונים על הכוכב
    elongation_percent_thickness = StringVar(ws)
    elongation_options = reverse(["אֵלוֹנְגַּצְיָה (מהשמש)","אורך ראשון (מהשמש)","אחוזי תאורה","קוטר זוויתי נראה"]) if is_heb_locale else ["Elongation","Ecliptic Elongation","Fraction Illuminated","Apparent Diameter"]
    elongation_percent_thickness_cb = ttk.Combobox(results, textvariable=elongation_percent_thickness, width=19, state='readonly',values=[*elongation_options],font="david 15 bold",justify='center')
    elongation_percent_thickness_cb.grid(column=6, row=8)
    elongation_percent_thickness.set(elongation_options[0])

    # טור רווח
    Label(results, text="  ", font= "david 10 bold").grid(column=5, row=0)


    # שמש

    sun_elongation_percent_thickness = StringVar(ws)
    sun_lon = StringVar(ws)
    sun_lat = StringVar(ws)
    sun_az = StringVar(ws)
    sun_alt = StringVar(ws)
    sun_ra = StringVar(ws)
    sun_dec = StringVar(ws)
    sun_ha = StringVar(ws)
    sun_dist = StringVar(ws)

    Label(results, text=reverse("שמש") if is_heb_locale else "Sun", font="david 16 bold",width=10, relief="groove",bg="white").grid(column=4, row=0)

    Entry(results, width=10, textvariable=sun_alt, font="narkisim 25 bold",justify="center",relief="flat",disabledbackground= "gray87").grid(column=4, row=1)
    Entry(results, width=17, textvariable=sun_az, font="narkisim 14",justify="center").grid(column=4, row=2)
    Entry(results, width=17, textvariable=sun_ra, font="narkisim 14",justify="center").grid(column=4, row=3)
    Entry(results, width=17, textvariable=sun_dec, font="narkisim 14",justify="center").grid(column=4, row=4)
    Entry(results, width=17, textvariable=sun_ha, font="narkisim 14",justify="center").grid(column=4, row=5)
    Entry(results, width=17, textvariable=sun_lon, font="narkisim 14",justify="center").grid(column=4, row=6)
    Entry(results, width=17, textvariable=sun_lat, font="narkisim 14",justify="center").grid(column=4, row=7)
    Entry(results, width=17, textvariable=sun_elongation_percent_thickness, font="narkisim 14",justify="center").grid(column=4, row=8)
    Entry(results, width=17, textvariable=sun_dist, font="narkisim 14", justify="center").grid(column=4, row=9)


    # טור רווח
    Label(results, text="", font= "david 10 bold").grid(column=3, row=0)



    # גוף נבחר ראשון: כוכבי לכת
    
    body1 = StringVar(ws)
    planets_names = reverse(['ירח', 'כוכב-חמה', 'נוגה', 'מאדים', 'צדק', 'שבתאי', 'אוראנוס', 'נפטון', 'פלוטו']) if is_heb_locale else ['Moon', 'Mercury', 'Venus', 'Mars', 'Jupiter', 'Saturn', 'Uranus', 'Neptune', 'Pluto']
    planets_cb = ttk.Combobox(results, textvariable=body1, width=12, state='readonly',values=[*planets_names],font="david 16 bold",justify='center')
    planets_cb.grid(column=2, row=0)
    # הגדרת ברירת מחדל בפתיחת התוכנה: שגוף נבחר שני יהיה הכוכב הראשון במערך המכיל את שמות כוכבי הלכת
    body1.set(planets_names[0])
    

    body1_lon = StringVar(ws)
    body1_lat = StringVar(ws)
    body1_az = StringVar(ws)
    body1_alt = StringVar(ws)
    body1_ra = StringVar(ws)
    body1_dec = StringVar(ws)
    body1_ha = StringVar(ws)
    body1_dist = StringVar(ws)
    body1_elongation_percent_thickness = StringVar(ws)


    Entry(results, width=17, textvariable=body1_alt, font="narkisim 14",justify="center").grid(column=2, row=1)
    Entry(results, width=17, textvariable=body1_az, font="narkisim 14",justify="center").grid(column=2, row=2)
    Entry(results, width=17, textvariable=body1_ra, font="narkisim 14",justify="center").grid(column=2, row=3)
    Entry(results, width=17, textvariable=body1_dec, font="narkisim 14",justify="center").grid(column=2, row=4)
    Entry(results, width=17, textvariable=body1_ha, font="narkisim 14",justify="center").grid(column=2, row=5)
    Entry(results, width=17, textvariable=body1_lon, font="narkisim 14",justify="center").grid(column=2, row=6)
    Entry(results, width=17, textvariable=body1_lat, font="narkisim 14",justify="center").grid(column=2, row=7)
    Entry(results, width=17, textvariable=body1_elongation_percent_thickness, font="narkisim 14",justify="center").grid(column=2, row=8)
    Entry(results, width=17, textvariable=body1_dist, font="narkisim 14", justify="center").grid(column=2, row=9)

    # טור רווח
    Label(results, text="  ", font= "david 14 bold").grid(column=1, row=0)


    # גוף נבחר שני: כוכבי שֶׁבֶת
    
    # הגדרת תפריט גלילה קומבודקס עבור גוף נבחר שני שזה כוכבי שבת
    body2 = StringVar(ws)
    stars_names = [reverse(i["name_he"]) if is_heb_locale else i["name_en"] for i in stars]
    stars_cb = ttk.Combobox(results, textvariable=body2, width=12, state='readonly',values=[*stars_names],font="david 16 bold",justify='center')
    stars_cb.grid(column=0, row=0)
    # הגדרת ברירת מחדל בפתיחת התוכנה: שגוף נבחר שני יהיה הכוכב הראשון ברשימת ההכוכבים שזהו המיקום הראשון בקובץ האקסל של הכוכבים
    body2.set(stars_names[0])
    

    body2_elongation_percent_thickness = StringVar(ws)
    body2_lon = StringVar(ws)
    body2_lat = StringVar(ws)
    body2_az = StringVar(ws)
    body2_alt = StringVar(ws)
    body2_ra = StringVar(ws)
    body2_dec = StringVar(ws)
    body2_ha = StringVar(ws)
    body2_dist = StringVar(ws)


    Entry(results, width=17, textvariable=body2_alt, font="narkisim 14",justify="center").grid(column=0, row=1)
    Entry(results, width=17, textvariable=body2_az, font="narkisim 14",justify="center").grid(column=0, row=2)
    Entry(results, width=17, textvariable=body2_ra, font="narkisim 14",justify="center").grid(column=0, row=3)
    Entry(results, width=17, textvariable=body2_dec, font="narkisim 14",justify="center").grid(column=0, row=4)
    Entry(results, width=17, textvariable=body2_ha, font="narkisim 14",justify="center").grid(column=0, row=5)
    Entry(results, width=17, textvariable=body2_lon, font="narkisim 14",justify="center").grid(column=0, row=6)
    Entry(results, width=17, textvariable=body2_lat, font="narkisim 14",justify="center").grid(column=0, row=7)
    Entry(results, width=17, textvariable=body2_elongation_percent_thickness, font="narkisim 14",justify="center").grid(column=0, row=8)
    Entry(results, width=17, textvariable=body2_dist, font="narkisim 14", justify="center").grid(column=0, row=9)

    # אריזת איזור התוצאות לתוך החלון הראשי
    results.pack()


    #ריווח
    #Label(ws, text= "———————————————————————————————————————————————————————").pack()
    
    
    
    
    # ===== temporal_clock =====
    temporal_clock = Frame(ws, bg=cu_color, highlightbackground="black", highlightthickness=1)
    temporal_clock.pack(padx=15, pady=10)

    # ===== main frame =====
    main_frame = Frame(temporal_clock, bg=cu_color)
    main_frame.pack(padx=5, pady=5)

    main_frame.columnconfigure(0, weight=1, uniform="halves")
    main_frame.columnconfigure(1, weight=0)
    main_frame.columnconfigure(2, weight=1, uniform="halves")

    # ================= LEFT =================
    left_frame = Frame(main_frame, bg=cu_color)
    left_frame.grid(row=0, column=0, sticky="nsew")

    left_tc = Frame(left_frame, bg=cu_color)
    left_tc.pack(expand=True)

    left_tc.columnconfigure(0, weight=1)
    left_tc.columnconfigure(1, weight=2)
    left_tc.columnconfigure(2, weight=1)

    # משתנים
    print_temporal_hour_MGA = StringVar(ws)
    print_day_or_night_MGA = StringVar(ws)
    print_Sunrise_determines_MGA = StringVar(ws)
    print_Sunset_determines_MGA = StringVar(ws)
    print_minutes_in_temporal_hour_MGA = StringVar(ws)

    # --- שקיעה ---
    sunset_frame_L = Frame(left_tc, bg=cu_color)
    sunset_frame_L.grid(row=0, column=0, sticky="n")

    Entry(
        sunset_frame_L,
        textvariable=print_Sunset_determines_MGA,
        width=8,
        font="narkisim 14",
        justify="center"
    ).pack()

    Label(
        sunset_frame_L,
        text=reverse("שקיעה קובעת") if is_heb_locale else "Sunset determines",
        bg=cu_color
    ).pack()

    # --- שעון ---
    clock_frame_L = Frame(left_tc, bg=cu_color)
    clock_frame_L.grid(row=0, column=1, sticky="n")

    Entry(
        clock_frame_L,
        textvariable=print_temporal_hour_MGA,
        width=9,
        font="narkisim 20 bold",
        justify="center",
        relief="flat",
        disabledbackground= "gray87"
    ).pack()

    Label(
        clock_frame_L,
        text=reverse("מג''א - שעה זמנית") if is_heb_locale else "MGA - Temporal Hour",
        font="david 10 bold",
        bg=cu_color
    ).pack()

    # --- זריחה ---
    sunrise_frame_L = Frame(left_tc, bg=cu_color)
    sunrise_frame_L.grid(row=0, column=2, sticky="n")

    Entry(
        sunrise_frame_L,
        textvariable=print_Sunrise_determines_MGA,
        width=8,
        font="narkisim 14",
        justify="center"
    ).pack()

    Label(
        sunrise_frame_L,
        text=reverse("זריחה קובעת") if is_heb_locale else "Sunrise determines",
        bg=cu_color
    ).pack()

    # --- שורה תחתונה ---
    Entry(left_tc, textvariable=print_day_or_night_MGA,
          width=5, font="narkisim 14", justify="center").grid(row=1, column=0)
    Label(left_tc, text=reverse("יום / לילה") if is_heb_locale else "Day / Night").grid(row=2, column=0)

    left_radio_frame = Frame(left_tc, bg=cu_color)
    left_radio_frame.grid(row=1, column=1)

    Entry(left_tc, textvariable=print_minutes_in_temporal_hour_MGA,
          width=5, font="narkisim 14", justify="center").grid(row=1, column=2)
    Label(left_tc, text=reverse("דקות לשעה") if is_heb_locale else "Minutes / hour").grid(row=2, column=2)

    values_MGA = [222, -19.75, -16]
    Halachic_method_MGA = DoubleVar(ws)
    idx_mga = values_MGA.index(settings_dict["mga_deg"]) if settings_dict["mga_deg"] in values_MGA else 2
    Halachic_method_MGA.set(values_MGA[idx_mga])
      
    def on_mga_change():
        save_setting("mga_deg", Halachic_method_MGA.get())
        all_calculations()

    for i, value in enumerate(values_MGA):
        ttk.Radiobutton(
            left_radio_frame,
            text=f"{value}°" if value < 100 else "-16|4",
            variable=Halachic_method_MGA,
            value=value,
            command=on_mga_change
        ).grid(row=0, column=i, padx=10)
        
    
    Label(left_tc, text=reverse("גובה עלות וצאהכ דרת") if is_heb_locale else "Alot and R''T Alt").grid(row=2, column=1)

    # ===== Separator =====
    ttk.Separator(main_frame, orient="vertical").grid(row=0, column=1, sticky="ns", padx=15)

    # ================= RIGHT =================
    right_frame = Frame(main_frame, bg=cu_color)
    right_frame.grid(row=0, column=2, sticky="nsew")

    right_tc = Frame(right_frame, bg=cu_color)
    right_tc.pack(expand=True)

    right_tc.columnconfigure(0, weight=1)
    right_tc.columnconfigure(1, weight=2)
    right_tc.columnconfigure(2, weight=1)

    print_temporal_hour_GRA = StringVar(ws)
    print_day_or_night_GRA = StringVar(ws)
    print_Sunrise_determines_GRA = StringVar(ws)
    print_Sunset_determines_GRA = StringVar(ws)
    print_minutes_in_temporal_hour_GRA = StringVar(ws)

    # --- שקיעה ---
    sunset_frame_R = Frame(right_tc, bg=cu_color)
    sunset_frame_R.grid(row=0, column=0, sticky="n")

    Entry(sunset_frame_R, textvariable=print_Sunset_determines_GRA, width=8, font="narkisim 14", justify="center").pack()
    Label(sunset_frame_R, text=reverse("שקיעה קובעת") if is_heb_locale else "Sunset determines", bg=cu_color).pack()

    # --- שעון ---
    clock_frame_R = Frame(right_tc, bg=cu_color)
    clock_frame_R.grid(row=0, column=1, sticky="n")

    Entry(clock_frame_R, textvariable=print_temporal_hour_GRA, width=9, font="narkisim 25 bold", justify="center", relief="flat", disabledbackground= "gray87").pack()
    Label(clock_frame_R, text=reverse("גר''א - שעה זמנית") if is_heb_locale else "GRA - Temporal Hour", font="david 14 bold", bg=cu_color).pack()

    # --- זריחה ---
    sunrise_frame_R = Frame(right_tc, bg=cu_color)
    sunrise_frame_R.grid(row=0, column=2, sticky="n")

    Entry(sunrise_frame_R,textvariable=print_Sunrise_determines_GRA,width=8,font="narkisim 14",justify="center").pack()
    Label(sunrise_frame_R,text=reverse("זריחה קובעת") if is_heb_locale else "Sunrise determines",bg=cu_color).pack()

    # --- שורה תחתונה ---
    Entry(right_tc, textvariable=print_day_or_night_GRA,width=5, font="narkisim 14", justify="center").grid(row=1, column=0)
    Label(right_tc, text=reverse("יום / לילה") if is_heb_locale else "Day / Night").grid(row=2, column=0)

    right_radio_frame = Frame(right_tc, bg=cu_color)
    right_radio_frame.grid(row=1, column=1)

    Entry(right_tc, textvariable=print_minutes_in_temporal_hour_GRA,width=5, font="narkisim 14", justify="center").grid(row=1, column=2)
    Label(right_tc, text=reverse("דקות לשעה") if is_heb_locale else "Minutes / hour").grid(row=2, column=2)

    values_GRA = [0, -0.833]
    Halachic_method_GRA = DoubleVar(ws)
    idx_gra = values_GRA.index(settings_dict["rise_set_deg"]) if settings_dict["rise_set_deg"] in values_GRA else 1
    Halachic_method_GRA.set(values_GRA[idx_gra])
    
    def on_gra_change():
        save_setting("rise_set_deg", Halachic_method_GRA.get())
        all_calculations()


    for i, value in enumerate(values_GRA):
        ttk.Radiobutton(
            right_radio_frame,
            text=f"{value}°",
            variable=Halachic_method_GRA,
            value=value,
            command=on_gra_change
        ).grid(row=0, column=i, padx=10)
        
    Label(right_tc, text=reverse("גובה זריחה ושקיעה") if is_heb_locale else "Sunrise and sunset Alt").grid(row=2, column=1)

    #ttk.Separator(ws,orient="horizontal").pack(fill="x", padx=20, pady=5)


    #ריווח
    #Label(ws, text= "———————————————————————————————————————————————————————").pack()
        

    # אזור נפרד למיקום גיאוגרפי
    location_lat_lon = cu_PanedWindow(ws)

    print_location = StringVar(ws)
    print_location_lat = StringVar(ws)
    print_location_lon = StringVar(ws)
    print_location_elevation = StringVar(ws)
    print_GMT_difference = StringVar(ws)
    print_location_timezone = StringVar(ws)
    
    Entry(location_lat_lon, textvariable=print_location,width=17, font="narkisim 14", justify="center").grid(column=11, row=1)
    Label(location_lat_lon, text= reverse("     שם המקום     ")  if is_heb_locale else "   Location Name   ").grid(column=11, row=2)
    Entry(location_lat_lon, textvariable=print_location_lat,width=13, font="narkisim 14", justify="center").grid(column=10, row=1)
    Label(location_lat_lon, text= reverse("     קו רוחב גיאוגרפי     ") if is_heb_locale else "        Latitude        ").grid(column=10, row=2)
    Entry(location_lat_lon, textvariable=print_location_lon,width=13, font="narkisim 14", justify="center").grid(column=9, row=1)
    Label(location_lat_lon, text= reverse("   קו אורך גיאוגרפי   ") if is_heb_locale else "      longitude      ").grid(column=9, row=2)
    Entry(location_lat_lon, textvariable=print_location_elevation,width=12, font="narkisim 14", justify="center").grid(column=8, row=1)
    Label(location_lat_lon, text= reverse("      גובה-במטרים      ") if is_heb_locale else "  Elevation (Meters)  ").grid(column=8, row=2)
    #Entry(location_lat_lon, textvariable=print_GMT_difference,width=13, font="narkisim 14", justify="center").grid(column=7, row=1)
    #Label(location_lat_lon, text= "הפרש שעות מגריניץ").grid(column=7, row=2)
    #Entry(location_lat_lon, textvariable=print_location_timezone,width=20, font="narkisim 14", justify="center").grid(column=6, row=1)
    #Label(location_lat_lon, text= "              איזור זמן מתואם              ").grid(column=6, row=2)

    # רווח
    #Label(location_lat_lon, text="   ").grid(column=6, row=2)

    # תאים להכנסת מיקום גיאוגרפי ידני. איזור זה מוצג רק בשעה שהמשתמש בוחר באופציית בחירה ידנית בחלונית המיקום. לכן ההצבה של התאים לא מוגדרת כאן
    lat_part_1 = StringVar(ws)
    lat_part_2 = StringVar(ws)
    lon_part_1 = StringVar(ws)
    lon_part_2 = StringVar(ws)
    elevation_part = StringVar(ws)
    
    
    # דוגמא איך אפשר לעשות ריינג עשרוני כרגע לא רלוונטי
    #[f"{i:02.2f}" for i in np.arange(-90.00, 90.01, 0.01)]
    
    input_elevation_range = [i for i in range(0,10000)]
    cb5 = ttk.Combobox(location_lat_lon, textvariable=elevation_part, width=8, state='readonly',values=[*input_elevation_range],font="narkisim 16",justify='center')
    # הרוחב 8 כדי לכסות את מה שמתחת
    cb5.set(0)
    
    input_0_99_range = [f"{i:02.0f}" for i in range(0,100)]
    
    cb4 = ttk.Combobox(location_lat_lon, textvariable=lat_part_2, width=2, state='readonly',values=[*input_0_99_range],font="narkisim 16",justify='center')
    cb4.set(input_0_99_range[0])
    
    cb2 = ttk.Combobox(location_lat_lon, textvariable=lon_part_2, width=2, state='readonly',values=[*input_0_99_range],font="narkisim 16",justify='center')
    cb2.set(input_0_99_range[0])
    
    input_lat_part_1_range = [i for i in range(-90,91)]
    cb3 = ttk.Combobox(location_lat_lon, textvariable=lat_part_1, width=3, state='readonly',values=[*input_lat_part_1_range],font="narkisim 16",justify='center')
    cb3.set(input_lat_part_1_range[90])
    
    input_lon_part_1_range = [i for i in range(-179,181)]
    cb1 = ttk.Combobox(location_lat_lon, textvariable=lon_part_1, width=4, state='readonly',values=[*input_lon_part_1_range],font="narkisim 16",justify='center')
    cb1.set(input_lon_part_1_range[179])
    
    cb3_Label = Label(location_lat_lon, text=reverse("קו רוחב (צפ-דר)") if is_heb_locale else "latitude (N-S)")
    Label(location_lat_lon, text="").grid(column=3, row=2) # רווח
    cb1_Label = Label(location_lat_lon, text=reverse("קו אורך (מז-מע)") if is_heb_locale else "longitude (E-W)")
    
    
    location_lat_lon.pack()

    #ריווח
    #Label(ws, text= "———————————————————————————————————————————————————————").pack()
    ttk.Separator(ws,orient="horizontal", style="Black.TSeparator").pack(fill="x", padx=20, pady=3)

    # אזור נפרד להדפסת תאריך שעה ומיקום גאוגרפי של החישובים
    print_ = cu_PanedWindow(ws)
    
    print_time = StringVar(ws)
    print_greg_date = StringVar(ws)
    print_heb_date = StringVar(ws)

    Label(print_, text= reverse("תאריך לועזי (גרגוריאני!)") if is_heb_locale else "Gregorian Date", font="david 12 bold").grid(column=5, row=2)
    Entry(print_, textvariable=print_greg_date ,width=35, font="narkisim 14", justify="center").grid(column=5, row=1)
    Label(print_, text= " ").grid(column=4, row=1)
    Label(print_, text= reverse("שעון רגיל (אֵזוֹרִי)") if is_heb_locale else "Standard Time",font="david 14 bold").grid(column=3, row=2)
    Entry(print_, textvariable=print_time, width=9, font="narkisim 25 bold", justify="center",relief="flat",disabledbackground= "gray87").grid(column=3, row=1)
    Label(print_, text= " ").grid(column=2, row=1)
    Label(print_, text= reverse("תאריך עברי (מתחלף בשקיעה)") if is_heb_locale else "Hebrew Date", font="david 12 bold").grid(column=1, row=2)
    Entry(print_, textvariable=print_heb_date, width=35, font="narkisim 14", justify="center").grid(column=1, row=1)

    print_.pack()

    Label(ws, text= "", font="david 1").pack()
    
    # אזור נפרד לשעונים שונים
    clocks = cu_PanedWindow(ws)
    # שעה-----------------------

    print_hours_from_last_sunset = StringVar(ws)
    print_utc_time = StringVar(ws)
    print_lmt_time=StringVar(ws)
    print_LSoT_time=StringVar(ws)
    print_JD=StringVar(ws)
    print_delta_t=StringVar(ws)
    print_equation_of_time = StringVar(ws)

    
    Entry(clocks,textvariable=print_JD,width=14,font="narkisim 16",justify="center").grid(column=8, row=1)
    Label(clocks, text = reverse("JD יום יוליאני ") if is_heb_locale else "JD Julian Day").grid(column=8, row=2)
    Label(clocks, text="   ").grid(column=7, row=2)
    Entry(clocks,textvariable=print_hours_from_last_sunset,width=8,font="narkisim 16", justify="center").grid(column=6, row=1)
    Label(clocks, text= reverse("שעות מהשקיעה") if is_heb_locale else "from sunset").grid(column=6, row=2)    
    Entry(clocks,textvariable=print_LSoT_time,width=8,font="narkisim 20",justify="center",disabledbackground= "gray87").grid(column=5, row=1)
    Label(clocks, text= reverse("שעון מקומי אמיתי") if is_heb_locale else "   Real local time   ").grid(column=5, row=2)    
    Entry(clocks,textvariable=print_lmt_time,width=8,font="narkisim 20",justify="center",disabledbackground= "gray87").grid(column=4, row=1)
    Label(clocks, text=reverse("שעון מקומי ממוצע") if is_heb_locale else "Mean local time").grid(column=4, row=2)
    Entry(clocks,textvariable=print_utc_time,width=8,font="narkisim 16",justify="center").grid(column=3, row=1)
    Label(clocks, text=reverse("(utc) שעון גריניץ") if is_heb_locale else "Greenwich time").grid(column=3, row=2)
    Label(clocks, text=" ").grid(column=2, row=2)
    Entry(clocks,textvariable=print_equation_of_time,width=7,font="narkisim 16",justify="center").grid(column=1, row=1)
    Label(clocks, text=reverse("משוואת הזמן") if is_heb_locale else "equation time").grid(column=1, row=2)
    Entry(clocks,textvariable=print_delta_t,width=8,font="narkisim 16",justify="center").grid(column=0, row=1)
    Label(clocks, text="ΔT (H:M:S)").grid(column=0, row=2)
    clocks.pack()
    
    # אם שני קבצי האפאמאריס לא קיימים באף מקום, יש להוציא הודעת שגיאה מפורטת. עדיין ניתן להשתמש בתוכנות הנלוות
    if eph_440 == False and eph_441s == False:
        tkMessageBox.showinfo("שגיאה", f'בתיקייה\n{cu_dir_path}\n\nלא קיים קובץ אֶפְאֶמְאֶרִיס של נאס"א ששמו\n{"de440.bsp"}\nללא קובץ זה התוכנה אינה יכולה לחשב נתונים\n\nניתן להוריד את הקובץ מאתר כוכבים וזמנים\nhttps://sites.google.com/view/cochavim-uzmanim/\n\nבחלון אפשרויות נוספות ללחוץ על: פתיחת תיקיית כוכבים וזמנים לשים את הקובץ (בשֵׁם זה!) בתיקייה, ולהפעיל מחדש את התוכנה')
        #ws.destroy()
    
    # פעולה קריטית בהפעלת התוכנה: הכנסת תאריך ושעה כלשהם לשעון העליון
    # אני בוחר להגדיר על תאריך ושעה נוכחיים לפי המחשב אבל אפשר כל תאריך ושעה
    set_date_time(datetime.now())
                 
    #------------------------------
    # כאשר התוכנה פועלת כתוכנה סגורה יש לסגור את מסך טעינת התוכנה כשהתוכנה גומרת להיטען
    if getattr(sys, "frozen", False): 
        pyi_splash.close()
        
    #----------------------------------
    # תמיד בפתיחת התוכנה יש לבדוק האם התוכנה עדכנית תוך הגדרה שאין מדובר בבדיקה ידנית שהמשתמש יזם
    # חובה!!! קודם עדכון ידני של חלון התוכנה כדי שהוא לא יתעכב עד ביצוע הבדיקה האם התוכנה עדכנית
    #####ws.update()
    is_cu_software_update(manual=False)
    
    
    # בודק האם מותקן במחשב גופנים מרים ודוד שדרושים לתצוגה טובה של כוכבים וזמנים וגופן מירים שדרוש לתצוגה טובה של שעון ההלכה
    is_heb_fonts = "Narkisim" and "David" and "Miriam" in tkfont.families() # and "Segoe UI"
    # אם הגופנים ההלו לא מותקנים במערכת ההפעלה
    if not is_heb_fonts:
        # הודעה בעברית אם התוכנה מוצגת בעברית
        if is_heb_locale:
            tkMessageBox.showinfo(reverse("התרעה"), reverse("שלושת הגופנים: 'נרקיסים, דוד, מרים' מווינדוס, חייבים להיות מותקנים בתיקיית הפונטים של מערכת ההפעלה לצורך תצוגה נכונה"))
        # אם התוכנה באנגלית - ההודעה באנגלית
        else:
            tkMessageBox.showinfo("warning", "The three fonts: 'Narkisim, David, Miriam' from Windows, must be installed in the operating system's fonts folder for correct display")
        # מחזיר את הפוקוס לחלון הראשי כי אחרת אי אפשר לצאת מהתוכנה בלחיצה על אסקייפ או לשנות מיקומים בלחצני החיצים
        ws.focus_force()
    
    if settings_dict["start_halacha_clock"]:
        halacha_clock() # אם רוצים ששעון ההלכה ייפתח מייד בעליית התוכנה
        
    #---------------------------------------------
    # בין אם יש רישיון ובין אם אין רישיון חייבת להיות לולאה אינסופית על החלון הראשי כך
    ws.mainloop()


